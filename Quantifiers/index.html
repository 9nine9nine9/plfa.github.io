<!DOCTYPE html>
<html lang="en">
    <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../public/css/style.css">
  
  <title>Programming Language Foundations in Agda – Quantifiers</title>
  
  
  
</head>

    <body>
        <header class="site-header">
    <div class="wrapper">
        <a class="site-title" href="../">Programming Language Foundations in Agda</a>
        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="../">The Book</a>
                <a class="page-link" href="../Announcements/">Announcements</a>
                <a class="page-link" href="../GettingStarted/">Getting Started</a>
                <a class="page-link" href="../Citing/">Citing</a>
                <a class="page-link" href="https://agda-zh.github.io/PLFA-zh/">中文</a>
            </div>
        </nav>
    </div>
</header>

        <main class="page-content" aria-label="Content">
            <div class="wrapper">
                <article class="post">
    <nav class="pager">
    <ul class="pagination">
        
        <li><a class="pagelink" href="../Negation/">Prev</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Quantifiers.lagda.md">Source</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="../Decidable/">Next</a></li>
        <li class="separator">&bullet;</li>
        
    </ul>
</nav>

    <header class="post-header">
        <h1 class="post-title" id="quantifiers">Quantifiers: Universals and existentials</h1>
    </header>
    <div class="post-content">
        <pre class="Agda"><a id="159" class="Keyword">module</a> <a id="166" href="../Quantifiers/" class="Module">plfa.part1.Quantifiers</a> <a id="189" class="Keyword">where</a>
</pre>
<p>This chapter introduces universal and existential quantification.</p>
<h2 id="imports">Imports</h2>
<pre class="Agda"><a id="283" class="Keyword">import</a> <a id="290" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="328" class="Symbol">as</a> <a id="331" class="Module">Eq</a>
<a id="334" class="Keyword">open</a> <a id="339" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="342" class="Keyword">using</a> <a id="348" class="Symbol">(</a><a id="349" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="352" class="Symbol">;</a> <a id="354" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="358" class="Symbol">)</a>
<a id="360" class="Keyword">open</a> <a id="365" class="Keyword">import</a> <a id="372" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.html" class="Module">Data.Nat</a> <a id="381" class="Keyword">using</a> <a id="387" class="Symbol">(</a><a id="388" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="389" class="Symbol">;</a> <a id="391" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="395" class="Symbol">;</a> <a id="397" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="400" class="Symbol">;</a> <a id="402" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a><a id="405" class="Symbol">;</a> <a id="407" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#528" class="Primitive Operator">_*_</a><a id="410" class="Symbol">)</a>
<a id="412" class="Keyword">open</a> <a id="417" class="Keyword">import</a> <a id="424" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="441" class="Keyword">using</a> <a id="447" class="Symbol">(</a><a id="448" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#653" class="Function Operator">¬_</a><a id="450" class="Symbol">)</a>
<a id="452" class="Keyword">open</a> <a id="457" class="Keyword">import</a> <a id="464" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html" class="Module">Data.Product</a> <a id="477" class="Keyword">using</a> <a id="483" class="Symbol">(</a><a id="484" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1167" class="Function Operator">_×_</a><a id="487" class="Symbol">;</a> <a id="489" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="494" class="Symbol">;</a> <a id="496" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Sigma.html#264" class="Field">proj₂</a><a id="501" class="Symbol">)</a> <a id="503" class="Keyword">renaming</a> <a id="512" class="Symbol">(</a><a id="513" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a> <a id="517" class="Symbol">to</a> <a id="_,_"></a><a id="520" href="../Quantifiers/#520" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="525" class="Symbol">)</a>
<a id="527" class="Keyword">open</a> <a id="532" class="Keyword">import</a> <a id="539" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.html" class="Module">Data.Sum</a> <a id="548" class="Keyword">using</a> <a id="554" class="Symbol">(</a><a id="555" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#728" class="Datatype Operator">_⊎_</a><a id="558" class="Symbol">;</a> <a id="560" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#778" class="InductiveConstructor">inj₁</a><a id="564" class="Symbol">;</a> <a id="566" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#803" class="InductiveConstructor">inj₂</a><a id="570" class="Symbol">)</a>
<a id="572" class="Keyword">open</a> <a id="577" class="Keyword">import</a> <a id="584" href="../Isomorphism/" class="Module">plfa.part1.Isomorphism</a> <a id="607" class="Keyword">using</a> <a id="613" class="Symbol">(</a><a id="614" href="../Isomorphism/#4329" class="Record Operator">_≃_</a><a id="617" class="Symbol">;</a> <a id="619" href="../Isomorphism/#2666" class="Postulate">extensionality</a><a id="633" class="Symbol">)</a>
</pre>
<h2 id="universals">Universals</h2>
<p>We formalise universal quantification using the dependent function type, which has appeared throughout this book. For instance, in Chapter Induction we showed addition is associative:</p>
<pre><code>+-assoc : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)</code></pre>
<p>which asserts for all natural numbers <code>m</code>, <code>n</code>, and <code>p</code> that <code>(m + n) + p ≡ m + (n + p)</code> holds. It is a dependent function, which given values for <code>m</code>, <code>n</code>, and <code>p</code> returns evidence for the corresponding equation.</p>
<p>In general, given a variable <code>x</code> of type <code>A</code> and a proposition <code>B x</code> which contains <code>x</code> as a free variable, the universally quantified proposition <code>∀ (x : A) → B x</code> holds if for every term <code>M</code> of type <code>A</code> the proposition <code>B M</code> holds. Here <code>B M</code> stands for the proposition <code>B x</code> with each free occurrence of <code>x</code> replaced by <code>M</code>. Variable <code>x</code> appears free in <code>B x</code> but bound in <code>∀ (x : A) → B x</code>.</p>
<p>Evidence that <code>∀ (x : A) → B x</code> holds is of the form</p>
<pre><code>λ (x : A) → N x</code></pre>
<p>where <code>N x</code> is a term of type <code>B x</code>, and <code>N x</code> and <code>B x</code> both contain a free variable <code>x</code> of type <code>A</code>. Given a term <code>L</code> providing evidence that <code>∀ (x : A) → B x</code> holds, and a term <code>M</code> of type <code>A</code>, the term <code>L M</code> provides evidence that <code>B M</code> holds. In other words, evidence that <code>∀ (x : A) → B x</code> holds is a function that converts a term <code>M</code> of type <code>A</code> into evidence that <code>B M</code> holds.</p>
Put another way, if we know that <code>∀ (x : A) → B x</code> holds and that <code>M</code> is a term of type <code>A</code> then we may conclude that <code>B M</code> holds:
<pre class="Agda"><a id="∀-elim"></a><a id="2111" href="../Quantifiers/#2111" class="Function">∀-elim</a> <a id="2118" class="Symbol">:</a> <a id="2120" class="Symbol">∀</a> <a id="2122" class="Symbol">{</a><a id="2123" href="../Quantifiers/#2123" class="Bound">A</a> <a id="2125" class="Symbol">:</a> <a id="2127" class="PrimitiveType">Set</a><a id="2130" class="Symbol">}</a> <a id="2132" class="Symbol">{</a><a id="2133" href="../Quantifiers/#2133" class="Bound">B</a> <a id="2135" class="Symbol">:</a> <a id="2137" href="../Quantifiers/#2123" class="Bound">A</a> <a id="2139" class="Symbol">→</a> <a id="2141" class="PrimitiveType">Set</a><a id="2144" class="Symbol">}</a>
  <a id="2148" class="Symbol">→</a> <a id="2150" class="Symbol">(</a><a id="2151" href="../Quantifiers/#2151" class="Bound">L</a> <a id="2153" class="Symbol">:</a> <a id="2155" class="Symbol">∀</a> <a id="2157" class="Symbol">(</a><a id="2158" href="../Quantifiers/#2158" class="Bound">x</a> <a id="2160" class="Symbol">:</a> <a id="2162" href="../Quantifiers/#2123" class="Bound">A</a><a id="2163" class="Symbol">)</a> <a id="2165" class="Symbol">→</a> <a id="2167" href="../Quantifiers/#2133" class="Bound">B</a> <a id="2169" href="../Quantifiers/#2158" class="Bound">x</a><a id="2170" class="Symbol">)</a>
  <a id="2174" class="Symbol">→</a> <a id="2176" class="Symbol">(</a><a id="2177" href="../Quantifiers/#2177" class="Bound">M</a> <a id="2179" class="Symbol">:</a> <a id="2181" href="../Quantifiers/#2123" class="Bound">A</a><a id="2182" class="Symbol">)</a>
    <a id="2188" class="Comment">-----------------</a>
  <a id="2208" class="Symbol">→</a> <a id="2210" href="../Quantifiers/#2133" class="Bound">B</a> <a id="2212" href="../Quantifiers/#2177" class="Bound">M</a>
<a id="2214" href="../Quantifiers/#2111" class="Function">∀-elim</a> <a id="2221" href="../Quantifiers/#2221" class="Bound">L</a> <a id="2223" href="../Quantifiers/#2223" class="Bound">M</a> <a id="2225" class="Symbol">=</a> <a id="2227" href="../Quantifiers/#2221" class="Bound">L</a> <a id="2229" href="../Quantifiers/#2223" class="Bound">M</a>
</pre>
<p>As with <code>→-elim</code>, the rule corresponds to function application.</p>
<p>Functions arise as a special case of dependent functions, where the range does not depend on a variable drawn from the domain. When a function is viewed as evidence of implication, both its argument and result are viewed as evidence, whereas when a dependent function is viewed as evidence of a universal, its argument is viewed as an element of a data type and its result is viewed as evidence of a proposition that depends on the argument. This difference is largely a matter of interpretation, since in Agda a value of a type and evidence of a proposition are indistinguishable.</p>
<p>Dependent function types are sometimes referred to as dependent products, because if <code>A</code> is a finite type with values <code>x₁ , ⋯ , xₙ</code>, and if each of the types <code>B x₁ , ⋯ , B xₙ</code> has <code>m₁ , ⋯ , mₙ</code> distinct members, then <code>∀ (x : A) → B x</code> has <code>m₁ * ⋯ * mₙ</code> members. Indeed, sometimes the notation <code>∀ (x : A) → B x</code> is replaced by a notation such as <code>Π[ x ∈ A ] (B x)</code>, where <code>Π</code> stands for product. However, we will stick with the name dependent function, because (as we will see) dependent product is ambiguous.</p>
<h4 id="exercise--distrib--recommended">Exercise <code>∀-distrib-×</code> (recommended)</h4>
Show that universals distribute over conjunction:
<pre class="Agda"><a id="3493" class="Keyword">postulate</a>
  <a id="∀-distrib-×"></a><a id="3505" href="../Quantifiers/#3505" class="Postulate">∀-distrib-×</a> <a id="3517" class="Symbol">:</a> <a id="3519" class="Symbol">∀</a> <a id="3521" class="Symbol">{</a><a id="3522" href="../Quantifiers/#3522" class="Bound">A</a> <a id="3524" class="Symbol">:</a> <a id="3526" class="PrimitiveType">Set</a><a id="3529" class="Symbol">}</a> <a id="3531" class="Symbol">{</a><a id="3532" href="../Quantifiers/#3532" class="Bound">B</a> <a id="3534" href="../Quantifiers/#3534" class="Bound">C</a> <a id="3536" class="Symbol">:</a> <a id="3538" href="../Quantifiers/#3522" class="Bound">A</a> <a id="3540" class="Symbol">→</a> <a id="3542" class="PrimitiveType">Set</a><a id="3545" class="Symbol">}</a> <a id="3547" class="Symbol">→</a>
    <a id="3553" class="Symbol">(∀</a> <a id="3556" class="Symbol">(</a><a id="3557" href="../Quantifiers/#3557" class="Bound">x</a> <a id="3559" class="Symbol">:</a> <a id="3561" href="../Quantifiers/#3522" class="Bound">A</a><a id="3562" class="Symbol">)</a> <a id="3564" class="Symbol">→</a> <a id="3566" href="../Quantifiers/#3532" class="Bound">B</a> <a id="3568" href="../Quantifiers/#3557" class="Bound">x</a> <a id="3570" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1167" class="Function Operator">×</a> <a id="3572" href="../Quantifiers/#3534" class="Bound">C</a> <a id="3574" href="../Quantifiers/#3557" class="Bound">x</a><a id="3575" class="Symbol">)</a> <a id="3577" href="../Isomorphism/#4329" class="Record Operator">≃</a> <a id="3579" class="Symbol">(∀</a> <a id="3582" class="Symbol">(</a><a id="3583" href="../Quantifiers/#3583" class="Bound">x</a> <a id="3585" class="Symbol">:</a> <a id="3587" href="../Quantifiers/#3522" class="Bound">A</a><a id="3588" class="Symbol">)</a> <a id="3590" class="Symbol">→</a> <a id="3592" href="../Quantifiers/#3532" class="Bound">B</a> <a id="3594" href="../Quantifiers/#3583" class="Bound">x</a><a id="3595" class="Symbol">)</a> <a id="3597" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1167" class="Function Operator">×</a> <a id="3599" class="Symbol">(∀</a> <a id="3602" class="Symbol">(</a><a id="3603" href="../Quantifiers/#3603" class="Bound">x</a> <a id="3605" class="Symbol">:</a> <a id="3607" href="../Quantifiers/#3522" class="Bound">A</a><a id="3608" class="Symbol">)</a> <a id="3610" class="Symbol">→</a> <a id="3612" href="../Quantifiers/#3534" class="Bound">C</a> <a id="3614" href="../Quantifiers/#3603" class="Bound">x</a><a id="3615" class="Symbol">)</a>
</pre>
<p>Compare this with the result (<code>→-distrib-×</code>) in Chapter <a href="../Connectives/">Connectives</a>.</p>
<h4 id="exercise--implies--practice">Exercise <code>⊎∀-implies-∀⊎</code> (practice)</h4>
Show that a disjunction of universals implies a universal of disjunctions:
<pre class="Agda"><a id="3829" class="Keyword">postulate</a>
  <a id="⊎∀-implies-∀⊎"></a><a id="3841" href="../Quantifiers/#3841" class="Postulate">⊎∀-implies-∀⊎</a> <a id="3855" class="Symbol">:</a> <a id="3857" class="Symbol">∀</a> <a id="3859" class="Symbol">{</a><a id="3860" href="../Quantifiers/#3860" class="Bound">A</a> <a id="3862" class="Symbol">:</a> <a id="3864" class="PrimitiveType">Set</a><a id="3867" class="Symbol">}</a> <a id="3869" class="Symbol">{</a><a id="3870" href="../Quantifiers/#3870" class="Bound">B</a> <a id="3872" href="../Quantifiers/#3872" class="Bound">C</a> <a id="3874" class="Symbol">:</a> <a id="3876" href="../Quantifiers/#3860" class="Bound">A</a> <a id="3878" class="Symbol">→</a> <a id="3880" class="PrimitiveType">Set</a><a id="3883" class="Symbol">}</a> <a id="3885" class="Symbol">→</a>
    <a id="3891" class="Symbol">(∀</a> <a id="3894" class="Symbol">(</a><a id="3895" href="../Quantifiers/#3895" class="Bound">x</a> <a id="3897" class="Symbol">:</a> <a id="3899" href="../Quantifiers/#3860" class="Bound">A</a><a id="3900" class="Symbol">)</a> <a id="3902" class="Symbol">→</a> <a id="3904" href="../Quantifiers/#3870" class="Bound">B</a> <a id="3906" href="../Quantifiers/#3895" class="Bound">x</a><a id="3907" class="Symbol">)</a> <a id="3909" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#728" class="Datatype Operator">⊎</a> <a id="3911" class="Symbol">(∀</a> <a id="3914" class="Symbol">(</a><a id="3915" href="../Quantifiers/#3915" class="Bound">x</a> <a id="3917" class="Symbol">:</a> <a id="3919" href="../Quantifiers/#3860" class="Bound">A</a><a id="3920" class="Symbol">)</a> <a id="3922" class="Symbol">→</a> <a id="3924" href="../Quantifiers/#3872" class="Bound">C</a> <a id="3926" href="../Quantifiers/#3915" class="Bound">x</a><a id="3927" class="Symbol">)</a> <a id="3929" class="Symbol">→</a> <a id="3931" class="Symbol">∀</a> <a id="3933" class="Symbol">(</a><a id="3934" href="../Quantifiers/#3934" class="Bound">x</a> <a id="3936" class="Symbol">:</a> <a id="3938" href="../Quantifiers/#3860" class="Bound">A</a><a id="3939" class="Symbol">)</a> <a id="3941" class="Symbol">→</a> <a id="3943" href="../Quantifiers/#3870" class="Bound">B</a> <a id="3945" href="../Quantifiers/#3934" class="Bound">x</a> <a id="3947" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#728" class="Datatype Operator">⊎</a> <a id="3949" href="../Quantifiers/#3872" class="Bound">C</a> <a id="3951" href="../Quantifiers/#3934" class="Bound">x</a>
</pre>
<p>Does the converse hold? If so, prove; if not, explain why.</p>
<h4 id="exercise---practice">Exercise <code>∀-×</code> (practice)</h4>
Consider the following type.
<pre class="Agda"><a id="4083" class="Keyword">data</a> <a id="Tri"></a><a id="4088" href="../Quantifiers/#4088" class="Datatype">Tri</a> <a id="4092" class="Symbol">:</a> <a id="4094" class="PrimitiveType">Set</a> <a id="4098" class="Keyword">where</a>
  <a id="Tri.aa"></a><a id="4106" href="../Quantifiers/#4106" class="InductiveConstructor">aa</a> <a id="4109" class="Symbol">:</a> <a id="4111" href="../Quantifiers/#4088" class="Datatype">Tri</a>
  <a id="Tri.bb"></a><a id="4117" href="../Quantifiers/#4117" class="InductiveConstructor">bb</a> <a id="4120" class="Symbol">:</a> <a id="4122" href="../Quantifiers/#4088" class="Datatype">Tri</a>
  <a id="Tri.cc"></a><a id="4128" href="../Quantifiers/#4128" class="InductiveConstructor">cc</a> <a id="4131" class="Symbol">:</a> <a id="4133" href="../Quantifiers/#4088" class="Datatype">Tri</a>
</pre>
<p>Let <code>B</code> be a type indexed by <code>Tri</code>, that is <code>B : Tri → Set</code>. Show that <code>∀ (x : Tri) → B x</code> is isomorphic to <code>B aa × B bb × B cc</code>. Hint: you will need to postulate a version of extensionality that works for dependent functions.</p>
<h2 id="existentials">Existentials</h2>
<p>Given a variable <code>x</code> of type <code>A</code> and a proposition <code>B x</code> which contains <code>x</code> as a free variable, the existentially quantified proposition <code>Σ[ x ∈ A ] B x</code> holds if for some term <code>M</code> of type <code>A</code> the proposition <code>B M</code> holds. Here <code>B M</code> stands for the proposition <code>B x</code> with each free occurrence of <code>x</code> replaced by <code>M</code>. Variable <code>x</code> appears free in <code>B x</code> but bound in <code>Σ[ x ∈ A ] B x</code>.</p>
We formalise existential quantification by declaring a suitable inductive type:
<pre class="Agda"><a id="4856" class="Keyword">data</a> <a id="Σ"></a><a id="4861" href="../Quantifiers/#4861" class="Datatype">Σ</a> <a id="4863" class="Symbol">(</a><a id="4864" href="../Quantifiers/#4864" class="Bound">A</a> <a id="4866" class="Symbol">:</a> <a id="4868" class="PrimitiveType">Set</a><a id="4871" class="Symbol">)</a> <a id="4873" class="Symbol">(</a><a id="4874" href="../Quantifiers/#4874" class="Bound">B</a> <a id="4876" class="Symbol">:</a> <a id="4878" href="../Quantifiers/#4864" class="Bound">A</a> <a id="4880" class="Symbol">→</a> <a id="4882" class="PrimitiveType">Set</a><a id="4885" class="Symbol">)</a> <a id="4887" class="Symbol">:</a> <a id="4889" class="PrimitiveType">Set</a> <a id="4893" class="Keyword">where</a>
  <a id="Σ.⟨_,_⟩"></a><a id="4901" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟨_,_⟩</a> <a id="4907" class="Symbol">:</a> <a id="4909" class="Symbol">(</a><a id="4910" href="../Quantifiers/#4910" class="Bound">x</a> <a id="4912" class="Symbol">:</a> <a id="4914" href="../Quantifiers/#4864" class="Bound">A</a><a id="4915" class="Symbol">)</a> <a id="4917" class="Symbol">→</a> <a id="4919" href="../Quantifiers/#4874" class="Bound">B</a> <a id="4921" href="../Quantifiers/#4910" class="Bound">x</a> <a id="4923" class="Symbol">→</a> <a id="4925" href="../Quantifiers/#4861" class="Datatype">Σ</a> <a id="4927" href="../Quantifiers/#4864" class="Bound">A</a> <a id="4929" href="../Quantifiers/#4874" class="Bound">B</a>
</pre>
We define a convenient syntax for existentials as follows:
<pre class="Agda"><a id="Σ-syntax"></a><a id="4998" href="../Quantifiers/#4998" class="Function">Σ-syntax</a> <a id="5007" class="Symbol">=</a> <a id="5009" href="../Quantifiers/#4861" class="Datatype">Σ</a>
<a id="5011" class="Keyword">infix</a> <a id="5017" class="Number">2</a> <a id="5019" href="../Quantifiers/#4998" class="Function">Σ-syntax</a>
<a id="5028" class="Keyword">syntax</a> <a id="5035" href="../Quantifiers/#4998" class="Function">Σ-syntax</a> <a id="5044" class="Bound">A</a> <a id="5046" class="Symbol">(λ</a> <a id="5049" class="Bound">x</a> <a id="5051" class="Symbol">→</a> <a id="5053" class="Bound">B</a><a id="5054" class="Symbol">)</a> <a id="5056" class="Symbol">=</a> <a id="5058" class="Function">Σ[</a> <a id="5061" class="Bound">x</a> <a id="5063" class="Function">∈</a> <a id="5065" class="Bound">A</a> <a id="5067" class="Function">]</a> <a id="5069" class="Bound">B</a>
</pre>
<p>This is our first use of a syntax declaration, which specifies that the term on the left may be written with the syntax on the right. The special syntax is available only when the identifier <code>Σ-syntax</code> is imported.</p>
<p>Evidence that <code>Σ[ x ∈ A ] B x</code> holds is of the form <code>⟨ M , N ⟩</code> where <code>M</code> is a term of type <code>A</code>, and <code>N</code> is evidence that <code>B M</code> holds.</p>
Equivalently, we could also declare existentials as a record type:
<pre class="Agda"><a id="5498" class="Keyword">record</a> <a id="Σ′"></a><a id="5505" href="../Quantifiers/#5505" class="Record">Σ′</a> <a id="5508" class="Symbol">(</a><a id="5509" href="../Quantifiers/#5509" class="Bound">A</a> <a id="5511" class="Symbol">:</a> <a id="5513" class="PrimitiveType">Set</a><a id="5516" class="Symbol">)</a> <a id="5518" class="Symbol">(</a><a id="5519" href="../Quantifiers/#5519" class="Bound">B</a> <a id="5521" class="Symbol">:</a> <a id="5523" href="../Quantifiers/#5509" class="Bound">A</a> <a id="5525" class="Symbol">→</a> <a id="5527" class="PrimitiveType">Set</a><a id="5530" class="Symbol">)</a> <a id="5532" class="Symbol">:</a> <a id="5534" class="PrimitiveType">Set</a> <a id="5538" class="Keyword">where</a>
  <a id="5546" class="Keyword">field</a>
    <a id="Σ′.proj₁′"></a><a id="5556" href="../Quantifiers/#5556" class="Field">proj₁′</a> <a id="5563" class="Symbol">:</a> <a id="5565" href="../Quantifiers/#5509" class="Bound">A</a>
    <a id="Σ′.proj₂′"></a><a id="5571" href="../Quantifiers/#5571" class="Field">proj₂′</a> <a id="5578" class="Symbol">:</a> <a id="5580" href="../Quantifiers/#5519" class="Bound">B</a> <a id="5582" href="../Quantifiers/#5556" class="Field">proj₁′</a>
</pre>
<p>Here record construction</p>
<pre><code>record
  { proj₁′ = M
  ; proj₂′ = N
  }</code></pre>
<p>corresponds to the term</p>
<pre><code>⟨ M , N ⟩</code></pre>
<p>where <code>M</code> is a term of type <code>A</code> and <code>N</code> is a term of type <code>B M</code>.</p>
<p>Products arise as a special case of existentials, where the second component does not depend on a variable drawn from the first component. When a product is viewed as evidence of a conjunction, both of its components are viewed as evidence, whereas when it is viewed as evidence of an existential, the first component is viewed as an element of a datatype and the second component is viewed as evidence of a proposition that depends on the first component. This difference is largely a matter of interpretation, since in Agda a value of a type and evidence of a proposition are indistinguishable.</p>
<p>Existentials are sometimes referred to as dependent sums, because if <code>A</code> is a finite type with values <code>x₁ , ⋯ , xₙ</code>, and if each of the types <code>B x₁ , ⋯ B xₙ</code> has <code>m₁ , ⋯ , mₙ</code> distinct members, then <code>Σ[ x ∈ A ] B x</code> has <code>m₁ + ⋯ + mₙ</code> members, which explains the choice of notation for existentials, since <code>Σ</code> stands for sum.</p>
<p>Existentials are sometimes referred to as dependent products, since products arise as a special case. However, that choice of names is doubly confusing, since universals also have a claim to the name dependent product and since existentials also have a claim to the name dependent sum.</p>
A common notation for existentials is <code>∃</code> (analogous to <code>∀</code> for universals). We follow the convention of the Agda standard library, and reserve this notation for the case where the domain of the bound variable is left implicit:
<pre class="Agda"><a id="∃"></a><a id="7229" href="../Quantifiers/#7229" class="Function">∃</a> <a id="7231" class="Symbol">:</a> <a id="7233" class="Symbol">∀</a> <a id="7235" class="Symbol">{</a><a id="7236" href="../Quantifiers/#7236" class="Bound">A</a> <a id="7238" class="Symbol">:</a> <a id="7240" class="PrimitiveType">Set</a><a id="7243" class="Symbol">}</a> <a id="7245" class="Symbol">(</a><a id="7246" href="../Quantifiers/#7246" class="Bound">B</a> <a id="7248" class="Symbol">:</a> <a id="7250" href="../Quantifiers/#7236" class="Bound">A</a> <a id="7252" class="Symbol">→</a> <a id="7254" class="PrimitiveType">Set</a><a id="7257" class="Symbol">)</a> <a id="7259" class="Symbol">→</a> <a id="7261" class="PrimitiveType">Set</a>
<a id="7265" href="../Quantifiers/#7229" class="Function">∃</a> <a id="7267" class="Symbol">{</a><a id="7268" href="../Quantifiers/#7268" class="Bound">A</a><a id="7269" class="Symbol">}</a> <a id="7271" href="../Quantifiers/#7271" class="Bound">B</a> <a id="7273" class="Symbol">=</a> <a id="7275" href="../Quantifiers/#4861" class="Datatype">Σ</a> <a id="7277" href="../Quantifiers/#7268" class="Bound">A</a> <a id="7279" href="../Quantifiers/#7271" class="Bound">B</a>

<a id="∃-syntax"></a><a id="7282" href="../Quantifiers/#7282" class="Function">∃-syntax</a> <a id="7291" class="Symbol">=</a> <a id="7293" href="../Quantifiers/#7229" class="Function">∃</a>
<a id="7295" class="Keyword">syntax</a> <a id="7302" href="../Quantifiers/#7282" class="Function">∃-syntax</a> <a id="7311" class="Symbol">(λ</a> <a id="7314" class="Bound">x</a> <a id="7316" class="Symbol">→</a> <a id="7318" class="Bound">B</a><a id="7319" class="Symbol">)</a> <a id="7321" class="Symbol">=</a> <a id="7323" class="Function">∃[</a> <a id="7326" class="Bound">x</a> <a id="7328" class="Function">]</a> <a id="7330" class="Bound">B</a>
</pre>
<p>The special syntax is available only when the identifier <code>∃-syntax</code> is imported. We will tend to use this syntax, since it is shorter and more familiar.</p>
Given evidence that <code>∀ x → B x → C</code> holds, where <code>C</code> does not contain <code>x</code> as a free variable, and given evidence that <code>∃[ x ] B x</code> holds, we may conclude that <code>C</code> holds:
<pre class="Agda"><a id="∃-elim"></a><a id="7664" href="../Quantifiers/#7664" class="Function">∃-elim</a> <a id="7671" class="Symbol">:</a> <a id="7673" class="Symbol">∀</a> <a id="7675" class="Symbol">{</a><a id="7676" href="../Quantifiers/#7676" class="Bound">A</a> <a id="7678" class="Symbol">:</a> <a id="7680" class="PrimitiveType">Set</a><a id="7683" class="Symbol">}</a> <a id="7685" class="Symbol">{</a><a id="7686" href="../Quantifiers/#7686" class="Bound">B</a> <a id="7688" class="Symbol">:</a> <a id="7690" href="../Quantifiers/#7676" class="Bound">A</a> <a id="7692" class="Symbol">→</a> <a id="7694" class="PrimitiveType">Set</a><a id="7697" class="Symbol">}</a> <a id="7699" class="Symbol">{</a><a id="7700" href="../Quantifiers/#7700" class="Bound">C</a> <a id="7702" class="Symbol">:</a> <a id="7704" class="PrimitiveType">Set</a><a id="7707" class="Symbol">}</a>
  <a id="7711" class="Symbol">→</a> <a id="7713" class="Symbol">(∀</a> <a id="7716" href="../Quantifiers/#7716" class="Bound">x</a> <a id="7718" class="Symbol">→</a> <a id="7720" href="../Quantifiers/#7686" class="Bound">B</a> <a id="7722" href="../Quantifiers/#7716" class="Bound">x</a> <a id="7724" class="Symbol">→</a> <a id="7726" href="../Quantifiers/#7700" class="Bound">C</a><a id="7727" class="Symbol">)</a>
  <a id="7731" class="Symbol">→</a> <a id="7733" href="../Quantifiers/#7282" class="Function">∃[</a> <a id="7736" href="../Quantifiers/#7736" class="Bound">x</a> <a id="7738" href="../Quantifiers/#7282" class="Function">]</a> <a id="7740" href="../Quantifiers/#7686" class="Bound">B</a> <a id="7742" href="../Quantifiers/#7736" class="Bound">x</a>
    <a id="7748" class="Comment">---------------</a>
  <a id="7766" class="Symbol">→</a> <a id="7768" href="../Quantifiers/#7700" class="Bound">C</a>
<a id="7770" href="../Quantifiers/#7664" class="Function">∃-elim</a> <a id="7777" href="../Quantifiers/#7777" class="Bound">f</a> <a id="7779" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟨</a> <a id="7781" href="../Quantifiers/#7781" class="Bound">x</a> <a id="7783" href="../Quantifiers/#4901" class="InductiveConstructor Operator">,</a> <a id="7785" href="../Quantifiers/#7785" class="Bound">y</a> <a id="7787" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟩</a> <a id="7789" class="Symbol">=</a> <a id="7791" href="../Quantifiers/#7777" class="Bound">f</a> <a id="7793" href="../Quantifiers/#7781" class="Bound">x</a> <a id="7795" href="../Quantifiers/#7785" class="Bound">y</a>
</pre>
<p>In other words, if we know for every <code>x</code> of type <code>A</code> that <code>B x</code> implies <code>C</code>, and we know for some <code>x</code> of type <code>A</code> that <code>B x</code> holds, then we may conclude that <code>C</code> holds. This is because we may instantiate that proof that <code>∀ x → B x → C</code> to any value <code>x</code> of type <code>A</code> and any <code>y</code> of type <code>B x</code>, and exactly such values are provided by the evidence for <code>∃[ x ] B x</code>.</p>
Indeed, the converse also holds, and the two together form an isomorphism:
<pre class="Agda"><a id="∀∃-currying"></a><a id="8245" href="../Quantifiers/#8245" class="Function">∀∃-currying</a> <a id="8257" class="Symbol">:</a> <a id="8259" class="Symbol">∀</a> <a id="8261" class="Symbol">{</a><a id="8262" href="../Quantifiers/#8262" class="Bound">A</a> <a id="8264" class="Symbol">:</a> <a id="8266" class="PrimitiveType">Set</a><a id="8269" class="Symbol">}</a> <a id="8271" class="Symbol">{</a><a id="8272" href="../Quantifiers/#8272" class="Bound">B</a> <a id="8274" class="Symbol">:</a> <a id="8276" href="../Quantifiers/#8262" class="Bound">A</a> <a id="8278" class="Symbol">→</a> <a id="8280" class="PrimitiveType">Set</a><a id="8283" class="Symbol">}</a> <a id="8285" class="Symbol">{</a><a id="8286" href="../Quantifiers/#8286" class="Bound">C</a> <a id="8288" class="Symbol">:</a> <a id="8290" class="PrimitiveType">Set</a><a id="8293" class="Symbol">}</a>
  <a id="8297" class="Symbol">→</a> <a id="8299" class="Symbol">(∀</a> <a id="8302" href="../Quantifiers/#8302" class="Bound">x</a> <a id="8304" class="Symbol">→</a> <a id="8306" href="../Quantifiers/#8272" class="Bound">B</a> <a id="8308" href="../Quantifiers/#8302" class="Bound">x</a> <a id="8310" class="Symbol">→</a> <a id="8312" href="../Quantifiers/#8286" class="Bound">C</a><a id="8313" class="Symbol">)</a> <a id="8315" href="../Isomorphism/#4329" class="Record Operator">≃</a> <a id="8317" class="Symbol">(</a><a id="8318" href="../Quantifiers/#7282" class="Function">∃[</a> <a id="8321" href="../Quantifiers/#8321" class="Bound">x</a> <a id="8323" href="../Quantifiers/#7282" class="Function">]</a> <a id="8325" href="../Quantifiers/#8272" class="Bound">B</a> <a id="8327" href="../Quantifiers/#8321" class="Bound">x</a> <a id="8329" class="Symbol">→</a> <a id="8331" href="../Quantifiers/#8286" class="Bound">C</a><a id="8332" class="Symbol">)</a>
<a id="8334" href="../Quantifiers/#8245" class="Function">∀∃-currying</a> <a id="8346" class="Symbol">=</a>
  <a id="8350" class="Keyword">record</a>
    <a id="8361" class="Symbol">{</a> <a id="8363" href="../Isomorphism/#4369" class="Field">to</a>      <a id="8371" class="Symbol">=</a>  <a id="8374" class="Symbol">λ{</a> <a id="8377" href="../Quantifiers/#8377" class="Bound">f</a> <a id="8379" class="Symbol">→</a> <a id="8381" class="Symbol">λ{</a> <a id="8384" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟨</a> <a id="8386" href="../Quantifiers/#8386" class="Bound">x</a> <a id="8388" href="../Quantifiers/#4901" class="InductiveConstructor Operator">,</a> <a id="8390" href="../Quantifiers/#8390" class="Bound">y</a> <a id="8392" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟩</a> <a id="8394" class="Symbol">→</a> <a id="8396" href="../Quantifiers/#8377" class="Bound">f</a> <a id="8398" href="../Quantifiers/#8386" class="Bound">x</a> <a id="8400" href="../Quantifiers/#8390" class="Bound">y</a> <a id="8402" class="Symbol">}}</a>
    <a id="8409" class="Symbol">;</a> <a id="8411" href="../Isomorphism/#4386" class="Field">from</a>    <a id="8419" class="Symbol">=</a>  <a id="8422" class="Symbol">λ{</a> <a id="8425" href="../Quantifiers/#8425" class="Bound">g</a> <a id="8427" class="Symbol">→</a> <a id="8429" class="Symbol">λ{</a> <a id="8432" href="../Quantifiers/#8432" class="Bound">x</a> <a id="8434" class="Symbol">→</a> <a id="8436" class="Symbol">λ{</a> <a id="8439" href="../Quantifiers/#8439" class="Bound">y</a> <a id="8441" class="Symbol">→</a> <a id="8443" href="../Quantifiers/#8425" class="Bound">g</a> <a id="8445" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟨</a> <a id="8447" href="../Quantifiers/#8432" class="Bound">x</a> <a id="8449" href="../Quantifiers/#4901" class="InductiveConstructor Operator">,</a> <a id="8451" href="../Quantifiers/#8439" class="Bound">y</a> <a id="8453" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟩</a> <a id="8455" class="Symbol">}}}</a>
    <a id="8463" class="Symbol">;</a> <a id="8465" href="../Isomorphism/#4403" class="Field">from∘to</a> <a id="8473" class="Symbol">=</a>  <a id="8476" class="Symbol">λ{</a> <a id="8479" href="../Quantifiers/#8479" class="Bound">f</a> <a id="8481" class="Symbol">→</a> <a id="8483" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="8488" class="Symbol">}</a>
    <a id="8494" class="Symbol">;</a> <a id="8496" href="../Isomorphism/#4445" class="Field">to∘from</a> <a id="8504" class="Symbol">=</a>  <a id="8507" class="Symbol">λ{</a> <a id="8510" href="../Quantifiers/#8510" class="Bound">g</a> <a id="8512" class="Symbol">→</a> <a id="8514" href="../Isomorphism/#2666" class="Postulate">extensionality</a> <a id="8529" class="Symbol">λ{</a> <a id="8532" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟨</a> <a id="8534" href="../Quantifiers/#8534" class="Bound">x</a> <a id="8536" href="../Quantifiers/#4901" class="InductiveConstructor Operator">,</a> <a id="8538" href="../Quantifiers/#8538" class="Bound">y</a> <a id="8540" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟩</a> <a id="8542" class="Symbol">→</a> <a id="8544" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="8549" class="Symbol">}}</a>
    <a id="8556" class="Symbol">}</a>
</pre>
<p>The result can be viewed as a generalisation of currying. Indeed, the code to establish the isomorphism is identical to what we wrote when discussing <a href="../Connectives/#implication">implication</a>.</p>
<h4 id="exercise--distrib--recommended-1">Exercise <code>∃-distrib-⊎</code> (recommended)</h4>
Show that existentials distribute over disjunction:
<pre class="Agda"><a id="8855" class="Keyword">postulate</a>
  <a id="∃-distrib-⊎"></a><a id="8867" href="../Quantifiers/#8867" class="Postulate">∃-distrib-⊎</a> <a id="8879" class="Symbol">:</a> <a id="8881" class="Symbol">∀</a> <a id="8883" class="Symbol">{</a><a id="8884" href="../Quantifiers/#8884" class="Bound">A</a> <a id="8886" class="Symbol">:</a> <a id="8888" class="PrimitiveType">Set</a><a id="8891" class="Symbol">}</a> <a id="8893" class="Symbol">{</a><a id="8894" href="../Quantifiers/#8894" class="Bound">B</a> <a id="8896" href="../Quantifiers/#8896" class="Bound">C</a> <a id="8898" class="Symbol">:</a> <a id="8900" href="../Quantifiers/#8884" class="Bound">A</a> <a id="8902" class="Symbol">→</a> <a id="8904" class="PrimitiveType">Set</a><a id="8907" class="Symbol">}</a> <a id="8909" class="Symbol">→</a>
    <a id="8915" href="../Quantifiers/#7282" class="Function">∃[</a> <a id="8918" href="../Quantifiers/#8918" class="Bound">x</a> <a id="8920" href="../Quantifiers/#7282" class="Function">]</a> <a id="8922" class="Symbol">(</a><a id="8923" href="../Quantifiers/#8894" class="Bound">B</a> <a id="8925" href="../Quantifiers/#8918" class="Bound">x</a> <a id="8927" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#728" class="Datatype Operator">⊎</a> <a id="8929" href="../Quantifiers/#8896" class="Bound">C</a> <a id="8931" href="../Quantifiers/#8918" class="Bound">x</a><a id="8932" class="Symbol">)</a> <a id="8934" href="../Isomorphism/#4329" class="Record Operator">≃</a> <a id="8936" class="Symbol">(</a><a id="8937" href="../Quantifiers/#7282" class="Function">∃[</a> <a id="8940" href="../Quantifiers/#8940" class="Bound">x</a> <a id="8942" href="../Quantifiers/#7282" class="Function">]</a> <a id="8944" href="../Quantifiers/#8894" class="Bound">B</a> <a id="8946" href="../Quantifiers/#8940" class="Bound">x</a><a id="8947" class="Symbol">)</a> <a id="8949" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#728" class="Datatype Operator">⊎</a> <a id="8951" class="Symbol">(</a><a id="8952" href="../Quantifiers/#7282" class="Function">∃[</a> <a id="8955" href="../Quantifiers/#8955" class="Bound">x</a> <a id="8957" href="../Quantifiers/#7282" class="Function">]</a> <a id="8959" href="../Quantifiers/#8896" class="Bound">C</a> <a id="8961" href="../Quantifiers/#8955" class="Bound">x</a><a id="8962" class="Symbol">)</a>
</pre>
<h4 id="exercise--implies--practice-1">Exercise <code>∃×-implies-×∃</code> (practice)</h4>
Show that an existential of conjunctions implies a conjunction of existentials:
<pre class="Agda"><a id="9095" class="Keyword">postulate</a>
  <a id="∃×-implies-×∃"></a><a id="9107" href="../Quantifiers/#9107" class="Postulate">∃×-implies-×∃</a> <a id="9121" class="Symbol">:</a> <a id="9123" class="Symbol">∀</a> <a id="9125" class="Symbol">{</a><a id="9126" href="../Quantifiers/#9126" class="Bound">A</a> <a id="9128" class="Symbol">:</a> <a id="9130" class="PrimitiveType">Set</a><a id="9133" class="Symbol">}</a> <a id="9135" class="Symbol">{</a><a id="9136" href="../Quantifiers/#9136" class="Bound">B</a> <a id="9138" href="../Quantifiers/#9138" class="Bound">C</a> <a id="9140" class="Symbol">:</a> <a id="9142" href="../Quantifiers/#9126" class="Bound">A</a> <a id="9144" class="Symbol">→</a> <a id="9146" class="PrimitiveType">Set</a><a id="9149" class="Symbol">}</a> <a id="9151" class="Symbol">→</a>
    <a id="9157" href="../Quantifiers/#7282" class="Function">∃[</a> <a id="9160" href="../Quantifiers/#9160" class="Bound">x</a> <a id="9162" href="../Quantifiers/#7282" class="Function">]</a> <a id="9164" class="Symbol">(</a><a id="9165" href="../Quantifiers/#9136" class="Bound">B</a> <a id="9167" href="../Quantifiers/#9160" class="Bound">x</a> <a id="9169" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1167" class="Function Operator">×</a> <a id="9171" href="../Quantifiers/#9138" class="Bound">C</a> <a id="9173" href="../Quantifiers/#9160" class="Bound">x</a><a id="9174" class="Symbol">)</a> <a id="9176" class="Symbol">→</a> <a id="9178" class="Symbol">(</a><a id="9179" href="../Quantifiers/#7282" class="Function">∃[</a> <a id="9182" href="../Quantifiers/#9182" class="Bound">x</a> <a id="9184" href="../Quantifiers/#7282" class="Function">]</a> <a id="9186" href="../Quantifiers/#9136" class="Bound">B</a> <a id="9188" href="../Quantifiers/#9182" class="Bound">x</a><a id="9189" class="Symbol">)</a> <a id="9191" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1167" class="Function Operator">×</a> <a id="9193" class="Symbol">(</a><a id="9194" href="../Quantifiers/#7282" class="Function">∃[</a> <a id="9197" href="../Quantifiers/#9197" class="Bound">x</a> <a id="9199" href="../Quantifiers/#7282" class="Function">]</a> <a id="9201" href="../Quantifiers/#9138" class="Bound">C</a> <a id="9203" href="../Quantifiers/#9197" class="Bound">x</a><a id="9204" class="Symbol">)</a>
</pre>
<p>Does the converse hold? If so, prove; if not, explain why.</p>
<h4 id="exercise---practice-1">Exercise <code>∃-⊎</code> (practice)</h4>
<p>Let <code>Tri</code> and <code>B</code> be as in Exercise <code>∀-×</code>. Show that <code>∃[ x ] B x</code> is isomorphic to <code>B aa ⊎ B bb ⊎ B cc</code>.</p>
<h2 id="an-existential-example">An existential example</h2>
Recall the definitions of <code>even</code> and <code>odd</code> from Chapter <a href="../Relations/">Relations</a>:
<pre class="Agda"><a id="9522" class="Keyword">data</a> <a id="even"></a><a id="9527" href="../Quantifiers/#9527" class="Datatype">even</a> <a id="9532" class="Symbol">:</a> <a id="9534" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="9536" class="Symbol">→</a> <a id="9538" class="PrimitiveType">Set</a>
<a id="9542" class="Keyword">data</a> <a id="odd"></a><a id="9547" href="../Quantifiers/#9547" class="Datatype">odd</a>  <a id="9552" class="Symbol">:</a> <a id="9554" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="9556" class="Symbol">→</a> <a id="9558" class="PrimitiveType">Set</a>

<a id="9563" class="Keyword">data</a> <a id="9568" href="../Quantifiers/#9527" class="Datatype">even</a> <a id="9573" class="Keyword">where</a>

  <a id="even.even-zero"></a><a id="9582" href="../Quantifiers/#9582" class="InductiveConstructor">even-zero</a> <a id="9592" class="Symbol">:</a> <a id="9594" href="../Quantifiers/#9527" class="Datatype">even</a> <a id="9599" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>

  <a id="even.even-suc"></a><a id="9607" href="../Quantifiers/#9607" class="InductiveConstructor">even-suc</a> <a id="9616" class="Symbol">:</a> <a id="9618" class="Symbol">∀</a> <a id="9620" class="Symbol">{</a><a id="9621" href="../Quantifiers/#9621" class="Bound">n</a> <a id="9623" class="Symbol">:</a> <a id="9625" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="9626" class="Symbol">}</a>
    <a id="9632" class="Symbol">→</a> <a id="9634" href="../Quantifiers/#9547" class="Datatype">odd</a> <a id="9638" href="../Quantifiers/#9621" class="Bound">n</a>
      <a id="9646" class="Comment">------------</a>
    <a id="9663" class="Symbol">→</a> <a id="9665" href="../Quantifiers/#9527" class="Datatype">even</a> <a id="9670" class="Symbol">(</a><a id="9671" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="9675" href="../Quantifiers/#9621" class="Bound">n</a><a id="9676" class="Symbol">)</a>

<a id="9679" class="Keyword">data</a> <a id="9684" href="../Quantifiers/#9547" class="Datatype">odd</a> <a id="9688" class="Keyword">where</a>
  <a id="odd.odd-suc"></a><a id="9696" href="../Quantifiers/#9696" class="InductiveConstructor">odd-suc</a> <a id="9704" class="Symbol">:</a> <a id="9706" class="Symbol">∀</a> <a id="9708" class="Symbol">{</a><a id="9709" href="../Quantifiers/#9709" class="Bound">n</a> <a id="9711" class="Symbol">:</a> <a id="9713" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="9714" class="Symbol">}</a>
    <a id="9720" class="Symbol">→</a> <a id="9722" href="../Quantifiers/#9527" class="Datatype">even</a> <a id="9727" href="../Quantifiers/#9709" class="Bound">n</a>
      <a id="9735" class="Comment">-----------</a>
    <a id="9751" class="Symbol">→</a> <a id="9753" href="../Quantifiers/#9547" class="Datatype">odd</a> <a id="9757" class="Symbol">(</a><a id="9758" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="9762" href="../Quantifiers/#9709" class="Bound">n</a><a id="9763" class="Symbol">)</a>
</pre>
<p>A number is even if it is zero or the successor of an odd number, and odd if it is the successor of an even number.</p>
<p>We will show that a number is even if and only if it is twice some other number, and odd if and only if it is one more than twice some other number. In other words, we will show:</p>
<p><code>even n</code> iff <code>∃[ m ] (    m * 2 ≡ n)</code></p>
<p><code>odd  n</code> iff <code>∃[ m ] (1 + m * 2 ≡ n)</code></p>
<p>By convention, one tends to write constant factors first and to put the constant term in a sum last. Here we’ve reversed each of those conventions, because doing so eases the proof.</p>
Here is the proof in the forward direction:
<pre class="Agda"><a id="even-∃"></a><a id="10384" href="../Quantifiers/#10384" class="Function">even-∃</a> <a id="10391" class="Symbol">:</a> <a id="10393" class="Symbol">∀</a> <a id="10395" class="Symbol">{</a><a id="10396" href="../Quantifiers/#10396" class="Bound">n</a> <a id="10398" class="Symbol">:</a> <a id="10400" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="10401" class="Symbol">}</a> <a id="10403" class="Symbol">→</a> <a id="10405" href="../Quantifiers/#9527" class="Datatype">even</a> <a id="10410" href="../Quantifiers/#10396" class="Bound">n</a> <a id="10412" class="Symbol">→</a> <a id="10414" href="../Quantifiers/#7282" class="Function">∃[</a> <a id="10417" href="../Quantifiers/#10417" class="Bound">m</a> <a id="10419" href="../Quantifiers/#7282" class="Function">]</a> <a id="10421" class="Symbol">(</a>    <a id="10426" href="../Quantifiers/#10417" class="Bound">m</a> <a id="10428" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#528" class="Primitive Operator">*</a> <a id="10430" class="Number">2</a> <a id="10432" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="10434" href="../Quantifiers/#10396" class="Bound">n</a><a id="10435" class="Symbol">)</a>
<a id="odd-∃"></a><a id="10437" href="../Quantifiers/#10437" class="Function">odd-∃</a>  <a id="10444" class="Symbol">:</a> <a id="10446" class="Symbol">∀</a> <a id="10448" class="Symbol">{</a><a id="10449" href="../Quantifiers/#10449" class="Bound">n</a> <a id="10451" class="Symbol">:</a> <a id="10453" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="10454" class="Symbol">}</a> <a id="10456" class="Symbol">→</a>  <a id="10459" href="../Quantifiers/#9547" class="Datatype">odd</a> <a id="10463" href="../Quantifiers/#10449" class="Bound">n</a> <a id="10465" class="Symbol">→</a> <a id="10467" href="../Quantifiers/#7282" class="Function">∃[</a> <a id="10470" href="../Quantifiers/#10470" class="Bound">m</a> <a id="10472" href="../Quantifiers/#7282" class="Function">]</a> <a id="10474" class="Symbol">(</a><a id="10475" class="Number">1</a> <a id="10477" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="10479" href="../Quantifiers/#10470" class="Bound">m</a> <a id="10481" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#528" class="Primitive Operator">*</a> <a id="10483" class="Number">2</a> <a id="10485" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="10487" href="../Quantifiers/#10449" class="Bound">n</a><a id="10488" class="Symbol">)</a>

<a id="10491" href="../Quantifiers/#10384" class="Function">even-∃</a> <a id="10498" href="../Quantifiers/#9582" class="InductiveConstructor">even-zero</a>                       <a id="10530" class="Symbol">=</a>  <a id="10533" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟨</a> <a id="10535" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="10540" href="../Quantifiers/#4901" class="InductiveConstructor Operator">,</a> <a id="10542" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="10547" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟩</a>
<a id="10549" href="../Quantifiers/#10384" class="Function">even-∃</a> <a id="10556" class="Symbol">(</a><a id="10557" href="../Quantifiers/#9607" class="InductiveConstructor">even-suc</a> <a id="10566" href="../Quantifiers/#10566" class="Bound">o</a><a id="10567" class="Symbol">)</a> <a id="10569" class="Keyword">with</a> <a id="10574" href="../Quantifiers/#10437" class="Function">odd-∃</a> <a id="10580" href="../Quantifiers/#10566" class="Bound">o</a>
<a id="10582" class="Symbol">...</a>                    <a id="10605" class="Symbol">|</a> <a id="10607" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟨</a> <a id="10609" href="../Quantifiers/#10609" class="Bound">m</a> <a id="10611" href="../Quantifiers/#4901" class="InductiveConstructor Operator">,</a> <a id="10613" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="10618" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟩</a>  <a id="10621" class="Symbol">=</a>  <a id="10624" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟨</a> <a id="10626" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="10630" href="../Quantifiers/#10609" class="Bound">m</a> <a id="10632" href="../Quantifiers/#4901" class="InductiveConstructor Operator">,</a> <a id="10634" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="10639" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟩</a>

<a id="10642" href="../Quantifiers/#10437" class="Function">odd-∃</a>  <a id="10649" class="Symbol">(</a><a id="10650" href="../Quantifiers/#9696" class="InductiveConstructor">odd-suc</a> <a id="10658" href="../Quantifiers/#10658" class="Bound">e</a><a id="10659" class="Symbol">)</a>  <a id="10662" class="Keyword">with</a> <a id="10667" href="../Quantifiers/#10384" class="Function">even-∃</a> <a id="10674" href="../Quantifiers/#10658" class="Bound">e</a>
<a id="10676" class="Symbol">...</a>                    <a id="10699" class="Symbol">|</a> <a id="10701" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟨</a> <a id="10703" href="../Quantifiers/#10703" class="Bound">m</a> <a id="10705" href="../Quantifiers/#4901" class="InductiveConstructor Operator">,</a> <a id="10707" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="10712" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟩</a>  <a id="10715" class="Symbol">=</a>  <a id="10718" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟨</a> <a id="10720" href="../Quantifiers/#10703" class="Bound">m</a> <a id="10722" href="../Quantifiers/#4901" class="InductiveConstructor Operator">,</a> <a id="10724" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="10729" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟩</a>
</pre>
<p>We define two mutually recursive functions. Given evidence that <code>n</code> is even or odd, we return a number <code>m</code> and evidence that <code>m * 2 ≡ n</code> or <code>1 + m * 2 ≡ n</code>. We induct over the evidence that <code>n</code> is even or odd:</p>
<ul>
<li><p>If the number is even because it is zero, then we return a pair consisting of zero and the evidence that twice zero is zero.</p></li>
<li><p>If the number is even because it is one more than an odd number, then we apply the induction hypothesis to give a number <code>m</code> and evidence that <code>1 + m * 2 ≡ n</code>. We return a pair consisting of <code>suc m</code> and evidence that <code>suc m * 2 ≡ suc n</code>, which is immediate after substituting for <code>n</code>.</p></li>
<li><p>If the number is odd because it is the successor of an even number, then we apply the induction hypothesis to give a number <code>m</code> and evidence that <code>m * 2 ≡ n</code>. We return a pair consisting of <code>suc m</code> and evidence that <code>1 + m * 2 ≡ suc n</code>, which is immediate after substituting for <code>n</code>.</p></li>
</ul>
<p>This completes the proof in the forward direction.</p>
Here is the proof in the reverse direction:
<pre class="Agda"><a id="∃-even"></a><a id="11749" href="../Quantifiers/#11749" class="Function">∃-even</a> <a id="11756" class="Symbol">:</a> <a id="11758" class="Symbol">∀</a> <a id="11760" class="Symbol">{</a><a id="11761" href="../Quantifiers/#11761" class="Bound">n</a> <a id="11763" class="Symbol">:</a> <a id="11765" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="11766" class="Symbol">}</a> <a id="11768" class="Symbol">→</a> <a id="11770" href="../Quantifiers/#7282" class="Function">∃[</a> <a id="11773" href="../Quantifiers/#11773" class="Bound">m</a> <a id="11775" href="../Quantifiers/#7282" class="Function">]</a> <a id="11777" class="Symbol">(</a>    <a id="11782" href="../Quantifiers/#11773" class="Bound">m</a> <a id="11784" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#528" class="Primitive Operator">*</a> <a id="11786" class="Number">2</a> <a id="11788" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="11790" href="../Quantifiers/#11761" class="Bound">n</a><a id="11791" class="Symbol">)</a> <a id="11793" class="Symbol">→</a> <a id="11795" href="../Quantifiers/#9527" class="Datatype">even</a> <a id="11800" href="../Quantifiers/#11761" class="Bound">n</a>
<a id="∃-odd"></a><a id="11802" href="../Quantifiers/#11802" class="Function">∃-odd</a>  <a id="11809" class="Symbol">:</a> <a id="11811" class="Symbol">∀</a> <a id="11813" class="Symbol">{</a><a id="11814" href="../Quantifiers/#11814" class="Bound">n</a> <a id="11816" class="Symbol">:</a> <a id="11818" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="11819" class="Symbol">}</a> <a id="11821" class="Symbol">→</a> <a id="11823" href="../Quantifiers/#7282" class="Function">∃[</a> <a id="11826" href="../Quantifiers/#11826" class="Bound">m</a> <a id="11828" href="../Quantifiers/#7282" class="Function">]</a> <a id="11830" class="Symbol">(</a><a id="11831" class="Number">1</a> <a id="11833" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="11835" href="../Quantifiers/#11826" class="Bound">m</a> <a id="11837" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#528" class="Primitive Operator">*</a> <a id="11839" class="Number">2</a> <a id="11841" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="11843" href="../Quantifiers/#11814" class="Bound">n</a><a id="11844" class="Symbol">)</a> <a id="11846" class="Symbol">→</a>  <a id="11849" href="../Quantifiers/#9547" class="Datatype">odd</a> <a id="11853" href="../Quantifiers/#11814" class="Bound">n</a>

<a id="11856" href="../Quantifiers/#11749" class="Function">∃-even</a> <a id="11863" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟨</a>  <a id="11866" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="11871" href="../Quantifiers/#4901" class="InductiveConstructor Operator">,</a> <a id="11873" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="11878" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟩</a>  <a id="11881" class="Symbol">=</a>  <a id="11884" href="../Quantifiers/#9582" class="InductiveConstructor">even-zero</a>
<a id="11894" href="../Quantifiers/#11749" class="Function">∃-even</a> <a id="11901" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟨</a> <a id="11903" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="11907" href="../Quantifiers/#11907" class="Bound">m</a> <a id="11909" href="../Quantifiers/#4901" class="InductiveConstructor Operator">,</a> <a id="11911" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="11916" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟩</a>  <a id="11919" class="Symbol">=</a>  <a id="11922" href="../Quantifiers/#9607" class="InductiveConstructor">even-suc</a> <a id="11931" class="Symbol">(</a><a id="11932" href="../Quantifiers/#11802" class="Function">∃-odd</a> <a id="11938" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟨</a> <a id="11940" href="../Quantifiers/#11907" class="Bound">m</a> <a id="11942" href="../Quantifiers/#4901" class="InductiveConstructor Operator">,</a> <a id="11944" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="11949" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟩</a><a id="11950" class="Symbol">)</a>

<a id="11953" href="../Quantifiers/#11802" class="Function">∃-odd</a>  <a id="11960" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟨</a>     <a id="11966" href="../Quantifiers/#11966" class="Bound">m</a> <a id="11968" href="../Quantifiers/#4901" class="InductiveConstructor Operator">,</a> <a id="11970" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="11975" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟩</a>  <a id="11978" class="Symbol">=</a>  <a id="11981" href="../Quantifiers/#9696" class="InductiveConstructor">odd-suc</a> <a id="11989" class="Symbol">(</a><a id="11990" href="../Quantifiers/#11749" class="Function">∃-even</a> <a id="11997" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟨</a> <a id="11999" href="../Quantifiers/#11966" class="Bound">m</a> <a id="12001" href="../Quantifiers/#4901" class="InductiveConstructor Operator">,</a> <a id="12003" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="12008" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟩</a><a id="12009" class="Symbol">)</a>
</pre>
<p>Given a number that is twice some other number we must show it is even, and a number that is one more than twice some other number we must show it is odd. We induct over the evidence of the existential, and in the even case consider the two possibilities for the number that is doubled:</p>
<ul>
<li><p>In the even case for <code>zero</code>, we must show <code>zero * 2</code> is even, which follows by <code>even-zero</code>.</p></li>
<li><p>In the even case for <code>suc n</code>, we must show <code>suc m * 2</code> is even. The inductive hypothesis tells us that <code>1 + m * 2</code> is odd, from which the desired result follows by <code>even-suc</code>.</p></li>
<li><p>In the odd case, we must show <code>1 + m * 2</code> is odd. The inductive hypothesis tell us that <code>m * 2</code> is even, from which the desired result follows by <code>odd-suc</code>.</p></li>
</ul>
<p>This completes the proof in the backward direction.</p>
<h4 id="exercise--even-odd-practice">Exercise <code>∃-even-odd</code> (practice)</h4>
<p>How do the proofs become more difficult if we replace <code>m * 2</code> and <code>1 + m * 2</code> by <code>2 * m</code> and <code>2 * m + 1</code>? Rewrite the proofs of <code>∃-even</code> and <code>∃-odd</code> when restated in this way.</p>
<pre class="Agda"><a id="13014" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise----practice">Exercise <code>∃-|-≤</code> (practice)</h4>
<p>Show that <code>y ≤ z</code> holds if and only if there exists a <code>x</code> such that <code>x + y ≡ z</code>.</p>
<pre class="Agda"><a id="13162" class="Comment">-- Your code goes here</a>
</pre>
<h2 id="existentials-universals-and-negation">Existentials, Universals, and Negation</h2>
Negation of an existential is isomorphic to the universal of a negation. Considering that existentials are generalised disjunction and universals are generalised conjunction, this result is analogous to the one which tells us that negation of a disjunction is isomorphic to a conjunction of negations:
<pre class="Agda"><a id="¬∃≃∀¬"></a><a id="13541" href="../Quantifiers/#13541" class="Function">¬∃≃∀¬</a> <a id="13547" class="Symbol">:</a> <a id="13549" class="Symbol">∀</a> <a id="13551" class="Symbol">{</a><a id="13552" href="../Quantifiers/#13552" class="Bound">A</a> <a id="13554" class="Symbol">:</a> <a id="13556" class="PrimitiveType">Set</a><a id="13559" class="Symbol">}</a> <a id="13561" class="Symbol">{</a><a id="13562" href="../Quantifiers/#13562" class="Bound">B</a> <a id="13564" class="Symbol">:</a> <a id="13566" href="../Quantifiers/#13552" class="Bound">A</a> <a id="13568" class="Symbol">→</a> <a id="13570" class="PrimitiveType">Set</a><a id="13573" class="Symbol">}</a>
  <a id="13577" class="Symbol">→</a> <a id="13579" class="Symbol">(</a><a id="13580" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#653" class="Function Operator">¬</a> <a id="13582" href="../Quantifiers/#7282" class="Function">∃[</a> <a id="13585" href="../Quantifiers/#13585" class="Bound">x</a> <a id="13587" href="../Quantifiers/#7282" class="Function">]</a> <a id="13589" href="../Quantifiers/#13562" class="Bound">B</a> <a id="13591" href="../Quantifiers/#13585" class="Bound">x</a><a id="13592" class="Symbol">)</a> <a id="13594" href="../Isomorphism/#4329" class="Record Operator">≃</a> <a id="13596" class="Symbol">∀</a> <a id="13598" href="../Quantifiers/#13598" class="Bound">x</a> <a id="13600" class="Symbol">→</a> <a id="13602" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#653" class="Function Operator">¬</a> <a id="13604" href="../Quantifiers/#13562" class="Bound">B</a> <a id="13606" href="../Quantifiers/#13598" class="Bound">x</a>
<a id="13608" href="../Quantifiers/#13541" class="Function">¬∃≃∀¬</a> <a id="13614" class="Symbol">=</a>
  <a id="13618" class="Keyword">record</a>
    <a id="13629" class="Symbol">{</a> <a id="13631" href="../Isomorphism/#4369" class="Field">to</a>      <a id="13639" class="Symbol">=</a>  <a id="13642" class="Symbol">λ{</a> <a id="13645" href="../Quantifiers/#13645" class="Bound">¬∃xy</a> <a id="13650" href="../Quantifiers/#13650" class="Bound">x</a> <a id="13652" href="../Quantifiers/#13652" class="Bound">y</a> <a id="13654" class="Symbol">→</a> <a id="13656" href="../Quantifiers/#13645" class="Bound">¬∃xy</a> <a id="13661" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟨</a> <a id="13663" href="../Quantifiers/#13650" class="Bound">x</a> <a id="13665" href="../Quantifiers/#4901" class="InductiveConstructor Operator">,</a> <a id="13667" href="../Quantifiers/#13652" class="Bound">y</a> <a id="13669" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟩</a> <a id="13671" class="Symbol">}</a>
    <a id="13677" class="Symbol">;</a> <a id="13679" href="../Isomorphism/#4386" class="Field">from</a>    <a id="13687" class="Symbol">=</a>  <a id="13690" class="Symbol">λ{</a> <a id="13693" href="../Quantifiers/#13693" class="Bound">∀¬xy</a> <a id="13698" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟨</a> <a id="13700" href="../Quantifiers/#13700" class="Bound">x</a> <a id="13702" href="../Quantifiers/#4901" class="InductiveConstructor Operator">,</a> <a id="13704" href="../Quantifiers/#13704" class="Bound">y</a> <a id="13706" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟩</a> <a id="13708" class="Symbol">→</a> <a id="13710" href="../Quantifiers/#13693" class="Bound">∀¬xy</a> <a id="13715" href="../Quantifiers/#13700" class="Bound">x</a> <a id="13717" href="../Quantifiers/#13704" class="Bound">y</a> <a id="13719" class="Symbol">}</a>
    <a id="13725" class="Symbol">;</a> <a id="13727" href="../Isomorphism/#4403" class="Field">from∘to</a> <a id="13735" class="Symbol">=</a>  <a id="13738" class="Symbol">λ{</a> <a id="13741" href="../Quantifiers/#13741" class="Bound">¬∃xy</a> <a id="13746" class="Symbol">→</a> <a id="13748" href="../Isomorphism/#2666" class="Postulate">extensionality</a> <a id="13763" class="Symbol">λ{</a> <a id="13766" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟨</a> <a id="13768" href="../Quantifiers/#13768" class="Bound">x</a> <a id="13770" href="../Quantifiers/#4901" class="InductiveConstructor Operator">,</a> <a id="13772" href="../Quantifiers/#13772" class="Bound">y</a> <a id="13774" href="../Quantifiers/#4901" class="InductiveConstructor Operator">⟩</a> <a id="13776" class="Symbol">→</a> <a id="13778" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="13783" class="Symbol">}</a> <a id="13785" class="Symbol">}</a>
    <a id="13791" class="Symbol">;</a> <a id="13793" href="../Isomorphism/#4445" class="Field">to∘from</a> <a id="13801" class="Symbol">=</a>  <a id="13804" class="Symbol">λ{</a> <a id="13807" href="../Quantifiers/#13807" class="Bound">∀¬xy</a> <a id="13812" class="Symbol">→</a> <a id="13814" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="13819" class="Symbol">}</a>
    <a id="13825" class="Symbol">}</a>
</pre>
<p>In the <code>to</code> direction, we are given a value <code>¬∃xy</code> of type <code>¬ ∃[ x ] B x</code>, and need to show that given a value <code>x</code> that <code>¬ B x</code> follows, in other words, from a value <code>y</code> of type <code>B x</code> we can derive false. Combining <code>x</code> and <code>y</code> gives us a value <code>⟨ x , y ⟩</code> of type <code>∃[ x ] B x</code>, and applying <code>¬∃xy</code> to that yields a contradiction.</p>
<p>In the <code>from</code> direction, we are given a value <code>∀¬xy</code> of type <code>∀ x → ¬ B x</code>, and need to show that from a value <code>⟨ x , y ⟩</code> of type <code>∃[ x ] B x</code> we can derive false. Applying <code>∀¬xy</code> to <code>x</code> gives a value of type <code>¬ B x</code>, and applying that to <code>y</code> yields a contradiction.</p>
<p>The two inverse proofs are straightforward, where one direction requires extensionality.</p>
<h4 id="exercise--implies--recommended">Exercise <code>∃¬-implies-¬∀</code> (recommended)</h4>
Show that existential of a negation implies negation of a universal:
<pre class="Agda"><a id="14642" class="Keyword">postulate</a>
  <a id="∃¬-implies-¬∀"></a><a id="14654" href="../Quantifiers/#14654" class="Postulate">∃¬-implies-¬∀</a> <a id="14668" class="Symbol">:</a> <a id="14670" class="Symbol">∀</a> <a id="14672" class="Symbol">{</a><a id="14673" href="../Quantifiers/#14673" class="Bound">A</a> <a id="14675" class="Symbol">:</a> <a id="14677" class="PrimitiveType">Set</a><a id="14680" class="Symbol">}</a> <a id="14682" class="Symbol">{</a><a id="14683" href="../Quantifiers/#14683" class="Bound">B</a> <a id="14685" class="Symbol">:</a> <a id="14687" href="../Quantifiers/#14673" class="Bound">A</a> <a id="14689" class="Symbol">→</a> <a id="14691" class="PrimitiveType">Set</a><a id="14694" class="Symbol">}</a>
    <a id="14700" class="Symbol">→</a> <a id="14702" href="../Quantifiers/#7282" class="Function">∃[</a> <a id="14705" href="../Quantifiers/#14705" class="Bound">x</a> <a id="14707" href="../Quantifiers/#7282" class="Function">]</a> <a id="14709" class="Symbol">(</a><a id="14710" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#653" class="Function Operator">¬</a> <a id="14712" href="../Quantifiers/#14683" class="Bound">B</a> <a id="14714" href="../Quantifiers/#14705" class="Bound">x</a><a id="14715" class="Symbol">)</a>
      <a id="14723" class="Comment">--------------</a>
    <a id="14742" class="Symbol">→</a> <a id="14744" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#653" class="Function Operator">¬</a> <a id="14746" class="Symbol">(∀</a> <a id="14749" href="../Quantifiers/#14749" class="Bound">x</a> <a id="14751" class="Symbol">→</a> <a id="14753" href="../Quantifiers/#14683" class="Bound">B</a> <a id="14755" href="../Quantifiers/#14749" class="Bound">x</a><a id="14756" class="Symbol">)</a>
</pre>
<p>Does the converse hold? If so, prove; if not, explain why.</p>
<h4 id="Bin-isomorphism">Exercise <code>Bin-isomorphism</code> (stretch)</h4>
<p>Recall that Exercises <a href="../Naturals/#Bin">Bin</a>, <a href="../Induction/#Bin-laws">Bin-laws</a>, and <a href="../Relations/#Bin-predicates">Bin-predicates</a> define a datatype <code>Bin</code> of bitstrings representing natural numbers, and asks you to define the following functions and predicates:</p>
<pre><code>to   : ℕ → Bin
from : Bin → ℕ
Can  : Bin → Set</code></pre>
<p>And to establish the following properties:</p>
<pre><code>from (to n) ≡ n

----------
Can (to n)

Can b
---------------
to (from b) ≡ b</code></pre>
<p>Using the above, establish that there is an isomorphism between <code>ℕ</code> and <code>∃[ b ] Can b</code>.</p>
<p>We recommend proving the following lemmas which show that, for a given binary number <code>b</code>, there is only one proof of <code>One b</code> and similarly for <code>Can b</code>.</p>
<pre><code>≡One : ∀ {b : Bin} (o o′ : One b) → o ≡ o′

≡Can : ∀ {b : Bin} (cb cb′ : Can b) → cb ≡ cb′</code></pre>
<p>Many of the alternatives for proving <code>to∘from</code> turn out to be tricky. However, the proof can be straightforward if you use the following lemma, which is a corollary of <code>≡Can</code>.</p>
<pre><code>proj₁≡→Can≡ : {cb cb′ : ∃[ b ] Can b} → proj₁ cb ≡ proj₁ cb′ → cb ≡ cb′</code></pre>
<pre class="Agda"><a id="15952" class="Comment">-- Your code goes here</a>
</pre>
<h2 id="standard-library">Standard library</h2>
Definitions similar to those in this chapter can be found in the standard library:
<pre class="Agda"><a id="16089" class="Keyword">import</a> <a id="16096" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html" class="Module">Data.Product</a> <a id="16109" class="Keyword">using</a> <a id="16115" class="Symbol">(</a><a id="16116" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Sigma.html#166" class="Record">Σ</a><a id="16117" class="Symbol">;</a> <a id="16119" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a><a id="16122" class="Symbol">;</a> <a id="16124" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1369" class="Function">∃</a><a id="16125" class="Symbol">;</a> <a id="16127" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#916" class="Function">Σ-syntax</a><a id="16135" class="Symbol">;</a> <a id="16137" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1788" class="Function">∃-syntax</a><a id="16145" class="Symbol">)</a>
</pre>
<h2 id="unicode">Unicode</h2>
<p>This chapter uses the following unicode:</p>
<pre><code>Π  U+03A0  GREEK CAPITAL LETTER PI (\Pi)
Σ  U+03A3  GREEK CAPITAL LETTER SIGMA (\Sigma)
∃  U+2203  THERE EXISTS (\ex, \exists)</code></pre>
    </div>
    <nav class="pager">
    <ul class="pagination">
        
        <li><a class="pagelink" href="../Negation/">Prev</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Quantifiers.lagda.md">Source</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="../Decidable/">Next</a></li>
        <li class="separator">&bullet;</li>
        
    </ul>
</nav>

</article>

            </div>
        </main>
        <footer class="site-footer h-card">
    <data class="u-url" href="../"></data>
    <div class="wrapper">
        <h2 class="footer-heading">Programming Language Foundations in Agda</h2>
        
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Philip Wadler</li>
                    <li>
                        
                        <a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/wadler" title="wadler"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;wadler</a></li>
    
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Wen Kokke</li>
                    <li>
                        
                        <a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;wenkokke</a></li>
    
    
    <li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#twitter"></use></svg>&nbsp;wenkokke</a></li>
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Jeremy G. Siek</li>
                    <li>
                        
                        <a class="u-email" href="mailto:jsiek@indiana.edu">jsiek@indiana.edu</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/jsiek" title="jsiek"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;jsiek</a></li>
    
    
    <li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#twitter"></use></svg>&nbsp;jeremysiek</a></li>
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        
        This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
    </div>
</footer>

    </body>
</html>
