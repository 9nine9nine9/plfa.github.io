<!DOCTYPE html>
<html lang="en">
    <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../public/css/style.css">
  
  <title>Programming Language Foundations in Agda – Connectives</title>
  
  
  
</head>

    <body>
        <header class="site-header">
    <div class="wrapper">
        <a class="site-title" href="../">Programming Language Foundations in Agda</a>
        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="../">The Book</a>
                <a class="page-link" href="../Announcements/">Announcements</a>
                <a class="page-link" href="../GettingStarted/">Getting Started</a>
                <a class="page-link" href="../Citing/">Citing</a>
                <a class="page-link" href="https://agda-zh.github.io/PLFA-zh/">中文</a>
            </div>
        </nav>
    </div>
</header>

        <main class="page-content" aria-label="Content">
            <div class="wrapper">
                <article class="post">
    <nav class="pager">
    <ul class="pagination">
        
        <li><a class="pagelink" href="../Isomorphism/">Prev</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Connectives.lagda.md">Source</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="../Negation/">Next</a></li>
        <li class="separator">&bullet;</li>
        
    </ul>
</nav>

    <header class="post-header">
        <h1 class="post-title">Connectives: Conjunction, disjunction, and implication</h1>
    </header>
    <div class="post-content">
        <pre class="Agda"><a id="175" class="Keyword">module</a> <a id="182" href="../Connectives/" class="Module">plfa.part1.Connectives</a> <a id="205" class="Keyword">where</a>
</pre>
<!-- The ⊥ ⊎ A ≅ A exercise requires a (inj₁ ()) pattern,
     which the reader will not have seen. Restore this
     exercise, and possibly also associativity? Take the
     exercises from the final sections on distributivity
     and exponentials? -->
<p>This chapter introduces the basic logical connectives, by observing a correspondence between connectives of logic and data types, a principle known as <em>Propositions as Types</em>:</p>
<ul>
<li><em>conjunction</em> is <em>product</em>,</li>
<li><em>disjunction</em> is <em>sum</em>,</li>
<li><em>true</em> is <em>unit type</em>,</li>
<li><em>false</em> is <em>empty type</em>,</li>
<li><em>implication</em> is <em>function space</em>.</li>
</ul>
<h2 id="imports">Imports</h2>
<pre class="Agda"><a id="821" class="Keyword">import</a> <a id="828" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="866" class="Symbol">as</a> <a id="869" class="Module">Eq</a>
<a id="872" class="Keyword">open</a> <a id="877" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="880" class="Keyword">using</a> <a id="886" class="Symbol">(</a><a id="887" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="890" class="Symbol">;</a> <a id="892" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="896" class="Symbol">)</a>
<a id="898" class="Keyword">open</a> <a id="903" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2419" class="Module">Eq.≡-Reasoning</a>
<a id="918" class="Keyword">open</a> <a id="923" class="Keyword">import</a> <a id="930" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.html" class="Module">Data.Nat</a> <a id="939" class="Keyword">using</a> <a id="945" class="Symbol">(</a><a id="946" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="947" class="Symbol">)</a>
<a id="949" class="Keyword">open</a> <a id="954" class="Keyword">import</a> <a id="961" href="https://agda.github.io/agda-stdlib/v1.3/Function.html" class="Module">Function</a> <a id="970" class="Keyword">using</a> <a id="976" class="Symbol">(</a><a id="977" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">_∘_</a><a id="980" class="Symbol">)</a>
<a id="982" class="Keyword">open</a> <a id="987" class="Keyword">import</a> <a id="994" href="../Isomorphism/" class="Module">plfa.part1.Isomorphism</a> <a id="1017" class="Keyword">using</a> <a id="1023" class="Symbol">(</a><a id="1024" href="../Isomorphism/#4333" class="Record Operator">_≃_</a><a id="1027" class="Symbol">;</a> <a id="1029" href="../Isomorphism/#9231" class="Record Operator">_≲_</a><a id="1032" class="Symbol">;</a> <a id="1034" href="../Isomorphism/#2670" class="Postulate">extensionality</a><a id="1048" class="Symbol">)</a>
<a id="1050" class="Keyword">open</a> <a id="1055" href="../Isomorphism/#8466" class="Module">plfa.part1.Isomorphism.≃-Reasoning</a>
</pre>
<h2 id="conjunction-is-product">Conjunction is product</h2>
Given two propositions <code>A</code> and <code>B</code>, the conjunction <code>A × B</code> holds if both <code>A</code> holds and <code>B</code> holds. We formalise this idea by declaring a suitable record type:
<pre class="Agda"><a id="1287" class="Keyword">data</a> <a id="_×_"></a><a id="1292" href="../Connectives/#1292" class="Datatype Operator">_×_</a> <a id="1296" class="Symbol">(</a><a id="1297" href="../Connectives/#1297" class="Bound">A</a> <a id="1299" href="../Connectives/#1299" class="Bound">B</a> <a id="1301" class="Symbol">:</a> <a id="1303" class="PrimitiveType">Set</a><a id="1306" class="Symbol">)</a> <a id="1308" class="Symbol">:</a> <a id="1310" class="PrimitiveType">Set</a> <a id="1314" class="Keyword">where</a>

  <a id="_×_.⟨_,_⟩"></a><a id="1323" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨_,_⟩</a> <a id="1329" class="Symbol">:</a>
      <a id="1337" href="../Connectives/#1297" class="Bound">A</a>
    <a id="1343" class="Symbol">→</a> <a id="1345" href="../Connectives/#1299" class="Bound">B</a>
      <a id="1353" class="Comment">-----</a>
    <a id="1363" class="Symbol">→</a> <a id="1365" href="../Connectives/#1297" class="Bound">A</a> <a id="1367" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="1369" href="../Connectives/#1299" class="Bound">B</a>
</pre>
<p>Evidence that <code>A × B</code> holds is of the form <code>⟨ M , N ⟩</code>, where <code>M</code> provides evidence that <code>A</code> holds and <code>N</code> provides evidence that <code>B</code> holds.</p>
Given evidence that <code>A × B</code> holds, we can conclude that either <code>A</code> holds or <code>B</code> holds:
<pre class="Agda"><a id="proj₁"></a><a id="1608" href="../Connectives/#1608" class="Function">proj₁</a> <a id="1614" class="Symbol">:</a> <a id="1616" class="Symbol">∀</a> <a id="1618" class="Symbol">{</a><a id="1619" href="../Connectives/#1619" class="Bound">A</a> <a id="1621" href="../Connectives/#1621" class="Bound">B</a> <a id="1623" class="Symbol">:</a> <a id="1625" class="PrimitiveType">Set</a><a id="1628" class="Symbol">}</a>
  <a id="1632" class="Symbol">→</a> <a id="1634" href="../Connectives/#1619" class="Bound">A</a> <a id="1636" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="1638" href="../Connectives/#1621" class="Bound">B</a>
    <a id="1644" class="Comment">-----</a>
  <a id="1652" class="Symbol">→</a> <a id="1654" href="../Connectives/#1619" class="Bound">A</a>
<a id="1656" href="../Connectives/#1608" class="Function">proj₁</a> <a id="1662" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="1664" href="../Connectives/#1664" class="Bound">x</a> <a id="1666" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="1668" href="../Connectives/#1668" class="Bound">y</a> <a id="1670" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="1672" class="Symbol">=</a> <a id="1674" href="../Connectives/#1664" class="Bound">x</a>

<a id="proj₂"></a><a id="1677" href="../Connectives/#1677" class="Function">proj₂</a> <a id="1683" class="Symbol">:</a> <a id="1685" class="Symbol">∀</a> <a id="1687" class="Symbol">{</a><a id="1688" href="../Connectives/#1688" class="Bound">A</a> <a id="1690" href="../Connectives/#1690" class="Bound">B</a> <a id="1692" class="Symbol">:</a> <a id="1694" class="PrimitiveType">Set</a><a id="1697" class="Symbol">}</a>
  <a id="1701" class="Symbol">→</a> <a id="1703" href="../Connectives/#1688" class="Bound">A</a> <a id="1705" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="1707" href="../Connectives/#1690" class="Bound">B</a>
    <a id="1713" class="Comment">-----</a>
  <a id="1721" class="Symbol">→</a> <a id="1723" href="../Connectives/#1690" class="Bound">B</a>
<a id="1725" href="../Connectives/#1677" class="Function">proj₂</a> <a id="1731" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="1733" href="../Connectives/#1733" class="Bound">x</a> <a id="1735" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="1737" href="../Connectives/#1737" class="Bound">y</a> <a id="1739" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="1741" class="Symbol">=</a> <a id="1743" href="../Connectives/#1737" class="Bound">y</a>
</pre>
<p>If <code>L</code> provides evidence that <code>A × B</code> holds, then <code>proj₁ L</code> provides evidence that <code>A</code> holds, and <code>proj₂ L</code> provides evidence that <code>B</code> holds.</p>
<p>When <code>⟨_,_⟩</code> appears in a term on the right-hand side of an equation we refer to it as a <em>constructor</em>, and when it appears in a pattern on the left-hand side of an equation we refer to it as a <em>destructor</em>. We may also refer to <code>proj₁</code> and <code>proj₂</code> as destructors, since they play a similar role.</p>
<p>Other terminology refers to <code>⟨_,_⟩</code> as <em>introducing</em> a conjunction, and to <code>proj₁</code> and <code>proj₂</code> as <em>eliminating</em> a conjunction; indeed, the former is sometimes given the name <code>×-I</code> and the latter two the names <code>×-E₁</code> and <code>×-E₂</code>. As we read the rules from top to bottom, introduction and elimination do what they say on the tin: the first <em>introduces</em> a formula for the connective, which appears in the conclusion but not in the hypotheses; the second <em>eliminates</em> a formula for the connective, which appears in a hypothesis but not in the conclusion. An introduction rule describes under what conditions we say the connective holds—how to <em>define</em> the connective. An elimination rule describes what we may conclude when the connective holds—how to <em>use</em> the connective.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
In this case, applying each destructor and reassembling the results with the constructor is the identity over products:
<pre class="Agda"><a id="η-×"></a><a id="3108" href="../Connectives/#3108" class="Function">η-×</a> <a id="3112" class="Symbol">:</a> <a id="3114" class="Symbol">∀</a> <a id="3116" class="Symbol">{</a><a id="3117" href="../Connectives/#3117" class="Bound">A</a> <a id="3119" href="../Connectives/#3119" class="Bound">B</a> <a id="3121" class="Symbol">:</a> <a id="3123" class="PrimitiveType">Set</a><a id="3126" class="Symbol">}</a> <a id="3128" class="Symbol">(</a><a id="3129" href="../Connectives/#3129" class="Bound">w</a> <a id="3131" class="Symbol">:</a> <a id="3133" href="../Connectives/#3117" class="Bound">A</a> <a id="3135" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="3137" href="../Connectives/#3119" class="Bound">B</a><a id="3138" class="Symbol">)</a> <a id="3140" class="Symbol">→</a> <a id="3142" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="3144" href="../Connectives/#1608" class="Function">proj₁</a> <a id="3150" href="../Connectives/#3129" class="Bound">w</a> <a id="3152" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="3154" href="../Connectives/#1677" class="Function">proj₂</a> <a id="3160" href="../Connectives/#3129" class="Bound">w</a> <a id="3162" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="3164" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="3166" href="../Connectives/#3129" class="Bound">w</a>
<a id="3168" href="../Connectives/#3108" class="Function">η-×</a> <a id="3172" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="3174" href="../Connectives/#3174" class="Bound">x</a> <a id="3176" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="3178" href="../Connectives/#3178" class="Bound">y</a> <a id="3180" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="3182" class="Symbol">=</a> <a id="3184" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>The pattern matching on the left-hand side is essential, since replacing <code>w</code> by <code>⟨ x , y ⟩</code> allows both sides of the propositional equality to simplify to the same term.</p>
We set the precedence of conjunction so that it binds less tightly than anything save disjunction:
<pre class="Agda"><a id="3467" class="Keyword">infixr</a> <a id="3474" class="Number">2</a> <a id="3476" href="../Connectives/#1292" class="Datatype Operator">_×_</a>
</pre>
<p>Thus, <code>m ≤ n × n ≤ p</code> parses as <code>(m ≤ n) × (n ≤ p)</code>.</p>
Alternatively, we can declare conjunction as a record type:
<pre class="Agda"><a id="3602" class="Keyword">record</a> <a id="_×′_"></a><a id="3609" href="../Connectives/#3609" class="Record Operator">_×′_</a> <a id="3614" class="Symbol">(</a><a id="3615" href="../Connectives/#3615" class="Bound">A</a> <a id="3617" href="../Connectives/#3617" class="Bound">B</a> <a id="3619" class="Symbol">:</a> <a id="3621" class="PrimitiveType">Set</a><a id="3624" class="Symbol">)</a> <a id="3626" class="Symbol">:</a> <a id="3628" class="PrimitiveType">Set</a> <a id="3632" class="Keyword">where</a>
  <a id="3640" class="Keyword">constructor</a> <a id="⟨_,_⟩′"></a><a id="3652" href="../Connectives/#3652" class="InductiveConstructor Operator">⟨_,_⟩′</a>
  <a id="3661" class="Keyword">field</a>
    <a id="_×′_.proj₁′"></a><a id="3671" href="../Connectives/#3671" class="Field">proj₁′</a> <a id="3678" class="Symbol">:</a> <a id="3680" href="../Connectives/#3615" class="Bound">A</a>
    <a id="_×′_.proj₂′"></a><a id="3686" href="../Connectives/#3686" class="Field">proj₂′</a> <a id="3693" class="Symbol">:</a> <a id="3695" href="../Connectives/#3617" class="Bound">B</a>
<a id="3697" class="Keyword">open</a> <a id="3702" href="../Connectives/#3609" class="Module Operator">_×′_</a>
</pre>
<p>The record construction <code>record { proj₁′ = M ; proj₂′ = N }</code> corresponds to the term <code>⟨ M , N ⟩</code> where <code>M</code> is a term of type <code>A</code> and <code>N</code> is a term of type <code>B</code>. The constructor declaration allows us to write <code>⟨ M , N ⟩′</code> in place of the record construction.</p>
The data type <code>_x_</code> and the record type <code>_×′_</code> behave similarly. One difference is that for data types we have to prove η-equality, but for record types, η-equality holds <em>by definition</em>. While proving <code>η-×′</code>, we do not have to pattern match on <code>w</code> to know that η-equality holds:
<pre class="Agda"><a id="η-×′"></a><a id="4253" href="../Connectives/#4253" class="Function">η-×′</a> <a id="4258" class="Symbol">:</a> <a id="4260" class="Symbol">∀</a> <a id="4262" class="Symbol">{</a><a id="4263" href="../Connectives/#4263" class="Bound">A</a> <a id="4265" href="../Connectives/#4265" class="Bound">B</a> <a id="4267" class="Symbol">:</a> <a id="4269" class="PrimitiveType">Set</a><a id="4272" class="Symbol">}</a> <a id="4274" class="Symbol">(</a><a id="4275" href="../Connectives/#4275" class="Bound">w</a> <a id="4277" class="Symbol">:</a> <a id="4279" href="../Connectives/#4263" class="Bound">A</a> <a id="4281" href="../Connectives/#3609" class="Record Operator">×′</a> <a id="4284" href="../Connectives/#4265" class="Bound">B</a><a id="4285" class="Symbol">)</a> <a id="4287" class="Symbol">→</a> <a id="4289" href="../Connectives/#3652" class="InductiveConstructor Operator">⟨</a> <a id="4291" href="../Connectives/#3671" class="Field">proj₁′</a> <a id="4298" href="../Connectives/#4275" class="Bound">w</a> <a id="4300" href="../Connectives/#3652" class="InductiveConstructor Operator">,</a> <a id="4302" href="../Connectives/#3686" class="Field">proj₂′</a> <a id="4309" href="../Connectives/#4275" class="Bound">w</a> <a id="4311" href="../Connectives/#3652" class="InductiveConstructor Operator">⟩′</a> <a id="4314" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="4316" href="../Connectives/#4275" class="Bound">w</a>
<a id="4318" href="../Connectives/#4253" class="Function">η-×′</a> <a id="4323" href="../Connectives/#4323" class="Bound">w</a> <a id="4325" class="Symbol">=</a> <a id="4327" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>It can be very convenient to have η-equality <em>definitionally</em>, and so the standard library defines <code>_×_</code> as a record type. We use the definition from the standard library in later chapters.</p>
Given two types <code>A</code> and <code>B</code>, we refer to <code>A × B</code> as the <em>product</em> of <code>A</code> and <code>B</code>. In set theory, it is also sometimes called the <em>Cartesian product</em>, and in computing it corresponds to a <em>record</em> type. Among other reasons for calling it the product, note that if type <code>A</code> has <code>m</code> distinct members, and type <code>B</code> has <code>n</code> distinct members, then the type <code>A × B</code> has <code>m * n</code> distinct members. For instance, consider a type <code>Bool</code> with two members, and a type <code>Tri</code> with three members:
<pre class="Agda"><a id="5014" class="Keyword">data</a> <a id="Bool"></a><a id="5019" href="../Connectives/#5019" class="Datatype">Bool</a> <a id="5024" class="Symbol">:</a> <a id="5026" class="PrimitiveType">Set</a> <a id="5030" class="Keyword">where</a>
  <a id="Bool.true"></a><a id="5038" href="../Connectives/#5038" class="InductiveConstructor">true</a>  <a id="5044" class="Symbol">:</a> <a id="5046" href="../Connectives/#5019" class="Datatype">Bool</a>
  <a id="Bool.false"></a><a id="5053" href="../Connectives/#5053" class="InductiveConstructor">false</a> <a id="5059" class="Symbol">:</a> <a id="5061" href="../Connectives/#5019" class="Datatype">Bool</a>

<a id="5067" class="Keyword">data</a> <a id="Tri"></a><a id="5072" href="../Connectives/#5072" class="Datatype">Tri</a> <a id="5076" class="Symbol">:</a> <a id="5078" class="PrimitiveType">Set</a> <a id="5082" class="Keyword">where</a>
  <a id="Tri.aa"></a><a id="5090" href="../Connectives/#5090" class="InductiveConstructor">aa</a> <a id="5093" class="Symbol">:</a> <a id="5095" href="../Connectives/#5072" class="Datatype">Tri</a>
  <a id="Tri.bb"></a><a id="5101" href="../Connectives/#5101" class="InductiveConstructor">bb</a> <a id="5104" class="Symbol">:</a> <a id="5106" href="../Connectives/#5072" class="Datatype">Tri</a>
  <a id="Tri.cc"></a><a id="5112" href="../Connectives/#5112" class="InductiveConstructor">cc</a> <a id="5115" class="Symbol">:</a> <a id="5117" href="../Connectives/#5072" class="Datatype">Tri</a>
</pre>
<p>Then the type <code>Bool × Tri</code> has six members:</p>
<pre><code>⟨ true  , aa ⟩    ⟨ true  , bb ⟩    ⟨ true ,  cc ⟩
⟨ false , aa ⟩    ⟨ false , bb ⟩    ⟨ false , cc ⟩</code></pre>
For example, the following function enumerates all possible arguments of type <code>Bool × Tri</code>:
<pre class="Agda"><a id="×-count"></a><a id="5377" href="../Connectives/#5377" class="Function">×-count</a> <a id="5385" class="Symbol">:</a> <a id="5387" href="../Connectives/#5019" class="Datatype">Bool</a> <a id="5392" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="5394" href="../Connectives/#5072" class="Datatype">Tri</a> <a id="5398" class="Symbol">→</a> <a id="5400" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="5402" href="../Connectives/#5377" class="Function">×-count</a> <a id="5410" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="5412" href="../Connectives/#5038" class="InductiveConstructor">true</a>  <a id="5418" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="5420" href="../Connectives/#5090" class="InductiveConstructor">aa</a> <a id="5423" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>  <a id="5426" class="Symbol">=</a>  <a id="5429" class="Number">1</a>
<a id="5431" href="../Connectives/#5377" class="Function">×-count</a> <a id="5439" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="5441" href="../Connectives/#5038" class="InductiveConstructor">true</a>  <a id="5447" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="5449" href="../Connectives/#5101" class="InductiveConstructor">bb</a> <a id="5452" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>  <a id="5455" class="Symbol">=</a>  <a id="5458" class="Number">2</a>
<a id="5460" href="../Connectives/#5377" class="Function">×-count</a> <a id="5468" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="5470" href="../Connectives/#5038" class="InductiveConstructor">true</a>  <a id="5476" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="5478" href="../Connectives/#5112" class="InductiveConstructor">cc</a> <a id="5481" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>  <a id="5484" class="Symbol">=</a>  <a id="5487" class="Number">3</a>
<a id="5489" href="../Connectives/#5377" class="Function">×-count</a> <a id="5497" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="5499" href="../Connectives/#5053" class="InductiveConstructor">false</a> <a id="5505" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="5507" href="../Connectives/#5090" class="InductiveConstructor">aa</a> <a id="5510" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>  <a id="5513" class="Symbol">=</a>  <a id="5516" class="Number">4</a>
<a id="5518" href="../Connectives/#5377" class="Function">×-count</a> <a id="5526" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="5528" href="../Connectives/#5053" class="InductiveConstructor">false</a> <a id="5534" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="5536" href="../Connectives/#5101" class="InductiveConstructor">bb</a> <a id="5539" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>  <a id="5542" class="Symbol">=</a>  <a id="5545" class="Number">5</a>
<a id="5547" href="../Connectives/#5377" class="Function">×-count</a> <a id="5555" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="5557" href="../Connectives/#5053" class="InductiveConstructor">false</a> <a id="5563" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="5565" href="../Connectives/#5112" class="InductiveConstructor">cc</a> <a id="5568" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>  <a id="5571" class="Symbol">=</a>  <a id="5574" class="Number">6</a>
</pre>
<p>Product on types also shares a property with product on numbers in that there is a sense in which it is commutative and associative. In particular, product is commutative and associative <em>up to isomorphism</em>.</p>
For commutativity, the <code>to</code> function swaps a pair, taking <code>⟨ x , y ⟩</code> to <code>⟨ y , x ⟩</code>, and the <code>from</code> function does the same (up to renaming). Instantiating the patterns correctly in <code>from∘to</code> and <code>to∘from</code> is essential. Replacing the definition of <code>from∘to</code> by <code>λ w → refl</code> will not work; and similarly for <code>to∘from</code>:
<pre class="Agda"><a id="×-comm"></a><a id="6113" href="../Connectives/#6113" class="Function">×-comm</a> <a id="6120" class="Symbol">:</a> <a id="6122" class="Symbol">∀</a> <a id="6124" class="Symbol">{</a><a id="6125" href="../Connectives/#6125" class="Bound">A</a> <a id="6127" href="../Connectives/#6127" class="Bound">B</a> <a id="6129" class="Symbol">:</a> <a id="6131" class="PrimitiveType">Set</a><a id="6134" class="Symbol">}</a> <a id="6136" class="Symbol">→</a> <a id="6138" href="../Connectives/#6125" class="Bound">A</a> <a id="6140" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="6142" href="../Connectives/#6127" class="Bound">B</a> <a id="6144" href="../Isomorphism/#4333" class="Record Operator">≃</a> <a id="6146" href="../Connectives/#6127" class="Bound">B</a> <a id="6148" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="6150" href="../Connectives/#6125" class="Bound">A</a>
<a id="6152" href="../Connectives/#6113" class="Function">×-comm</a> <a id="6159" class="Symbol">=</a>
  <a id="6163" class="Keyword">record</a>
    <a id="6174" class="Symbol">{</a> <a id="6176" href="../Isomorphism/#4373" class="Field">to</a>       <a id="6185" class="Symbol">=</a>  <a id="6188" class="Symbol">λ{</a> <a id="6191" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="6193" href="../Connectives/#6193" class="Bound">x</a> <a id="6195" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="6197" href="../Connectives/#6197" class="Bound">y</a> <a id="6199" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="6201" class="Symbol">→</a> <a id="6203" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="6205" href="../Connectives/#6197" class="Bound">y</a> <a id="6207" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="6209" href="../Connectives/#6193" class="Bound">x</a> <a id="6211" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="6213" class="Symbol">}</a>
    <a id="6219" class="Symbol">;</a> <a id="6221" href="../Isomorphism/#4390" class="Field">from</a>     <a id="6230" class="Symbol">=</a>  <a id="6233" class="Symbol">λ{</a> <a id="6236" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="6238" href="../Connectives/#6238" class="Bound">y</a> <a id="6240" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="6242" href="../Connectives/#6242" class="Bound">x</a> <a id="6244" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="6246" class="Symbol">→</a> <a id="6248" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="6250" href="../Connectives/#6242" class="Bound">x</a> <a id="6252" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="6254" href="../Connectives/#6238" class="Bound">y</a> <a id="6256" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="6258" class="Symbol">}</a>
    <a id="6264" class="Symbol">;</a> <a id="6266" href="../Isomorphism/#4407" class="Field">from∘to</a>  <a id="6275" class="Symbol">=</a>  <a id="6278" class="Symbol">λ{</a> <a id="6281" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="6283" href="../Connectives/#6283" class="Bound">x</a> <a id="6285" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="6287" href="../Connectives/#6287" class="Bound">y</a> <a id="6289" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="6291" class="Symbol">→</a> <a id="6293" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="6298" class="Symbol">}</a>
    <a id="6304" class="Symbol">;</a> <a id="6306" href="../Isomorphism/#4449" class="Field">to∘from</a>  <a id="6315" class="Symbol">=</a>  <a id="6318" class="Symbol">λ{</a> <a id="6321" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="6323" href="../Connectives/#6323" class="Bound">y</a> <a id="6325" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="6327" href="../Connectives/#6327" class="Bound">x</a> <a id="6329" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="6331" class="Symbol">→</a> <a id="6333" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="6338" class="Symbol">}</a>
    <a id="6344" class="Symbol">}</a>
</pre>
<p>Being <em>commutative</em> is different from being <em>commutative up to isomorphism</em>. Compare the two statements:</p>
<pre><code>m * n ≡ n * m
A × B ≃ B × A</code></pre>
<p>In the first case, we might have that <code>m</code> is <code>2</code> and <code>n</code> is <code>3</code>, and both <code>m * n</code> and <code>n * m</code> are equal to <code>6</code>. In the second case, we might have that <code>A</code> is <code>Bool</code> and <code>B</code> is <code>Tri</code>, and <code>Bool × Tri</code> is <em>not</em> the same as <code>Tri × Bool</code>. But there is an isomorphism between the two types. For instance, <code>⟨ true , aa ⟩</code>, which is a member of the former, corresponds to <code>⟨ aa , true ⟩</code>, which is a member of the latter.</p>
For associativity, the <code>to</code> function reassociates two uses of pairing, taking <code>⟨ ⟨ x , y ⟩ , z ⟩</code> to <code>⟨ x , ⟨ y , z ⟩ ⟩</code>, and the <code>from</code> function does the inverse. Again, the evidence of left and right inverse requires matching against a suitable pattern to enable simplification:
<pre class="Agda"><a id="×-assoc"></a><a id="7200" href="../Connectives/#7200" class="Function">×-assoc</a> <a id="7208" class="Symbol">:</a> <a id="7210" class="Symbol">∀</a> <a id="7212" class="Symbol">{</a><a id="7213" href="../Connectives/#7213" class="Bound">A</a> <a id="7215" href="../Connectives/#7215" class="Bound">B</a> <a id="7217" href="../Connectives/#7217" class="Bound">C</a> <a id="7219" class="Symbol">:</a> <a id="7221" class="PrimitiveType">Set</a><a id="7224" class="Symbol">}</a> <a id="7226" class="Symbol">→</a> <a id="7228" class="Symbol">(</a><a id="7229" href="../Connectives/#7213" class="Bound">A</a> <a id="7231" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="7233" href="../Connectives/#7215" class="Bound">B</a><a id="7234" class="Symbol">)</a> <a id="7236" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="7238" href="../Connectives/#7217" class="Bound">C</a> <a id="7240" href="../Isomorphism/#4333" class="Record Operator">≃</a> <a id="7242" href="../Connectives/#7213" class="Bound">A</a> <a id="7244" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="7246" class="Symbol">(</a><a id="7247" href="../Connectives/#7215" class="Bound">B</a> <a id="7249" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="7251" href="../Connectives/#7217" class="Bound">C</a><a id="7252" class="Symbol">)</a>
<a id="7254" href="../Connectives/#7200" class="Function">×-assoc</a> <a id="7262" class="Symbol">=</a>
  <a id="7266" class="Keyword">record</a>
    <a id="7277" class="Symbol">{</a> <a id="7279" href="../Isomorphism/#4373" class="Field">to</a>      <a id="7287" class="Symbol">=</a> <a id="7289" class="Symbol">λ{</a> <a id="7292" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7294" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7296" href="../Connectives/#7296" class="Bound">x</a> <a id="7298" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7300" href="../Connectives/#7300" class="Bound">y</a> <a id="7302" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7304" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7306" href="../Connectives/#7306" class="Bound">z</a> <a id="7308" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7310" class="Symbol">→</a> <a id="7312" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7314" href="../Connectives/#7296" class="Bound">x</a> <a id="7316" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7318" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7320" href="../Connectives/#7300" class="Bound">y</a> <a id="7322" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7324" href="../Connectives/#7306" class="Bound">z</a> <a id="7326" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7328" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7330" class="Symbol">}</a>
    <a id="7336" class="Symbol">;</a> <a id="7338" href="../Isomorphism/#4390" class="Field">from</a>    <a id="7346" class="Symbol">=</a> <a id="7348" class="Symbol">λ{</a> <a id="7351" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7353" href="../Connectives/#7353" class="Bound">x</a> <a id="7355" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7357" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7359" href="../Connectives/#7359" class="Bound">y</a> <a id="7361" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7363" href="../Connectives/#7363" class="Bound">z</a> <a id="7365" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7367" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7369" class="Symbol">→</a> <a id="7371" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7373" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7375" href="../Connectives/#7353" class="Bound">x</a> <a id="7377" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7379" href="../Connectives/#7359" class="Bound">y</a> <a id="7381" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7383" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7385" href="../Connectives/#7363" class="Bound">z</a> <a id="7387" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7389" class="Symbol">}</a>
    <a id="7395" class="Symbol">;</a> <a id="7397" href="../Isomorphism/#4407" class="Field">from∘to</a> <a id="7405" class="Symbol">=</a> <a id="7407" class="Symbol">λ{</a> <a id="7410" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7412" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7414" href="../Connectives/#7414" class="Bound">x</a> <a id="7416" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7418" href="../Connectives/#7418" class="Bound">y</a> <a id="7420" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7422" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7424" href="../Connectives/#7424" class="Bound">z</a> <a id="7426" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7428" class="Symbol">→</a> <a id="7430" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="7435" class="Symbol">}</a>
    <a id="7441" class="Symbol">;</a> <a id="7443" href="../Isomorphism/#4449" class="Field">to∘from</a> <a id="7451" class="Symbol">=</a> <a id="7453" class="Symbol">λ{</a> <a id="7456" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7458" href="../Connectives/#7458" class="Bound">x</a> <a id="7460" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7462" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7464" href="../Connectives/#7464" class="Bound">y</a> <a id="7466" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7468" href="../Connectives/#7468" class="Bound">z</a> <a id="7470" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7472" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7474" class="Symbol">→</a> <a id="7476" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="7481" class="Symbol">}</a>
    <a id="7487" class="Symbol">}</a>
</pre>
<p>Being <em>associative</em> is not the same as being <em>associative up to isomorphism</em>. Compare the two statements:</p>
<pre><code>(m * n) * p ≡ m * (n * p)
(A × B) × C ≃ A × (B × C)</code></pre>
<p>For example, the type <code>(ℕ × Bool) × Tri</code> is <em>not</em> the same as <code>ℕ × (Bool × Tri)</code>. But there is an isomorphism between the two types. For instance <code>⟨ ⟨ 1 , true ⟩ , aa ⟩</code>, which is a member of the former, corresponds to <code>⟨ 1 , ⟨ true , aa ⟩ ⟩</code>, which is a member of the latter.</p>
<h4 id="exercise-recommended">Exercise <code>⇔≃×</code> (recommended)</h4>
<p>Show that <code>A ⇔ B</code> as defined <a href="../Isomorphism/#iff">earlier</a> is isomorphic to <code>(A → B) × (B → A)</code>.</p>
<pre class="Agda"><a id="8077" class="Comment">-- Your code goes here</a>
</pre>
<h2 id="truth-is-unit">Truth is unit</h2>
Truth <code>⊤</code> always holds. We formalise this idea by declaring a suitable record type:
<pre class="Agda"><a id="8212" class="Keyword">data</a> <a id="⊤"></a><a id="8217" href="../Connectives/#8217" class="Datatype">⊤</a> <a id="8219" class="Symbol">:</a> <a id="8221" class="PrimitiveType">Set</a> <a id="8225" class="Keyword">where</a>

  <a id="⊤.tt"></a><a id="8234" href="../Connectives/#8234" class="InductiveConstructor">tt</a> <a id="8237" class="Symbol">:</a>
    <a id="8243" class="Comment">--</a>
    <a id="8250" href="../Connectives/#8217" class="Datatype">⊤</a>
</pre>
<p>Evidence that <code>⊤</code> holds is of the form <code>tt</code>.</p>
<p>There is an introduction rule, but no elimination rule. Given evidence that <code>⊤</code> holds, there is nothing more of interest we can conclude. Since truth always holds, knowing that it holds tells us nothing new.</p>
The nullary case of <code>η-×</code> is <code>η-⊤</code>, which asserts that any value of type <code>⊤</code> must be equal to <code>tt</code>:
<pre class="Agda"><a id="η-⊤"></a><a id="8616" href="../Connectives/#8616" class="Function">η-⊤</a> <a id="8620" class="Symbol">:</a> <a id="8622" class="Symbol">∀</a> <a id="8624" class="Symbol">(</a><a id="8625" href="../Connectives/#8625" class="Bound">w</a> <a id="8627" class="Symbol">:</a> <a id="8629" href="../Connectives/#8217" class="Datatype">⊤</a><a id="8630" class="Symbol">)</a> <a id="8632" class="Symbol">→</a> <a id="8634" href="../Connectives/#8234" class="InductiveConstructor">tt</a> <a id="8637" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="8639" href="../Connectives/#8625" class="Bound">w</a>
<a id="8641" href="../Connectives/#8616" class="Function">η-⊤</a> <a id="8645" href="../Connectives/#8234" class="InductiveConstructor">tt</a> <a id="8648" class="Symbol">=</a> <a id="8650" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>The pattern matching on the left-hand side is essential. Replacing <code>w</code> by <code>tt</code> allows both sides of the propositional equality to simplify to the same term.</p>
Alternatively, we can declare truth as an empty record:
<pre class="Agda"><a id="8877" class="Keyword">record</a> <a id="⊤′"></a><a id="8884" href="../Connectives/#8884" class="Record">⊤′</a> <a id="8887" class="Symbol">:</a> <a id="8889" class="PrimitiveType">Set</a> <a id="8893" class="Keyword">where</a>
  <a id="8901" class="Keyword">constructor</a> <a id="tt′"></a><a id="8913" href="../Connectives/#8913" class="InductiveConstructor">tt′</a>
</pre>
<p>The record construction <code>record {}</code> corresponds to the term <code>tt</code>. The constructor declaration allows us to write <code>tt′</code>.</p>
As with the product, the data type <code>⊤</code> and the record type <code>⊤′</code> behave similarly, but η-equality holds <em>by definition</em> for the record type. While proving <code>η-⊤′</code>, we do not have to pattern match on <code>w</code>—Agda <em>knows</em> it is equal to <code>tt′</code>:
<pre class="Agda"><a id="η-⊤′"></a><a id="9284" href="../Connectives/#9284" class="Function">η-⊤′</a> <a id="9289" class="Symbol">:</a> <a id="9291" class="Symbol">∀</a> <a id="9293" class="Symbol">(</a><a id="9294" href="../Connectives/#9294" class="Bound">w</a> <a id="9296" class="Symbol">:</a> <a id="9298" href="../Connectives/#8884" class="Record">⊤′</a><a id="9300" class="Symbol">)</a> <a id="9302" class="Symbol">→</a> <a id="9304" href="../Connectives/#8913" class="InductiveConstructor">tt′</a> <a id="9308" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="9310" href="../Connectives/#9294" class="Bound">w</a>
<a id="9312" href="../Connectives/#9284" class="Function">η-⊤′</a> <a id="9317" href="../Connectives/#9317" class="Bound">w</a> <a id="9319" class="Symbol">=</a> <a id="9321" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
Agda knows that <em>any</em> value of type <code>⊤′</code> must be <code>tt′</code>, so any time we need a value of type <code>⊤′</code>, we can tell Agda to figure it out:
<pre class="Agda"><a id="truth′"></a><a id="9467" href="../Connectives/#9467" class="Function">truth′</a> <a id="9474" class="Symbol">:</a> <a id="9476" href="../Connectives/#8884" class="Record">⊤′</a>
<a id="9479" href="../Connectives/#9467" class="Function">truth′</a> <a id="9486" class="Symbol">=</a> <a id="9488" class="Symbol">_</a>
</pre>
We refer to <code>⊤</code> as the <em>unit</em> type. And, indeed, type <code>⊤</code> has exactly one member, <code>tt</code>. For example, the following function enumerates all possible arguments of type <code>⊤</code>:
<pre class="Agda"><a id="⊤-count"></a><a id="9671" href="../Connectives/#9671" class="Function">⊤-count</a> <a id="9679" class="Symbol">:</a> <a id="9681" href="../Connectives/#8217" class="Datatype">⊤</a> <a id="9683" class="Symbol">→</a> <a id="9685" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="9687" href="../Connectives/#9671" class="Function">⊤-count</a> <a id="9695" href="../Connectives/#8234" class="InductiveConstructor">tt</a> <a id="9698" class="Symbol">=</a> <a id="9700" class="Number">1</a>
</pre>
For numbers, one is the identity of multiplication. Correspondingly, unit is the identity of product <em>up to isomorphism</em>. For left identity, the <code>to</code> function takes <code>⟨ tt , x ⟩</code> to <code>x</code>, and the <code>from</code> function does the inverse. The evidence of left inverse requires matching against a suitable pattern to enable simplification:
<pre class="Agda"><a id="⊤-identityˡ"></a><a id="10041" href="../Connectives/#10041" class="Function">⊤-identityˡ</a> <a id="10053" class="Symbol">:</a> <a id="10055" class="Symbol">∀</a> <a id="10057" class="Symbol">{</a><a id="10058" href="../Connectives/#10058" class="Bound">A</a> <a id="10060" class="Symbol">:</a> <a id="10062" class="PrimitiveType">Set</a><a id="10065" class="Symbol">}</a> <a id="10067" class="Symbol">→</a> <a id="10069" href="../Connectives/#8217" class="Datatype">⊤</a> <a id="10071" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="10073" href="../Connectives/#10058" class="Bound">A</a> <a id="10075" href="../Isomorphism/#4333" class="Record Operator">≃</a> <a id="10077" href="../Connectives/#10058" class="Bound">A</a>
<a id="10079" href="../Connectives/#10041" class="Function">⊤-identityˡ</a> <a id="10091" class="Symbol">=</a>
  <a id="10095" class="Keyword">record</a>
    <a id="10106" class="Symbol">{</a> <a id="10108" href="../Isomorphism/#4373" class="Field">to</a>      <a id="10116" class="Symbol">=</a> <a id="10118" class="Symbol">λ{</a> <a id="10121" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="10123" href="../Connectives/#8234" class="InductiveConstructor">tt</a> <a id="10126" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="10128" href="../Connectives/#10128" class="Bound">x</a> <a id="10130" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="10132" class="Symbol">→</a> <a id="10134" href="../Connectives/#10128" class="Bound">x</a> <a id="10136" class="Symbol">}</a>
    <a id="10142" class="Symbol">;</a> <a id="10144" href="../Isomorphism/#4390" class="Field">from</a>    <a id="10152" class="Symbol">=</a> <a id="10154" class="Symbol">λ{</a> <a id="10157" href="../Connectives/#10157" class="Bound">x</a> <a id="10159" class="Symbol">→</a> <a id="10161" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="10163" href="../Connectives/#8234" class="InductiveConstructor">tt</a> <a id="10166" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="10168" href="../Connectives/#10157" class="Bound">x</a> <a id="10170" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="10172" class="Symbol">}</a>
    <a id="10178" class="Symbol">;</a> <a id="10180" href="../Isomorphism/#4407" class="Field">from∘to</a> <a id="10188" class="Symbol">=</a> <a id="10190" class="Symbol">λ{</a> <a id="10193" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="10195" href="../Connectives/#8234" class="InductiveConstructor">tt</a> <a id="10198" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="10200" href="../Connectives/#10200" class="Bound">x</a> <a id="10202" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="10204" class="Symbol">→</a> <a id="10206" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="10211" class="Symbol">}</a>
    <a id="10217" class="Symbol">;</a> <a id="10219" href="../Isomorphism/#4449" class="Field">to∘from</a> <a id="10227" class="Symbol">=</a> <a id="10229" class="Symbol">λ{</a> <a id="10232" href="../Connectives/#10232" class="Bound">x</a> <a id="10234" class="Symbol">→</a> <a id="10236" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="10241" class="Symbol">}</a>
    <a id="10247" class="Symbol">}</a>
</pre>
<p>Having an <em>identity</em> is different from having an identity <em>up to isomorphism</em>. Compare the two statements:</p>
<pre><code>1 * m ≡ m
⊤ × A ≃ A</code></pre>
<p>In the first case, we might have that <code>m</code> is <code>2</code>, and both <code>1 * m</code> and <code>m</code> are equal to <code>2</code>. In the second case, we might have that <code>A</code> is <code>Bool</code>, and <code>⊤ × Bool</code> is <em>not</em> the same as <code>Bool</code>. But there is an isomorphism between the two types. For instance, <code>⟨ tt , true ⟩</code>, which is a member of the former, corresponds to <code>true</code>, which is a member of the latter.</p>
Right identity follows from commutativity of product and left identity:
<pre class="Agda"><a id="⊤-identityʳ"></a><a id="10833" href="../Connectives/#10833" class="Function">⊤-identityʳ</a> <a id="10845" class="Symbol">:</a> <a id="10847" class="Symbol">∀</a> <a id="10849" class="Symbol">{</a><a id="10850" href="../Connectives/#10850" class="Bound">A</a> <a id="10852" class="Symbol">:</a> <a id="10854" class="PrimitiveType">Set</a><a id="10857" class="Symbol">}</a> <a id="10859" class="Symbol">→</a> <a id="10861" class="Symbol">(</a><a id="10862" href="../Connectives/#10850" class="Bound">A</a> <a id="10864" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="10866" href="../Connectives/#8217" class="Datatype">⊤</a><a id="10867" class="Symbol">)</a> <a id="10869" href="../Isomorphism/#4333" class="Record Operator">≃</a> <a id="10871" href="../Connectives/#10850" class="Bound">A</a>
<a id="10873" href="../Connectives/#10833" class="Function">⊤-identityʳ</a> <a id="10885" class="Symbol">{</a><a id="10886" href="../Connectives/#10886" class="Bound">A</a><a id="10887" class="Symbol">}</a> <a id="10889" class="Symbol">=</a>
  <a id="10893" href="../Isomorphism/#8542" class="Function Operator">≃-begin</a>
    <a id="10905" class="Symbol">(</a><a id="10906" href="../Connectives/#10886" class="Bound">A</a> <a id="10908" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="10910" href="../Connectives/#8217" class="Datatype">⊤</a><a id="10911" class="Symbol">)</a>
  <a id="10915" href="../Isomorphism/#8626" class="Function Operator">≃⟨</a> <a id="10918" href="../Connectives/#6113" class="Function">×-comm</a> <a id="10925" href="../Isomorphism/#8626" class="Function Operator">⟩</a>
    <a id="10931" class="Symbol">(</a><a id="10932" href="../Connectives/#8217" class="Datatype">⊤</a> <a id="10934" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="10936" href="../Connectives/#10886" class="Bound">A</a><a id="10937" class="Symbol">)</a>
  <a id="10941" href="../Isomorphism/#8626" class="Function Operator">≃⟨</a> <a id="10944" href="../Connectives/#10041" class="Function">⊤-identityˡ</a> <a id="10956" href="../Isomorphism/#8626" class="Function Operator">⟩</a>
    <a id="10962" href="../Connectives/#10886" class="Bound">A</a>
  <a id="10966" href="../Isomorphism/#8745" class="Function Operator">≃-∎</a>
</pre>
<p>Here we have used a chain of isomorphisms, analogous to that used for equality.</p>
<h2 id="disjunction-is-sum">Disjunction is sum</h2>
Given two propositions <code>A</code> and <code>B</code>, the disjunction <code>A ⊎ B</code> holds if either <code>A</code> holds or <code>B</code> holds. We formalise this idea by declaring a suitable inductive type:
<pre class="Agda"><a id="11247" class="Keyword">data</a> <a id="_⊎_"></a><a id="11252" href="../Connectives/#11252" class="Datatype Operator">_⊎_</a> <a id="11256" class="Symbol">(</a><a id="11257" href="../Connectives/#11257" class="Bound">A</a> <a id="11259" href="../Connectives/#11259" class="Bound">B</a> <a id="11261" class="Symbol">:</a> <a id="11263" class="PrimitiveType">Set</a><a id="11266" class="Symbol">)</a> <a id="11268" class="Symbol">:</a> <a id="11270" class="PrimitiveType">Set</a> <a id="11274" class="Keyword">where</a>

  <a id="_⊎_.inj₁"></a><a id="11283" href="../Connectives/#11283" class="InductiveConstructor">inj₁</a> <a id="11288" class="Symbol">:</a>
      <a id="11296" href="../Connectives/#11257" class="Bound">A</a>
      <a id="11304" class="Comment">-----</a>
    <a id="11314" class="Symbol">→</a> <a id="11316" href="../Connectives/#11257" class="Bound">A</a> <a id="11318" href="../Connectives/#11252" class="Datatype Operator">⊎</a> <a id="11320" href="../Connectives/#11259" class="Bound">B</a>

  <a id="_⊎_.inj₂"></a><a id="11325" href="../Connectives/#11325" class="InductiveConstructor">inj₂</a> <a id="11330" class="Symbol">:</a>
      <a id="11338" href="../Connectives/#11259" class="Bound">B</a>
      <a id="11346" class="Comment">-----</a>
    <a id="11356" class="Symbol">→</a> <a id="11358" href="../Connectives/#11257" class="Bound">A</a> <a id="11360" href="../Connectives/#11252" class="Datatype Operator">⊎</a> <a id="11362" href="../Connectives/#11259" class="Bound">B</a>
</pre>
<p>Evidence that <code>A ⊎ B</code> holds is either of the form <code>inj₁ M</code>, where <code>M</code> provides evidence that <code>A</code> holds, or <code>inj₂ N</code>, where <code>N</code> provides evidence that <code>B</code> holds.</p>
Given evidence that <code>A → C</code> and <code>B → C</code> both hold, then given evidence that <code>A ⊎ B</code> holds we can conclude that <code>C</code> holds:
<pre class="Agda"><a id="case-⊎"></a><a id="11656" href="../Connectives/#11656" class="Function">case-⊎</a> <a id="11663" class="Symbol">:</a> <a id="11665" class="Symbol">∀</a> <a id="11667" class="Symbol">{</a><a id="11668" href="../Connectives/#11668" class="Bound">A</a> <a id="11670" href="../Connectives/#11670" class="Bound">B</a> <a id="11672" href="../Connectives/#11672" class="Bound">C</a> <a id="11674" class="Symbol">:</a> <a id="11676" class="PrimitiveType">Set</a><a id="11679" class="Symbol">}</a>
  <a id="11683" class="Symbol">→</a> <a id="11685" class="Symbol">(</a><a id="11686" href="../Connectives/#11668" class="Bound">A</a> <a id="11688" class="Symbol">→</a> <a id="11690" href="../Connectives/#11672" class="Bound">C</a><a id="11691" class="Symbol">)</a>
  <a id="11695" class="Symbol">→</a> <a id="11697" class="Symbol">(</a><a id="11698" href="../Connectives/#11670" class="Bound">B</a> <a id="11700" class="Symbol">→</a> <a id="11702" href="../Connectives/#11672" class="Bound">C</a><a id="11703" class="Symbol">)</a>
  <a id="11707" class="Symbol">→</a> <a id="11709" href="../Connectives/#11668" class="Bound">A</a> <a id="11711" href="../Connectives/#11252" class="Datatype Operator">⊎</a> <a id="11713" href="../Connectives/#11670" class="Bound">B</a>
    <a id="11719" class="Comment">-----------</a>
  <a id="11733" class="Symbol">→</a> <a id="11735" href="../Connectives/#11672" class="Bound">C</a>
<a id="11737" href="../Connectives/#11656" class="Function">case-⊎</a> <a id="11744" href="../Connectives/#11744" class="Bound">f</a> <a id="11746" href="../Connectives/#11746" class="Bound">g</a> <a id="11748" class="Symbol">(</a><a id="11749" href="../Connectives/#11283" class="InductiveConstructor">inj₁</a> <a id="11754" href="../Connectives/#11754" class="Bound">x</a><a id="11755" class="Symbol">)</a> <a id="11757" class="Symbol">=</a> <a id="11759" href="../Connectives/#11744" class="Bound">f</a> <a id="11761" href="../Connectives/#11754" class="Bound">x</a>
<a id="11763" href="../Connectives/#11656" class="Function">case-⊎</a> <a id="11770" href="../Connectives/#11770" class="Bound">f</a> <a id="11772" href="../Connectives/#11772" class="Bound">g</a> <a id="11774" class="Symbol">(</a><a id="11775" href="../Connectives/#11325" class="InductiveConstructor">inj₂</a> <a id="11780" href="../Connectives/#11780" class="Bound">y</a><a id="11781" class="Symbol">)</a> <a id="11783" class="Symbol">=</a> <a id="11785" href="../Connectives/#11772" class="Bound">g</a> <a id="11787" href="../Connectives/#11780" class="Bound">y</a>
</pre>
<p>Pattern matching against <code>inj₁</code> and <code>inj₂</code> is typical of how we exploit evidence that a disjunction holds.</p>
<p>When <code>inj₁</code> and <code>inj₂</code> appear on the right-hand side of an equation we refer to them as <em>constructors</em>, and when they appear on the left-hand side we refer to them as <em>destructors</em>. We also refer to <code>case-⊎</code> as a destructor, since it plays a similar role. Other terminology refers to <code>inj₁</code> and <code>inj₂</code> as <em>introducing</em> a disjunction, and to <code>case-⊎</code> as <em>eliminating</em> a disjunction; indeed the former are sometimes given the names <code>⊎-I₁</code> and <code>⊎-I₂</code> and the latter the name <code>⊎-E</code>.</p>
Applying the destructor to each of the constructors is the identity:
<pre class="Agda"><a id="η-⊎"></a><a id="12456" href="../Connectives/#12456" class="Function">η-⊎</a> <a id="12460" class="Symbol">:</a> <a id="12462" class="Symbol">∀</a> <a id="12464" class="Symbol">{</a><a id="12465" href="../Connectives/#12465" class="Bound">A</a> <a id="12467" href="../Connectives/#12467" class="Bound">B</a> <a id="12469" class="Symbol">:</a> <a id="12471" class="PrimitiveType">Set</a><a id="12474" class="Symbol">}</a> <a id="12476" class="Symbol">(</a><a id="12477" href="../Connectives/#12477" class="Bound">w</a> <a id="12479" class="Symbol">:</a> <a id="12481" href="../Connectives/#12465" class="Bound">A</a> <a id="12483" href="../Connectives/#11252" class="Datatype Operator">⊎</a> <a id="12485" href="../Connectives/#12467" class="Bound">B</a><a id="12486" class="Symbol">)</a> <a id="12488" class="Symbol">→</a> <a id="12490" href="../Connectives/#11656" class="Function">case-⊎</a> <a id="12497" href="../Connectives/#11283" class="InductiveConstructor">inj₁</a> <a id="12502" href="../Connectives/#11325" class="InductiveConstructor">inj₂</a> <a id="12507" href="../Connectives/#12477" class="Bound">w</a> <a id="12509" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="12511" href="../Connectives/#12477" class="Bound">w</a>
<a id="12513" href="../Connectives/#12456" class="Function">η-⊎</a> <a id="12517" class="Symbol">(</a><a id="12518" href="../Connectives/#11283" class="InductiveConstructor">inj₁</a> <a id="12523" href="../Connectives/#12523" class="Bound">x</a><a id="12524" class="Symbol">)</a> <a id="12526" class="Symbol">=</a> <a id="12528" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="12533" href="../Connectives/#12456" class="Function">η-⊎</a> <a id="12537" class="Symbol">(</a><a id="12538" href="../Connectives/#11325" class="InductiveConstructor">inj₂</a> <a id="12543" href="../Connectives/#12543" class="Bound">y</a><a id="12544" class="Symbol">)</a> <a id="12546" class="Symbol">=</a> <a id="12548" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
More generally, we can also throw in an arbitrary function from a disjunction:
<pre class="Agda"><a id="uniq-⊎"></a><a id="12640" href="../Connectives/#12640" class="Function">uniq-⊎</a> <a id="12647" class="Symbol">:</a> <a id="12649" class="Symbol">∀</a> <a id="12651" class="Symbol">{</a><a id="12652" href="../Connectives/#12652" class="Bound">A</a> <a id="12654" href="../Connectives/#12654" class="Bound">B</a> <a id="12656" href="../Connectives/#12656" class="Bound">C</a> <a id="12658" class="Symbol">:</a> <a id="12660" class="PrimitiveType">Set</a><a id="12663" class="Symbol">}</a> <a id="12665" class="Symbol">(</a><a id="12666" href="../Connectives/#12666" class="Bound">h</a> <a id="12668" class="Symbol">:</a> <a id="12670" href="../Connectives/#12652" class="Bound">A</a> <a id="12672" href="../Connectives/#11252" class="Datatype Operator">⊎</a> <a id="12674" href="../Connectives/#12654" class="Bound">B</a> <a id="12676" class="Symbol">→</a> <a id="12678" href="../Connectives/#12656" class="Bound">C</a><a id="12679" class="Symbol">)</a> <a id="12681" class="Symbol">(</a><a id="12682" href="../Connectives/#12682" class="Bound">w</a> <a id="12684" class="Symbol">:</a> <a id="12686" href="../Connectives/#12652" class="Bound">A</a> <a id="12688" href="../Connectives/#11252" class="Datatype Operator">⊎</a> <a id="12690" href="../Connectives/#12654" class="Bound">B</a><a id="12691" class="Symbol">)</a> <a id="12693" class="Symbol">→</a>
  <a id="12697" href="../Connectives/#11656" class="Function">case-⊎</a> <a id="12704" class="Symbol">(</a><a id="12705" href="../Connectives/#12666" class="Bound">h</a> <a id="12707" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">∘</a> <a id="12709" href="../Connectives/#11283" class="InductiveConstructor">inj₁</a><a id="12713" class="Symbol">)</a> <a id="12715" class="Symbol">(</a><a id="12716" href="../Connectives/#12666" class="Bound">h</a> <a id="12718" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">∘</a> <a id="12720" href="../Connectives/#11325" class="InductiveConstructor">inj₂</a><a id="12724" class="Symbol">)</a> <a id="12726" href="../Connectives/#12682" class="Bound">w</a> <a id="12728" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="12730" href="../Connectives/#12666" class="Bound">h</a> <a id="12732" href="../Connectives/#12682" class="Bound">w</a>
<a id="12734" href="../Connectives/#12640" class="Function">uniq-⊎</a> <a id="12741" href="../Connectives/#12741" class="Bound">h</a> <a id="12743" class="Symbol">(</a><a id="12744" href="../Connectives/#11283" class="InductiveConstructor">inj₁</a> <a id="12749" href="../Connectives/#12749" class="Bound">x</a><a id="12750" class="Symbol">)</a> <a id="12752" class="Symbol">=</a> <a id="12754" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="12759" href="../Connectives/#12640" class="Function">uniq-⊎</a> <a id="12766" href="../Connectives/#12766" class="Bound">h</a> <a id="12768" class="Symbol">(</a><a id="12769" href="../Connectives/#11325" class="InductiveConstructor">inj₂</a> <a id="12774" href="../Connectives/#12774" class="Bound">y</a><a id="12775" class="Symbol">)</a> <a id="12777" class="Symbol">=</a> <a id="12779" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>The pattern matching on the left-hand side is essential. Replacing <code>w</code> by <code>inj₁ x</code> allows both sides of the propositional equality to simplify to the same term, and similarly for <code>inj₂ y</code>.</p>
We set the precedence of disjunction so that it binds less tightly than any other declared operator:
<pre class="Agda"><a id="13084" class="Keyword">infixr</a> <a id="13091" class="Number">1</a> <a id="13093" href="../Connectives/#11252" class="Datatype Operator">_⊎_</a>
</pre>
<p>Thus, <code>A × C ⊎ B × C</code> parses as <code>(A × C) ⊎ (B × C)</code>.</p>
<p>Given two types <code>A</code> and <code>B</code>, we refer to <code>A ⊎ B</code> as the <em>sum</em> of <code>A</code> and <code>B</code>. In set theory, it is also sometimes called the <em>disjoint union</em>, and in computing it corresponds to a <em>variant record</em> type. Among other reasons for calling it the sum, note that if type <code>A</code> has <code>m</code> distinct members, and type <code>B</code> has <code>n</code> distinct members, then the type <code>A ⊎ B</code> has <code>m + n</code> distinct members. For instance, consider a type <code>Bool</code> with two members, and a type <code>Tri</code> with three members, as defined earlier. Then the type <code>Bool ⊎ Tri</code> has five members:</p>
<pre><code>inj₁ true     inj₂ aa
inj₁ false    inj₂ bb
              inj₂ cc</code></pre>
For example, the following function enumerates all possible arguments of type <code>Bool ⊎ Tri</code>:
<pre class="Agda"><a id="⊎-count"></a><a id="13875" href="../Connectives/#13875" class="Function">⊎-count</a> <a id="13883" class="Symbol">:</a> <a id="13885" href="../Connectives/#5019" class="Datatype">Bool</a> <a id="13890" href="../Connectives/#11252" class="Datatype Operator">⊎</a> <a id="13892" href="../Connectives/#5072" class="Datatype">Tri</a> <a id="13896" class="Symbol">→</a> <a id="13898" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="13900" href="../Connectives/#13875" class="Function">⊎-count</a> <a id="13908" class="Symbol">(</a><a id="13909" href="../Connectives/#11283" class="InductiveConstructor">inj₁</a> <a id="13914" href="../Connectives/#5038" class="InductiveConstructor">true</a><a id="13918" class="Symbol">)</a>   <a id="13922" class="Symbol">=</a>  <a id="13925" class="Number">1</a>
<a id="13927" href="../Connectives/#13875" class="Function">⊎-count</a> <a id="13935" class="Symbol">(</a><a id="13936" href="../Connectives/#11283" class="InductiveConstructor">inj₁</a> <a id="13941" href="../Connectives/#5053" class="InductiveConstructor">false</a><a id="13946" class="Symbol">)</a>  <a id="13949" class="Symbol">=</a>  <a id="13952" class="Number">2</a>
<a id="13954" href="../Connectives/#13875" class="Function">⊎-count</a> <a id="13962" class="Symbol">(</a><a id="13963" href="../Connectives/#11325" class="InductiveConstructor">inj₂</a> <a id="13968" href="../Connectives/#5090" class="InductiveConstructor">aa</a><a id="13970" class="Symbol">)</a>     <a id="13976" class="Symbol">=</a>  <a id="13979" class="Number">3</a>
<a id="13981" href="../Connectives/#13875" class="Function">⊎-count</a> <a id="13989" class="Symbol">(</a><a id="13990" href="../Connectives/#11325" class="InductiveConstructor">inj₂</a> <a id="13995" href="../Connectives/#5101" class="InductiveConstructor">bb</a><a id="13997" class="Symbol">)</a>     <a id="14003" class="Symbol">=</a>  <a id="14006" class="Number">4</a>
<a id="14008" href="../Connectives/#13875" class="Function">⊎-count</a> <a id="14016" class="Symbol">(</a><a id="14017" href="../Connectives/#11325" class="InductiveConstructor">inj₂</a> <a id="14022" href="../Connectives/#5112" class="InductiveConstructor">cc</a><a id="14024" class="Symbol">)</a>     <a id="14030" class="Symbol">=</a>  <a id="14033" class="Number">5</a>
</pre>
<p>Sum on types also shares a property with sum on numbers in that it is commutative and associative <em>up to isomorphism</em>.</p>
<h4 id="exercise--comm-recommended">Exercise <code>⊎-comm</code> (recommended)</h4>
<p>Show sum is commutative up to isomorphism.</p>
<pre class="Agda"><a id="14246" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise--assoc-practice">Exercise <code>⊎-assoc</code> (practice)</h4>
<p>Show sum is associative up to isomorphism.</p>
<pre class="Agda"><a id="14358" class="Comment">-- Your code goes here</a>
</pre>
<h2 id="false-is-empty">False is empty</h2>
False <code>⊥</code> never holds. We formalise this idea by declaring a suitable inductive type:
<pre class="Agda"><a id="14496" class="Keyword">data</a> <a id="⊥"></a><a id="14501" href="../Connectives/#14501" class="Datatype">⊥</a> <a id="14503" class="Symbol">:</a> <a id="14505" class="PrimitiveType">Set</a> <a id="14509" class="Keyword">where</a>
  <a id="14517" class="Comment">-- no clauses!</a>
</pre>
<p>There is no possible evidence that <code>⊥</code> holds.</p>
Dual to <code>⊤</code>, for <code>⊥</code> there is no introduction rule but an elimination rule. Since false never holds, knowing that it holds tells us we are in a paradoxical situation. Given evidence that <code>⊥</code> holds, we might conclude anything! This is a basic principle of logic, known in medieval times by the Latin phrase <em>ex falso</em>, and known to children through phrases such as “if pigs had wings, then I’d be the Queen of Sheba”. We formalise it as follows:
<pre class="Agda"><a id="⊥-elim"></a><a id="15035" href="../Connectives/#15035" class="Function">⊥-elim</a> <a id="15042" class="Symbol">:</a> <a id="15044" class="Symbol">∀</a> <a id="15046" class="Symbol">{</a><a id="15047" href="../Connectives/#15047" class="Bound">A</a> <a id="15049" class="Symbol">:</a> <a id="15051" class="PrimitiveType">Set</a><a id="15054" class="Symbol">}</a>
  <a id="15058" class="Symbol">→</a> <a id="15060" href="../Connectives/#14501" class="Datatype">⊥</a>
    <a id="15066" class="Comment">--</a>
  <a id="15071" class="Symbol">→</a> <a id="15073" href="../Connectives/#15047" class="Bound">A</a>
<a id="15075" href="../Connectives/#15035" class="Function">⊥-elim</a> <a id="15082" class="Symbol">()</a>
</pre>
<p>This is our first use of the <em>absurd pattern</em> <code>()</code>. Here since <code>⊥</code> is a type with no members, we indicate that it is <em>never</em> possible to match against a value of this type by using the pattern <code>()</code>.</p>
<p>The nullary case of <code>case-⊎</code> is <code>⊥-elim</code>. By analogy, we might have called it <code>case-⊥</code>, but chose to stick with the name in the standard library.</p>
The nullary case of <code>uniq-⊎</code> is <code>uniq-⊥</code>, which asserts that <code>⊥-elim</code> is equal to any arbitrary function from <code>⊥</code>:
<pre class="Agda"><a id="uniq-⊥"></a><a id="15556" href="../Connectives/#15556" class="Function">uniq-⊥</a> <a id="15563" class="Symbol">:</a> <a id="15565" class="Symbol">∀</a> <a id="15567" class="Symbol">{</a><a id="15568" href="../Connectives/#15568" class="Bound">C</a> <a id="15570" class="Symbol">:</a> <a id="15572" class="PrimitiveType">Set</a><a id="15575" class="Symbol">}</a> <a id="15577" class="Symbol">(</a><a id="15578" href="../Connectives/#15578" class="Bound">h</a> <a id="15580" class="Symbol">:</a> <a id="15582" href="../Connectives/#14501" class="Datatype">⊥</a> <a id="15584" class="Symbol">→</a> <a id="15586" href="../Connectives/#15568" class="Bound">C</a><a id="15587" class="Symbol">)</a> <a id="15589" class="Symbol">(</a><a id="15590" href="../Connectives/#15590" class="Bound">w</a> <a id="15592" class="Symbol">:</a> <a id="15594" href="../Connectives/#14501" class="Datatype">⊥</a><a id="15595" class="Symbol">)</a> <a id="15597" class="Symbol">→</a> <a id="15599" href="../Connectives/#15035" class="Function">⊥-elim</a> <a id="15606" href="../Connectives/#15590" class="Bound">w</a> <a id="15608" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="15610" href="../Connectives/#15578" class="Bound">h</a> <a id="15612" href="../Connectives/#15590" class="Bound">w</a>
<a id="15614" href="../Connectives/#15556" class="Function">uniq-⊥</a> <a id="15621" href="../Connectives/#15621" class="Bound">h</a> <a id="15623" class="Symbol">()</a>
</pre>
<p>Using the absurd pattern asserts there are no possible values for <code>w</code>, so the equation holds trivially.</p>
We refer to <code>⊥</code> as the <em>empty</em> type. And, indeed, type <code>⊥</code> has no members. For example, the following function enumerates all possible arguments of type <code>⊥</code>:
<pre class="Agda"><a id="⊥-count"></a><a id="15897" href="../Connectives/#15897" class="Function">⊥-count</a> <a id="15905" class="Symbol">:</a> <a id="15907" href="../Connectives/#14501" class="Datatype">⊥</a> <a id="15909" class="Symbol">→</a> <a id="15911" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="15913" href="../Connectives/#15897" class="Function">⊥-count</a> <a id="15921" class="Symbol">()</a>
</pre>
<p>Here again the absurd pattern <code>()</code> indicates that no value can match type <code>⊥</code>.</p>
<p>For numbers, zero is the identity of addition. Correspondingly, empty is the identity of sums <em>up to isomorphism</em>.</p>
<h4 id="exercise--identityˡ-recommended">Exercise <code>⊥-identityˡ</code> (recommended)</h4>
<p>Show empty is the left identity of sums up to isomorphism.</p>
<pre class="Agda"><a id="16231" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise--identityʳ-practice">Exercise <code>⊥-identityʳ</code> (practice)</h4>
<p>Show empty is the right identity of sums up to isomorphism.</p>
<pre class="Agda"><a id="16364" class="Comment">-- Your code goes here</a>
</pre>
<h2 name="implication" id="implication-is-function">Implication is function</h2>
<p>Given two propositions <code>A</code> and <code>B</code>, the implication <code>A → B</code> holds if whenever <code>A</code> holds then <code>B</code> must also hold. We formalise implication using the function type, which has appeared throughout this book.</p>
<p>Evidence that <code>A → B</code> holds is of the form</p>
<pre><code>λ (x : A) → N</code></pre>
<p>where <code>N</code> is a term of type <code>B</code> containing as a free variable <code>x</code> of type <code>A</code>. Given a term <code>L</code> providing evidence that <code>A → B</code> holds, and a term <code>M</code> providing evidence that <code>A</code> holds, the term <code>L M</code> provides evidence that <code>B</code> holds. In other words, evidence that <code>A → B</code> holds is a function that converts evidence that <code>A</code> holds into evidence that <code>B</code> holds.</p>
Put another way, if we know that <code>A → B</code> and <code>A</code> both hold, then we may conclude that <code>B</code> holds:
<pre class="Agda"><a id="→-elim"></a><a id="17171" href="../Connectives/#17171" class="Function">→-elim</a> <a id="17178" class="Symbol">:</a> <a id="17180" class="Symbol">∀</a> <a id="17182" class="Symbol">{</a><a id="17183" href="../Connectives/#17183" class="Bound">A</a> <a id="17185" href="../Connectives/#17185" class="Bound">B</a> <a id="17187" class="Symbol">:</a> <a id="17189" class="PrimitiveType">Set</a><a id="17192" class="Symbol">}</a>
  <a id="17196" class="Symbol">→</a> <a id="17198" class="Symbol">(</a><a id="17199" href="../Connectives/#17183" class="Bound">A</a> <a id="17201" class="Symbol">→</a> <a id="17203" href="../Connectives/#17185" class="Bound">B</a><a id="17204" class="Symbol">)</a>
  <a id="17208" class="Symbol">→</a> <a id="17210" href="../Connectives/#17183" class="Bound">A</a>
    <a id="17216" class="Comment">-------</a>
  <a id="17226" class="Symbol">→</a> <a id="17228" href="../Connectives/#17185" class="Bound">B</a>
<a id="17230" href="../Connectives/#17171" class="Function">→-elim</a> <a id="17237" href="../Connectives/#17237" class="Bound">L</a> <a id="17239" href="../Connectives/#17239" class="Bound">M</a> <a id="17241" class="Symbol">=</a> <a id="17243" href="../Connectives/#17237" class="Bound">L</a> <a id="17245" href="../Connectives/#17239" class="Bound">M</a>
</pre>
<p>In medieval times, this rule was known by the name <em>modus ponens</em>. It corresponds to function application.</p>
<p>Defining a function, with a named definition or a lambda abstraction, is referred to as <em>introducing</em> a function, while applying a function is referred to as <em>eliminating</em> the function.</p>
Elimination followed by introduction is the identity:
<pre class="Agda"><a id="η-→"></a><a id="17604" href="../Connectives/#17604" class="Function">η-→</a> <a id="17608" class="Symbol">:</a> <a id="17610" class="Symbol">∀</a> <a id="17612" class="Symbol">{</a><a id="17613" href="../Connectives/#17613" class="Bound">A</a> <a id="17615" href="../Connectives/#17615" class="Bound">B</a> <a id="17617" class="Symbol">:</a> <a id="17619" class="PrimitiveType">Set</a><a id="17622" class="Symbol">}</a> <a id="17624" class="Symbol">(</a><a id="17625" href="../Connectives/#17625" class="Bound">f</a> <a id="17627" class="Symbol">:</a> <a id="17629" href="../Connectives/#17613" class="Bound">A</a> <a id="17631" class="Symbol">→</a> <a id="17633" href="../Connectives/#17615" class="Bound">B</a><a id="17634" class="Symbol">)</a> <a id="17636" class="Symbol">→</a> <a id="17638" class="Symbol">(λ</a> <a id="17641" class="Symbol">(</a><a id="17642" href="../Connectives/#17642" class="Bound">x</a> <a id="17644" class="Symbol">:</a> <a id="17646" href="../Connectives/#17613" class="Bound">A</a><a id="17647" class="Symbol">)</a> <a id="17649" class="Symbol">→</a> <a id="17651" href="../Connectives/#17625" class="Bound">f</a> <a id="17653" href="../Connectives/#17642" class="Bound">x</a><a id="17654" class="Symbol">)</a> <a id="17656" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="17658" href="../Connectives/#17625" class="Bound">f</a>
<a id="17660" href="../Connectives/#17604" class="Function">η-→</a> <a id="17664" href="../Connectives/#17664" class="Bound">f</a> <a id="17666" class="Symbol">=</a> <a id="17668" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>Implication binds less tightly than any other operator. Thus, <code>A ⊎ B → B ⊎ A</code> parses as <code>(A ⊎ B) → (B ⊎ A)</code>.</p>
<p>Given two types <code>A</code> and <code>B</code>, we refer to <code>A → B</code> as the <em>function</em> space from <code>A</code> to <code>B</code>. It is also sometimes called the <em>exponential</em>, with <code>B</code> raised to the <code>A</code> power. Among other reasons for calling it the exponential, note that if type <code>A</code> has <code>m</code> distinct members, and type <code>B</code> has <code>n</code> distinct members, then the type <code>A → B</code> has <code>nᵐ</code> distinct members. For instance, consider a type <code>Bool</code> with two members and a type <code>Tri</code> with three members, as defined earlier. Then the type <code>Bool → Tri</code> has nine (that is, three squared) members:</p>
<pre><code>λ{true → aa; false → aa}  λ{true → aa; false → bb}  λ{true → aa; false → cc}
λ{true → bb; false → aa}  λ{true → bb; false → bb}  λ{true → bb; false → cc}
λ{true → cc; false → aa}  λ{true → cc; false → bb}  λ{true → cc; false → cc}</code></pre>
For example, the following function enumerates all possible arguments of the type <code>Bool → Tri</code>:
<pre class="Agda"><a id="→-count"></a><a id="18676" href="../Connectives/#18676" class="Function">→-count</a> <a id="18684" class="Symbol">:</a> <a id="18686" class="Symbol">(</a><a id="18687" href="../Connectives/#5019" class="Datatype">Bool</a> <a id="18692" class="Symbol">→</a> <a id="18694" href="../Connectives/#5072" class="Datatype">Tri</a><a id="18697" class="Symbol">)</a> <a id="18699" class="Symbol">→</a> <a id="18701" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="18703" href="../Connectives/#18676" class="Function">→-count</a> <a id="18711" href="../Connectives/#18711" class="Bound">f</a> <a id="18713" class="Keyword">with</a> <a id="18718" href="../Connectives/#18711" class="Bound">f</a> <a id="18720" href="../Connectives/#5038" class="InductiveConstructor">true</a> <a id="18725" class="Symbol">|</a> <a id="18727" href="../Connectives/#18711" class="Bound">f</a> <a id="18729" href="../Connectives/#5053" class="InductiveConstructor">false</a>
<a id="18735" class="Symbol">...</a>          <a id="18748" class="Symbol">|</a> <a id="18750" href="../Connectives/#5090" class="InductiveConstructor">aa</a>     <a id="18757" class="Symbol">|</a> <a id="18759" href="../Connectives/#5090" class="InductiveConstructor">aa</a>      <a id="18767" class="Symbol">=</a>   <a id="18771" class="Number">1</a>
<a id="18773" class="Symbol">...</a>          <a id="18786" class="Symbol">|</a> <a id="18788" href="../Connectives/#5090" class="InductiveConstructor">aa</a>     <a id="18795" class="Symbol">|</a> <a id="18797" href="../Connectives/#5101" class="InductiveConstructor">bb</a>      <a id="18805" class="Symbol">=</a>   <a id="18809" class="Number">2</a>
<a id="18811" class="Symbol">...</a>          <a id="18824" class="Symbol">|</a> <a id="18826" href="../Connectives/#5090" class="InductiveConstructor">aa</a>     <a id="18833" class="Symbol">|</a> <a id="18835" href="../Connectives/#5112" class="InductiveConstructor">cc</a>      <a id="18843" class="Symbol">=</a>   <a id="18847" class="Number">3</a>
<a id="18849" class="Symbol">...</a>          <a id="18862" class="Symbol">|</a> <a id="18864" href="../Connectives/#5101" class="InductiveConstructor">bb</a>     <a id="18871" class="Symbol">|</a> <a id="18873" href="../Connectives/#5090" class="InductiveConstructor">aa</a>      <a id="18881" class="Symbol">=</a>   <a id="18885" class="Number">4</a>
<a id="18887" class="Symbol">...</a>          <a id="18900" class="Symbol">|</a> <a id="18902" href="../Connectives/#5101" class="InductiveConstructor">bb</a>     <a id="18909" class="Symbol">|</a> <a id="18911" href="../Connectives/#5101" class="InductiveConstructor">bb</a>      <a id="18919" class="Symbol">=</a>   <a id="18923" class="Number">5</a>
<a id="18925" class="Symbol">...</a>          <a id="18938" class="Symbol">|</a> <a id="18940" href="../Connectives/#5101" class="InductiveConstructor">bb</a>     <a id="18947" class="Symbol">|</a> <a id="18949" href="../Connectives/#5112" class="InductiveConstructor">cc</a>      <a id="18957" class="Symbol">=</a>   <a id="18961" class="Number">6</a>
<a id="18963" class="Symbol">...</a>          <a id="18976" class="Symbol">|</a> <a id="18978" href="../Connectives/#5112" class="InductiveConstructor">cc</a>     <a id="18985" class="Symbol">|</a> <a id="18987" href="../Connectives/#5090" class="InductiveConstructor">aa</a>      <a id="18995" class="Symbol">=</a>   <a id="18999" class="Number">7</a>
<a id="19001" class="Symbol">...</a>          <a id="19014" class="Symbol">|</a> <a id="19016" href="../Connectives/#5112" class="InductiveConstructor">cc</a>     <a id="19023" class="Symbol">|</a> <a id="19025" href="../Connectives/#5101" class="InductiveConstructor">bb</a>      <a id="19033" class="Symbol">=</a>   <a id="19037" class="Number">8</a>
<a id="19039" class="Symbol">...</a>          <a id="19052" class="Symbol">|</a> <a id="19054" href="../Connectives/#5112" class="InductiveConstructor">cc</a>     <a id="19061" class="Symbol">|</a> <a id="19063" href="../Connectives/#5112" class="InductiveConstructor">cc</a>      <a id="19071" class="Symbol">=</a>   <a id="19075" class="Number">9</a>
</pre>
<p>Exponential on types also share a property with exponential on numbers in that many of the standard identities for numbers carry over to the types.</p>
<p>Corresponding to the law</p>
<pre><code>(p ^ n) ^ m  ≡  p ^ (n * m)</code></pre>
<p>we have the isomorphism</p>
<pre><code>A → (B → C)  ≃  (A × B) → C</code></pre>
Both types can be viewed as functions that given evidence that <code>A</code> holds and evidence that <code>B</code> holds can return evidence that <code>C</code> holds. This isomorphism sometimes goes by the name <em>currying</em>. The proof of the right inverse requires extensionality:
<pre class="Agda"><a id="currying"></a><a id="19601" href="../Connectives/#19601" class="Function">currying</a> <a id="19610" class="Symbol">:</a> <a id="19612" class="Symbol">∀</a> <a id="19614" class="Symbol">{</a><a id="19615" href="../Connectives/#19615" class="Bound">A</a> <a id="19617" href="../Connectives/#19617" class="Bound">B</a> <a id="19619" href="../Connectives/#19619" class="Bound">C</a> <a id="19621" class="Symbol">:</a> <a id="19623" class="PrimitiveType">Set</a><a id="19626" class="Symbol">}</a> <a id="19628" class="Symbol">→</a> <a id="19630" class="Symbol">(</a><a id="19631" href="../Connectives/#19615" class="Bound">A</a> <a id="19633" class="Symbol">→</a> <a id="19635" href="../Connectives/#19617" class="Bound">B</a> <a id="19637" class="Symbol">→</a> <a id="19639" href="../Connectives/#19619" class="Bound">C</a><a id="19640" class="Symbol">)</a> <a id="19642" href="../Isomorphism/#4333" class="Record Operator">≃</a> <a id="19644" class="Symbol">(</a><a id="19645" href="../Connectives/#19615" class="Bound">A</a> <a id="19647" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="19649" href="../Connectives/#19617" class="Bound">B</a> <a id="19651" class="Symbol">→</a> <a id="19653" href="../Connectives/#19619" class="Bound">C</a><a id="19654" class="Symbol">)</a>
<a id="19656" href="../Connectives/#19601" class="Function">currying</a> <a id="19665" class="Symbol">=</a>
  <a id="19669" class="Keyword">record</a>
    <a id="19680" class="Symbol">{</a> <a id="19682" href="../Isomorphism/#4373" class="Field">to</a>      <a id="19690" class="Symbol">=</a>  <a id="19693" class="Symbol">λ{</a> <a id="19696" href="../Connectives/#19696" class="Bound">f</a> <a id="19698" class="Symbol">→</a> <a id="19700" class="Symbol">λ{</a> <a id="19703" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="19705" href="../Connectives/#19705" class="Bound">x</a> <a id="19707" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="19709" href="../Connectives/#19709" class="Bound">y</a> <a id="19711" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="19713" class="Symbol">→</a> <a id="19715" href="../Connectives/#19696" class="Bound">f</a> <a id="19717" href="../Connectives/#19705" class="Bound">x</a> <a id="19719" href="../Connectives/#19709" class="Bound">y</a> <a id="19721" class="Symbol">}}</a>
    <a id="19728" class="Symbol">;</a> <a id="19730" href="../Isomorphism/#4390" class="Field">from</a>    <a id="19738" class="Symbol">=</a>  <a id="19741" class="Symbol">λ{</a> <a id="19744" href="../Connectives/#19744" class="Bound">g</a> <a id="19746" class="Symbol">→</a> <a id="19748" class="Symbol">λ{</a> <a id="19751" href="../Connectives/#19751" class="Bound">x</a> <a id="19753" class="Symbol">→</a> <a id="19755" class="Symbol">λ{</a> <a id="19758" href="../Connectives/#19758" class="Bound">y</a> <a id="19760" class="Symbol">→</a> <a id="19762" href="../Connectives/#19744" class="Bound">g</a> <a id="19764" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="19766" href="../Connectives/#19751" class="Bound">x</a> <a id="19768" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="19770" href="../Connectives/#19758" class="Bound">y</a> <a id="19772" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="19774" class="Symbol">}}}</a>
    <a id="19782" class="Symbol">;</a> <a id="19784" href="../Isomorphism/#4407" class="Field">from∘to</a> <a id="19792" class="Symbol">=</a>  <a id="19795" class="Symbol">λ{</a> <a id="19798" href="../Connectives/#19798" class="Bound">f</a> <a id="19800" class="Symbol">→</a> <a id="19802" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="19807" class="Symbol">}</a>
    <a id="19813" class="Symbol">;</a> <a id="19815" href="../Isomorphism/#4449" class="Field">to∘from</a> <a id="19823" class="Symbol">=</a>  <a id="19826" class="Symbol">λ{</a> <a id="19829" href="../Connectives/#19829" class="Bound">g</a> <a id="19831" class="Symbol">→</a> <a id="19833" href="../Isomorphism/#2670" class="Postulate">extensionality</a> <a id="19848" class="Symbol">λ{</a> <a id="19851" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="19853" href="../Connectives/#19853" class="Bound">x</a> <a id="19855" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="19857" href="../Connectives/#19857" class="Bound">y</a> <a id="19859" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="19861" class="Symbol">→</a> <a id="19863" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="19868" class="Symbol">}}</a>
    <a id="19875" class="Symbol">}</a>
</pre>
<p>Currying tells us that instead of a function that takes a pair of arguments, we can have a function that takes the first argument and returns a function that expects the second argument. Thus, for instance, our way of writing addition</p>
<pre><code>_+_ : ℕ → ℕ → ℕ</code></pre>
<p>is isomorphic to a function that accepts a pair of arguments:</p>
<pre><code>_+′_ : (ℕ × ℕ) → ℕ</code></pre>
<p>Agda is optimised for currying, so <code>2 + 3</code> abbreviates <code>_+_ 2 3</code>. In a language optimised for pairing, we would instead take <code>2 +′ 3</code> as an abbreviation for <code>_+′_ ⟨ 2 , 3 ⟩</code>.</p>
<p>Corresponding to the law</p>
<pre><code>p ^ (n + m) = (p ^ n) * (p ^ m)</code></pre>
<p>we have the isomorphism:</p>
<pre><code>(A ⊎ B) → C  ≃  (A → C) × (B → C)</code></pre>
That is, the assertion that if either <code>A</code> holds or <code>B</code> holds then <code>C</code> holds is the same as the assertion that if <code>A</code> holds then <code>C</code> holds and if <code>B</code> holds then <code>C</code> holds. The proof of the left inverse requires extensionality:
<pre class="Agda"><a id="→-distrib-⊎"></a><a id="20762" href="../Connectives/#20762" class="Function">→-distrib-⊎</a> <a id="20774" class="Symbol">:</a> <a id="20776" class="Symbol">∀</a> <a id="20778" class="Symbol">{</a><a id="20779" href="../Connectives/#20779" class="Bound">A</a> <a id="20781" href="../Connectives/#20781" class="Bound">B</a> <a id="20783" href="../Connectives/#20783" class="Bound">C</a> <a id="20785" class="Symbol">:</a> <a id="20787" class="PrimitiveType">Set</a><a id="20790" class="Symbol">}</a> <a id="20792" class="Symbol">→</a> <a id="20794" class="Symbol">(</a><a id="20795" href="../Connectives/#20779" class="Bound">A</a> <a id="20797" href="../Connectives/#11252" class="Datatype Operator">⊎</a> <a id="20799" href="../Connectives/#20781" class="Bound">B</a> <a id="20801" class="Symbol">→</a> <a id="20803" href="../Connectives/#20783" class="Bound">C</a><a id="20804" class="Symbol">)</a> <a id="20806" href="../Isomorphism/#4333" class="Record Operator">≃</a> <a id="20808" class="Symbol">((</a><a id="20810" href="../Connectives/#20779" class="Bound">A</a> <a id="20812" class="Symbol">→</a> <a id="20814" href="../Connectives/#20783" class="Bound">C</a><a id="20815" class="Symbol">)</a> <a id="20817" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="20819" class="Symbol">(</a><a id="20820" href="../Connectives/#20781" class="Bound">B</a> <a id="20822" class="Symbol">→</a> <a id="20824" href="../Connectives/#20783" class="Bound">C</a><a id="20825" class="Symbol">))</a>
<a id="20828" href="../Connectives/#20762" class="Function">→-distrib-⊎</a> <a id="20840" class="Symbol">=</a>
  <a id="20844" class="Keyword">record</a>
    <a id="20855" class="Symbol">{</a> <a id="20857" href="../Isomorphism/#4373" class="Field">to</a>      <a id="20865" class="Symbol">=</a> <a id="20867" class="Symbol">λ{</a> <a id="20870" href="../Connectives/#20870" class="Bound">f</a> <a id="20872" class="Symbol">→</a> <a id="20874" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="20876" href="../Connectives/#20870" class="Bound">f</a> <a id="20878" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">∘</a> <a id="20880" href="../Connectives/#11283" class="InductiveConstructor">inj₁</a> <a id="20885" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="20887" href="../Connectives/#20870" class="Bound">f</a> <a id="20889" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">∘</a> <a id="20891" href="../Connectives/#11325" class="InductiveConstructor">inj₂</a> <a id="20896" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="20898" class="Symbol">}</a>
    <a id="20904" class="Symbol">;</a> <a id="20906" href="../Isomorphism/#4390" class="Field">from</a>    <a id="20914" class="Symbol">=</a> <a id="20916" class="Symbol">λ{</a> <a id="20919" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="20921" href="../Connectives/#20921" class="Bound">g</a> <a id="20923" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="20925" href="../Connectives/#20925" class="Bound">h</a> <a id="20927" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="20929" class="Symbol">→</a> <a id="20931" class="Symbol">λ{</a> <a id="20934" class="Symbol">(</a><a id="20935" href="../Connectives/#11283" class="InductiveConstructor">inj₁</a> <a id="20940" href="../Connectives/#20940" class="Bound">x</a><a id="20941" class="Symbol">)</a> <a id="20943" class="Symbol">→</a> <a id="20945" href="../Connectives/#20921" class="Bound">g</a> <a id="20947" href="../Connectives/#20940" class="Bound">x</a> <a id="20949" class="Symbol">;</a> <a id="20951" class="Symbol">(</a><a id="20952" href="../Connectives/#11325" class="InductiveConstructor">inj₂</a> <a id="20957" href="../Connectives/#20957" class="Bound">y</a><a id="20958" class="Symbol">)</a> <a id="20960" class="Symbol">→</a> <a id="20962" href="../Connectives/#20925" class="Bound">h</a> <a id="20964" href="../Connectives/#20957" class="Bound">y</a> <a id="20966" class="Symbol">}</a> <a id="20968" class="Symbol">}</a>
    <a id="20974" class="Symbol">;</a> <a id="20976" href="../Isomorphism/#4407" class="Field">from∘to</a> <a id="20984" class="Symbol">=</a> <a id="20986" class="Symbol">λ{</a> <a id="20989" href="../Connectives/#20989" class="Bound">f</a> <a id="20991" class="Symbol">→</a> <a id="20993" href="../Isomorphism/#2670" class="Postulate">extensionality</a> <a id="21008" class="Symbol">λ{</a> <a id="21011" class="Symbol">(</a><a id="21012" href="../Connectives/#11283" class="InductiveConstructor">inj₁</a> <a id="21017" href="../Connectives/#21017" class="Bound">x</a><a id="21018" class="Symbol">)</a> <a id="21020" class="Symbol">→</a> <a id="21022" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="21027" class="Symbol">;</a> <a id="21029" class="Symbol">(</a><a id="21030" href="../Connectives/#11325" class="InductiveConstructor">inj₂</a> <a id="21035" href="../Connectives/#21035" class="Bound">y</a><a id="21036" class="Symbol">)</a> <a id="21038" class="Symbol">→</a> <a id="21040" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="21045" class="Symbol">}</a> <a id="21047" class="Symbol">}</a>
    <a id="21053" class="Symbol">;</a> <a id="21055" href="../Isomorphism/#4449" class="Field">to∘from</a> <a id="21063" class="Symbol">=</a> <a id="21065" class="Symbol">λ{</a> <a id="21068" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="21070" href="../Connectives/#21070" class="Bound">g</a> <a id="21072" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="21074" href="../Connectives/#21074" class="Bound">h</a> <a id="21076" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="21078" class="Symbol">→</a> <a id="21080" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="21085" class="Symbol">}</a>
    <a id="21091" class="Symbol">}</a>
</pre>
<p>Corresponding to the law</p>
<pre><code>(p * n) ^ m = (p ^ m) * (n ^ m)</code></pre>
<p>we have the isomorphism:</p>
<pre><code>A → B × C  ≃  (A → B) × (A → C)</code></pre>
That is, the assertion that if <code>A</code> holds then <code>B</code> holds and <code>C</code> holds is the same as the assertion that if <code>A</code> holds then <code>B</code> holds and if <code>A</code> holds then <code>C</code> holds. The proof of left inverse requires both extensionality and the rule <code>η-×</code> for products:
<pre class="Agda"><a id="→-distrib-×"></a><a id="21482" href="../Connectives/#21482" class="Function">→-distrib-×</a> <a id="21494" class="Symbol">:</a> <a id="21496" class="Symbol">∀</a> <a id="21498" class="Symbol">{</a><a id="21499" href="../Connectives/#21499" class="Bound">A</a> <a id="21501" href="../Connectives/#21501" class="Bound">B</a> <a id="21503" href="../Connectives/#21503" class="Bound">C</a> <a id="21505" class="Symbol">:</a> <a id="21507" class="PrimitiveType">Set</a><a id="21510" class="Symbol">}</a> <a id="21512" class="Symbol">→</a> <a id="21514" class="Symbol">(</a><a id="21515" href="../Connectives/#21499" class="Bound">A</a> <a id="21517" class="Symbol">→</a> <a id="21519" href="../Connectives/#21501" class="Bound">B</a> <a id="21521" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="21523" href="../Connectives/#21503" class="Bound">C</a><a id="21524" class="Symbol">)</a> <a id="21526" href="../Isomorphism/#4333" class="Record Operator">≃</a> <a id="21528" class="Symbol">(</a><a id="21529" href="../Connectives/#21499" class="Bound">A</a> <a id="21531" class="Symbol">→</a> <a id="21533" href="../Connectives/#21501" class="Bound">B</a><a id="21534" class="Symbol">)</a> <a id="21536" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="21538" class="Symbol">(</a><a id="21539" href="../Connectives/#21499" class="Bound">A</a> <a id="21541" class="Symbol">→</a> <a id="21543" href="../Connectives/#21503" class="Bound">C</a><a id="21544" class="Symbol">)</a>
<a id="21546" href="../Connectives/#21482" class="Function">→-distrib-×</a> <a id="21558" class="Symbol">=</a>
  <a id="21562" class="Keyword">record</a>
    <a id="21573" class="Symbol">{</a> <a id="21575" href="../Isomorphism/#4373" class="Field">to</a>      <a id="21583" class="Symbol">=</a> <a id="21585" class="Symbol">λ{</a> <a id="21588" href="../Connectives/#21588" class="Bound">f</a> <a id="21590" class="Symbol">→</a> <a id="21592" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="21594" href="../Connectives/#1608" class="Function">proj₁</a> <a id="21600" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">∘</a> <a id="21602" href="../Connectives/#21588" class="Bound">f</a> <a id="21604" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="21606" href="../Connectives/#1677" class="Function">proj₂</a> <a id="21612" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">∘</a> <a id="21614" href="../Connectives/#21588" class="Bound">f</a> <a id="21616" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="21618" class="Symbol">}</a>
    <a id="21624" class="Symbol">;</a> <a id="21626" href="../Isomorphism/#4390" class="Field">from</a>    <a id="21634" class="Symbol">=</a> <a id="21636" class="Symbol">λ{</a> <a id="21639" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="21641" href="../Connectives/#21641" class="Bound">g</a> <a id="21643" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="21645" href="../Connectives/#21645" class="Bound">h</a> <a id="21647" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="21649" class="Symbol">→</a> <a id="21651" class="Symbol">λ</a> <a id="21653" href="../Connectives/#21653" class="Bound">x</a> <a id="21655" class="Symbol">→</a> <a id="21657" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="21659" href="../Connectives/#21641" class="Bound">g</a> <a id="21661" href="../Connectives/#21653" class="Bound">x</a> <a id="21663" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="21665" href="../Connectives/#21645" class="Bound">h</a> <a id="21667" href="../Connectives/#21653" class="Bound">x</a> <a id="21669" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="21671" class="Symbol">}</a>
    <a id="21677" class="Symbol">;</a> <a id="21679" href="../Isomorphism/#4407" class="Field">from∘to</a> <a id="21687" class="Symbol">=</a> <a id="21689" class="Symbol">λ{</a> <a id="21692" href="../Connectives/#21692" class="Bound">f</a> <a id="21694" class="Symbol">→</a> <a id="21696" href="../Isomorphism/#2670" class="Postulate">extensionality</a> <a id="21711" class="Symbol">λ{</a> <a id="21714" href="../Connectives/#21714" class="Bound">x</a> <a id="21716" class="Symbol">→</a> <a id="21718" href="../Connectives/#3108" class="Function">η-×</a> <a id="21722" class="Symbol">(</a><a id="21723" href="../Connectives/#21692" class="Bound">f</a> <a id="21725" href="../Connectives/#21714" class="Bound">x</a><a id="21726" class="Symbol">)</a> <a id="21728" class="Symbol">}</a> <a id="21730" class="Symbol">}</a>
    <a id="21736" class="Symbol">;</a> <a id="21738" href="../Isomorphism/#4449" class="Field">to∘from</a> <a id="21746" class="Symbol">=</a> <a id="21748" class="Symbol">λ{</a> <a id="21751" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="21753" href="../Connectives/#21753" class="Bound">g</a> <a id="21755" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="21757" href="../Connectives/#21757" class="Bound">h</a> <a id="21759" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="21761" class="Symbol">→</a> <a id="21763" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="21768" class="Symbol">}</a>
    <a id="21774" class="Symbol">}</a>
</pre>
<h2 id="distribution">Distribution</h2>
Products distribute over sum, up to isomorphism. The code to validate this fact is similar in structure to our previous results:
<pre class="Agda"><a id="×-distrib-⊎"></a><a id="21933" href="../Connectives/#21933" class="Function">×-distrib-⊎</a> <a id="21945" class="Symbol">:</a> <a id="21947" class="Symbol">∀</a> <a id="21949" class="Symbol">{</a><a id="21950" href="../Connectives/#21950" class="Bound">A</a> <a id="21952" href="../Connectives/#21952" class="Bound">B</a> <a id="21954" href="../Connectives/#21954" class="Bound">C</a> <a id="21956" class="Symbol">:</a> <a id="21958" class="PrimitiveType">Set</a><a id="21961" class="Symbol">}</a> <a id="21963" class="Symbol">→</a> <a id="21965" class="Symbol">(</a><a id="21966" href="../Connectives/#21950" class="Bound">A</a> <a id="21968" href="../Connectives/#11252" class="Datatype Operator">⊎</a> <a id="21970" href="../Connectives/#21952" class="Bound">B</a><a id="21971" class="Symbol">)</a> <a id="21973" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="21975" href="../Connectives/#21954" class="Bound">C</a> <a id="21977" href="../Isomorphism/#4333" class="Record Operator">≃</a> <a id="21979" class="Symbol">(</a><a id="21980" href="../Connectives/#21950" class="Bound">A</a> <a id="21982" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="21984" href="../Connectives/#21954" class="Bound">C</a><a id="21985" class="Symbol">)</a> <a id="21987" href="../Connectives/#11252" class="Datatype Operator">⊎</a> <a id="21989" class="Symbol">(</a><a id="21990" href="../Connectives/#21952" class="Bound">B</a> <a id="21992" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="21994" href="../Connectives/#21954" class="Bound">C</a><a id="21995" class="Symbol">)</a>
<a id="21997" href="../Connectives/#21933" class="Function">×-distrib-⊎</a> <a id="22009" class="Symbol">=</a>
  <a id="22013" class="Keyword">record</a>
    <a id="22024" class="Symbol">{</a> <a id="22026" href="../Isomorphism/#4373" class="Field">to</a>      <a id="22034" class="Symbol">=</a> <a id="22036" class="Symbol">λ{</a> <a id="22039" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22041" href="../Connectives/#11283" class="InductiveConstructor">inj₁</a> <a id="22046" href="../Connectives/#22046" class="Bound">x</a> <a id="22048" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22050" href="../Connectives/#22050" class="Bound">z</a> <a id="22052" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="22054" class="Symbol">→</a> <a id="22056" class="Symbol">(</a><a id="22057" href="../Connectives/#11283" class="InductiveConstructor">inj₁</a> <a id="22062" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22064" href="../Connectives/#22046" class="Bound">x</a> <a id="22066" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22068" href="../Connectives/#22050" class="Bound">z</a> <a id="22070" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a><a id="22071" class="Symbol">)</a>
                 <a id="22090" class="Symbol">;</a> <a id="22092" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22094" href="../Connectives/#11325" class="InductiveConstructor">inj₂</a> <a id="22099" href="../Connectives/#22099" class="Bound">y</a> <a id="22101" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22103" href="../Connectives/#22103" class="Bound">z</a> <a id="22105" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="22107" class="Symbol">→</a> <a id="22109" class="Symbol">(</a><a id="22110" href="../Connectives/#11325" class="InductiveConstructor">inj₂</a> <a id="22115" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22117" href="../Connectives/#22099" class="Bound">y</a> <a id="22119" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22121" href="../Connectives/#22103" class="Bound">z</a> <a id="22123" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a><a id="22124" class="Symbol">)</a>
                 <a id="22143" class="Symbol">}</a>
    <a id="22149" class="Symbol">;</a> <a id="22151" href="../Isomorphism/#4390" class="Field">from</a>    <a id="22159" class="Symbol">=</a> <a id="22161" class="Symbol">λ{</a> <a id="22164" class="Symbol">(</a><a id="22165" href="../Connectives/#11283" class="InductiveConstructor">inj₁</a> <a id="22170" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22172" href="../Connectives/#22172" class="Bound">x</a> <a id="22174" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22176" href="../Connectives/#22176" class="Bound">z</a> <a id="22178" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a><a id="22179" class="Symbol">)</a> <a id="22181" class="Symbol">→</a> <a id="22183" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22185" href="../Connectives/#11283" class="InductiveConstructor">inj₁</a> <a id="22190" href="../Connectives/#22172" class="Bound">x</a> <a id="22192" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22194" href="../Connectives/#22176" class="Bound">z</a> <a id="22196" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>
                 <a id="22215" class="Symbol">;</a> <a id="22217" class="Symbol">(</a><a id="22218" href="../Connectives/#11325" class="InductiveConstructor">inj₂</a> <a id="22223" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22225" href="../Connectives/#22225" class="Bound">y</a> <a id="22227" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22229" href="../Connectives/#22229" class="Bound">z</a> <a id="22231" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a><a id="22232" class="Symbol">)</a> <a id="22234" class="Symbol">→</a> <a id="22236" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22238" href="../Connectives/#11325" class="InductiveConstructor">inj₂</a> <a id="22243" href="../Connectives/#22225" class="Bound">y</a> <a id="22245" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22247" href="../Connectives/#22229" class="Bound">z</a> <a id="22249" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>
                 <a id="22268" class="Symbol">}</a>
    <a id="22274" class="Symbol">;</a> <a id="22276" href="../Isomorphism/#4407" class="Field">from∘to</a> <a id="22284" class="Symbol">=</a> <a id="22286" class="Symbol">λ{</a> <a id="22289" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22291" href="../Connectives/#11283" class="InductiveConstructor">inj₁</a> <a id="22296" href="../Connectives/#22296" class="Bound">x</a> <a id="22298" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22300" href="../Connectives/#22300" class="Bound">z</a> <a id="22302" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="22304" class="Symbol">→</a> <a id="22306" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
                 <a id="22328" class="Symbol">;</a> <a id="22330" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22332" href="../Connectives/#11325" class="InductiveConstructor">inj₂</a> <a id="22337" href="../Connectives/#22337" class="Bound">y</a> <a id="22339" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22341" href="../Connectives/#22341" class="Bound">z</a> <a id="22343" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="22345" class="Symbol">→</a> <a id="22347" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
                 <a id="22369" class="Symbol">}</a>
    <a id="22375" class="Symbol">;</a> <a id="22377" href="../Isomorphism/#4449" class="Field">to∘from</a> <a id="22385" class="Symbol">=</a> <a id="22387" class="Symbol">λ{</a> <a id="22390" class="Symbol">(</a><a id="22391" href="../Connectives/#11283" class="InductiveConstructor">inj₁</a> <a id="22396" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22398" href="../Connectives/#22398" class="Bound">x</a> <a id="22400" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22402" href="../Connectives/#22402" class="Bound">z</a> <a id="22404" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a><a id="22405" class="Symbol">)</a> <a id="22407" class="Symbol">→</a> <a id="22409" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
                 <a id="22431" class="Symbol">;</a> <a id="22433" class="Symbol">(</a><a id="22434" href="../Connectives/#11325" class="InductiveConstructor">inj₂</a> <a id="22439" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22441" href="../Connectives/#22441" class="Bound">y</a> <a id="22443" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22445" href="../Connectives/#22445" class="Bound">z</a> <a id="22447" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a><a id="22448" class="Symbol">)</a> <a id="22450" class="Symbol">→</a> <a id="22452" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
                 <a id="22474" class="Symbol">}</a>
    <a id="22480" class="Symbol">}</a>
</pre>
Sums do not distribute over products up to isomorphism, but it is an embedding:
<pre class="Agda"><a id="⊎-distrib-×"></a><a id="22571" href="../Connectives/#22571" class="Function">⊎-distrib-×</a> <a id="22583" class="Symbol">:</a> <a id="22585" class="Symbol">∀</a> <a id="22587" class="Symbol">{</a><a id="22588" href="../Connectives/#22588" class="Bound">A</a> <a id="22590" href="../Connectives/#22590" class="Bound">B</a> <a id="22592" href="../Connectives/#22592" class="Bound">C</a> <a id="22594" class="Symbol">:</a> <a id="22596" class="PrimitiveType">Set</a><a id="22599" class="Symbol">}</a> <a id="22601" class="Symbol">→</a> <a id="22603" class="Symbol">(</a><a id="22604" href="../Connectives/#22588" class="Bound">A</a> <a id="22606" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="22608" href="../Connectives/#22590" class="Bound">B</a><a id="22609" class="Symbol">)</a> <a id="22611" href="../Connectives/#11252" class="Datatype Operator">⊎</a> <a id="22613" href="../Connectives/#22592" class="Bound">C</a> <a id="22615" href="../Isomorphism/#9231" class="Record Operator">≲</a> <a id="22617" class="Symbol">(</a><a id="22618" href="../Connectives/#22588" class="Bound">A</a> <a id="22620" href="../Connectives/#11252" class="Datatype Operator">⊎</a> <a id="22622" href="../Connectives/#22592" class="Bound">C</a><a id="22623" class="Symbol">)</a> <a id="22625" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="22627" class="Symbol">(</a><a id="22628" href="../Connectives/#22590" class="Bound">B</a> <a id="22630" href="../Connectives/#11252" class="Datatype Operator">⊎</a> <a id="22632" href="../Connectives/#22592" class="Bound">C</a><a id="22633" class="Symbol">)</a>
<a id="22635" href="../Connectives/#22571" class="Function">⊎-distrib-×</a> <a id="22647" class="Symbol">=</a>
  <a id="22651" class="Keyword">record</a>
    <a id="22662" class="Symbol">{</a> <a id="22664" href="../Isomorphism/#9271" class="Field">to</a>      <a id="22672" class="Symbol">=</a> <a id="22674" class="Symbol">λ{</a> <a id="22677" class="Symbol">(</a><a id="22678" href="../Connectives/#11283" class="InductiveConstructor">inj₁</a> <a id="22683" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22685" href="../Connectives/#22685" class="Bound">x</a> <a id="22687" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22689" href="../Connectives/#22689" class="Bound">y</a> <a id="22691" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a><a id="22692" class="Symbol">)</a> <a id="22694" class="Symbol">→</a> <a id="22696" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22698" href="../Connectives/#11283" class="InductiveConstructor">inj₁</a> <a id="22703" href="../Connectives/#22685" class="Bound">x</a> <a id="22705" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22707" href="../Connectives/#11283" class="InductiveConstructor">inj₁</a> <a id="22712" href="../Connectives/#22689" class="Bound">y</a> <a id="22714" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>
                 <a id="22733" class="Symbol">;</a> <a id="22735" class="Symbol">(</a><a id="22736" href="../Connectives/#11325" class="InductiveConstructor">inj₂</a> <a id="22741" href="../Connectives/#22741" class="Bound">z</a><a id="22742" class="Symbol">)</a>         <a id="22752" class="Symbol">→</a> <a id="22754" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22756" href="../Connectives/#11325" class="InductiveConstructor">inj₂</a> <a id="22761" href="../Connectives/#22741" class="Bound">z</a> <a id="22763" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22765" href="../Connectives/#11325" class="InductiveConstructor">inj₂</a> <a id="22770" href="../Connectives/#22741" class="Bound">z</a> <a id="22772" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>
                 <a id="22791" class="Symbol">}</a>
    <a id="22797" class="Symbol">;</a> <a id="22799" href="../Isomorphism/#9291" class="Field">from</a>    <a id="22807" class="Symbol">=</a> <a id="22809" class="Symbol">λ{</a> <a id="22812" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22814" href="../Connectives/#11283" class="InductiveConstructor">inj₁</a> <a id="22819" href="../Connectives/#22819" class="Bound">x</a> <a id="22821" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22823" href="../Connectives/#11283" class="InductiveConstructor">inj₁</a> <a id="22828" href="../Connectives/#22828" class="Bound">y</a> <a id="22830" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="22832" class="Symbol">→</a> <a id="22834" class="Symbol">(</a><a id="22835" href="../Connectives/#11283" class="InductiveConstructor">inj₁</a> <a id="22840" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22842" href="../Connectives/#22819" class="Bound">x</a> <a id="22844" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22846" href="../Connectives/#22828" class="Bound">y</a> <a id="22848" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a><a id="22849" class="Symbol">)</a>
                 <a id="22868" class="Symbol">;</a> <a id="22870" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22872" href="../Connectives/#11283" class="InductiveConstructor">inj₁</a> <a id="22877" href="../Connectives/#22877" class="Bound">x</a> <a id="22879" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22881" href="../Connectives/#11325" class="InductiveConstructor">inj₂</a> <a id="22886" href="../Connectives/#22886" class="Bound">z</a> <a id="22888" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="22890" class="Symbol">→</a> <a id="22892" class="Symbol">(</a><a id="22893" href="../Connectives/#11325" class="InductiveConstructor">inj₂</a> <a id="22898" href="../Connectives/#22886" class="Bound">z</a><a id="22899" class="Symbol">)</a>
                 <a id="22918" class="Symbol">;</a> <a id="22920" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22922" href="../Connectives/#11325" class="InductiveConstructor">inj₂</a> <a id="22927" href="../Connectives/#22927" class="Bound">z</a> <a id="22929" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22931" class="Symbol">_</a>      <a id="22938" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="22940" class="Symbol">→</a> <a id="22942" class="Symbol">(</a><a id="22943" href="../Connectives/#11325" class="InductiveConstructor">inj₂</a> <a id="22948" href="../Connectives/#22927" class="Bound">z</a><a id="22949" class="Symbol">)</a>
                 <a id="22968" class="Symbol">}</a>
    <a id="22974" class="Symbol">;</a> <a id="22976" href="../Isomorphism/#9311" class="Field">from∘to</a> <a id="22984" class="Symbol">=</a> <a id="22986" class="Symbol">λ{</a> <a id="22989" class="Symbol">(</a><a id="22990" href="../Connectives/#11283" class="InductiveConstructor">inj₁</a> <a id="22995" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22997" href="../Connectives/#22997" class="Bound">x</a> <a id="22999" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="23001" href="../Connectives/#23001" class="Bound">y</a> <a id="23003" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a><a id="23004" class="Symbol">)</a> <a id="23006" class="Symbol">→</a> <a id="23008" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
                 <a id="23030" class="Symbol">;</a> <a id="23032" class="Symbol">(</a><a id="23033" href="../Connectives/#11325" class="InductiveConstructor">inj₂</a> <a id="23038" href="../Connectives/#23038" class="Bound">z</a><a id="23039" class="Symbol">)</a>         <a id="23049" class="Symbol">→</a> <a id="23051" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
                 <a id="23073" class="Symbol">}</a>
    <a id="23079" class="Symbol">}</a>
</pre>
<p>Note that there is a choice in how we write the <code>from</code> function. As given, it takes <code>⟨ inj₂ z , inj₂ z′ ⟩</code> to <code>inj₂ z</code>, but it is easy to write a variant that instead returns <code>inj₂ z′</code>. We have an embedding rather than an isomorphism because the <code>from</code> function must discard either <code>z</code> or <code>z′</code> in this case.</p>
<p>In the usual approach to logic, both of the distribution laws are given as equivalences, where each side implies the other:</p>
<pre><code>A × (B ⊎ C) ⇔ (A × B) ⊎ (A × C)
A ⊎ (B × C) ⇔ (A ⊎ B) × (A ⊎ C)</code></pre>
<p>But when we consider the functions that provide evidence for these implications, then the first corresponds to an isomorphism while the second only corresponds to an embedding, revealing a sense in which one of these laws is “more true” than the other.</p>
<h4 id="exercise--weak--recommended">Exercise <code>⊎-weak-×</code> (recommended)</h4>
Show that the following property holds:
<pre class="Agda"><a id="23932" class="Keyword">postulate</a>
  <a id="⊎-weak-×"></a><a id="23944" href="../Connectives/#23944" class="Postulate">⊎-weak-×</a> <a id="23953" class="Symbol">:</a> <a id="23955" class="Symbol">∀</a> <a id="23957" class="Symbol">{</a><a id="23958" href="../Connectives/#23958" class="Bound">A</a> <a id="23960" href="../Connectives/#23960" class="Bound">B</a> <a id="23962" href="../Connectives/#23962" class="Bound">C</a> <a id="23964" class="Symbol">:</a> <a id="23966" class="PrimitiveType">Set</a><a id="23969" class="Symbol">}</a> <a id="23971" class="Symbol">→</a> <a id="23973" class="Symbol">(</a><a id="23974" href="../Connectives/#23958" class="Bound">A</a> <a id="23976" href="../Connectives/#11252" class="Datatype Operator">⊎</a> <a id="23978" href="../Connectives/#23960" class="Bound">B</a><a id="23979" class="Symbol">)</a> <a id="23981" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="23983" href="../Connectives/#23962" class="Bound">C</a> <a id="23985" class="Symbol">→</a> <a id="23987" href="../Connectives/#23958" class="Bound">A</a> <a id="23989" href="../Connectives/#11252" class="Datatype Operator">⊎</a> <a id="23991" class="Symbol">(</a><a id="23992" href="../Connectives/#23960" class="Bound">B</a> <a id="23994" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="23996" href="../Connectives/#23962" class="Bound">C</a><a id="23997" class="Symbol">)</a>
</pre>
<p>This is called a <em>weak distributive law</em>. Give the corresponding distributive law, and explain how it relates to the weak version.</p>
<pre class="Agda"><a id="24139" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise--implies--practice">Exercise <code>⊎×-implies-×⊎</code> (practice)</h4>
Show that a disjunct of conjuncts implies a conjunct of disjuncts:
<pre class="Agda"><a id="24281" class="Keyword">postulate</a>
  <a id="⊎×-implies-×⊎"></a><a id="24293" href="../Connectives/#24293" class="Postulate">⊎×-implies-×⊎</a> <a id="24307" class="Symbol">:</a> <a id="24309" class="Symbol">∀</a> <a id="24311" class="Symbol">{</a><a id="24312" href="../Connectives/#24312" class="Bound">A</a> <a id="24314" href="../Connectives/#24314" class="Bound">B</a> <a id="24316" href="../Connectives/#24316" class="Bound">C</a> <a id="24318" href="../Connectives/#24318" class="Bound">D</a> <a id="24320" class="Symbol">:</a> <a id="24322" class="PrimitiveType">Set</a><a id="24325" class="Symbol">}</a> <a id="24327" class="Symbol">→</a> <a id="24329" class="Symbol">(</a><a id="24330" href="../Connectives/#24312" class="Bound">A</a> <a id="24332" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="24334" href="../Connectives/#24314" class="Bound">B</a><a id="24335" class="Symbol">)</a> <a id="24337" href="../Connectives/#11252" class="Datatype Operator">⊎</a> <a id="24339" class="Symbol">(</a><a id="24340" href="../Connectives/#24316" class="Bound">C</a> <a id="24342" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="24344" href="../Connectives/#24318" class="Bound">D</a><a id="24345" class="Symbol">)</a> <a id="24347" class="Symbol">→</a> <a id="24349" class="Symbol">(</a><a id="24350" href="../Connectives/#24312" class="Bound">A</a> <a id="24352" href="../Connectives/#11252" class="Datatype Operator">⊎</a> <a id="24354" href="../Connectives/#24316" class="Bound">C</a><a id="24355" class="Symbol">)</a> <a id="24357" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="24359" class="Symbol">(</a><a id="24360" href="../Connectives/#24314" class="Bound">B</a> <a id="24362" href="../Connectives/#11252" class="Datatype Operator">⊎</a> <a id="24364" href="../Connectives/#24318" class="Bound">D</a><a id="24365" class="Symbol">)</a>
</pre>
<p>Does the converse hold? If so, prove; if not, give a counterexample.</p>
<pre class="Agda"><a id="24445" class="Comment">-- Your code goes here</a>
</pre>
<h2 id="standard-library">Standard library</h2>
Definitions similar to those in this chapter can be found in the standard library:
<pre class="Agda"><a id="24582" class="Keyword">import</a> <a id="24589" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html" class="Module">Data.Product</a> <a id="24602" class="Keyword">using</a> <a id="24608" class="Symbol">(</a><a id="24609" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1167" class="Function Operator">_×_</a><a id="24612" class="Symbol">;</a> <a id="24614" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="24619" class="Symbol">;</a> <a id="24621" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Sigma.html#264" class="Field">proj₂</a><a id="24626" class="Symbol">)</a> <a id="24628" class="Keyword">renaming</a> <a id="24637" class="Symbol">(</a><a id="24638" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a> <a id="24642" class="Symbol">to</a> <a id="_,_"></a><a id="24645" href="../Connectives/#24645" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="24650" class="Symbol">)</a>
<a id="24652" class="Keyword">import</a> <a id="24659" href="https://agda.github.io/agda-stdlib/v1.3/Data.Unit.html" class="Module">Data.Unit</a> <a id="24669" class="Keyword">using</a> <a id="24675" class="Symbol">(</a><a id="24676" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Unit.html#164" class="Record">⊤</a><a id="24677" class="Symbol">;</a> <a id="24679" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a><a id="24681" class="Symbol">)</a>
<a id="24683" class="Keyword">import</a> <a id="24690" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.html" class="Module">Data.Sum</a> <a id="24699" class="Keyword">using</a> <a id="24705" class="Symbol">(</a><a id="24706" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#728" class="Datatype Operator">_⊎_</a><a id="24709" class="Symbol">;</a> <a id="24711" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#778" class="InductiveConstructor">inj₁</a><a id="24715" class="Symbol">;</a> <a id="24717" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#803" class="InductiveConstructor">inj₂</a><a id="24721" class="Symbol">)</a> <a id="24723" class="Keyword">renaming</a> <a id="24732" class="Symbol">(</a><a id="24733" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#914" class="Function Operator">[_,_]</a> <a id="24739" class="Symbol">to</a> <a id="[_,_]"></a><a id="24742" href="../Connectives/#24742" class="Function Operator">case-⊎</a><a id="24748" class="Symbol">)</a>
<a id="24750" class="Keyword">import</a> <a id="24757" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html" class="Module">Data.Empty</a> <a id="24768" class="Keyword">using</a> <a id="24774" class="Symbol">(</a><a id="24775" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html#526" class="Datatype">⊥</a><a id="24776" class="Symbol">;</a> <a id="24778" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html#628" class="Function">⊥-elim</a><a id="24784" class="Symbol">)</a>
<a id="24786" class="Keyword">import</a> <a id="24793" href="https://agda.github.io/agda-stdlib/v1.3/Function.Equivalence.html" class="Module">Function.Equivalence</a> <a id="24814" class="Keyword">using</a> <a id="24820" class="Symbol">(</a><a id="24821" href="https://agda.github.io/agda-stdlib/v1.3/Function.Equivalence.html#971" class="Function Operator">_⇔_</a><a id="24824" class="Symbol">)</a>
</pre>
<p>The standard library constructs pairs with <code>_,_</code> whereas we use <code>⟨_,_⟩</code>. The former makes it convenient to build triples or larger tuples from pairs, permitting <code>a , b , c</code> to stand for <code>(a , (b , c))</code>. But it conflicts with other useful notations, such as <code>[_,_]</code> to construct a list of two elements in Chapter <a href="../Lists/">Lists</a> and <code>Γ , A</code> to extend environments in Chapter <a href="../DeBruijn/">DeBruijn</a>. The standard library <code>_⇔_</code> is similar to ours, but the one in the standard library is less convenient, since it is parameterised with respect to an arbitrary notion of equivalence.</p>
<h2 id="unicode">Unicode</h2>
<p>This chapter uses the following unicode:</p>
<pre><code>×  U+00D7  MULTIPLICATION SIGN (\x)
⊎  U+228E  MULTISET UNION (\u+)
⊤  U+22A4  DOWN TACK (\top)
⊥  U+22A5  UP TACK (\bot)
η  U+03B7  GREEK SMALL LETTER ETA (\eta)
₁  U+2081  SUBSCRIPT ONE (\_1)
₂  U+2082  SUBSCRIPT TWO (\_2)
⇔  U+21D4  LEFT RIGHT DOUBLE ARROW (\&lt;=&gt;)</code></pre>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>This paragraph was adopted from “Propositions as Types”, Philip Wadler, <em>Communications of the ACM</em>, December 2015.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
    </div>
    <nav class="pager">
    <ul class="pagination">
        
        <li><a class="pagelink" href="../Isomorphism/">Prev</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Connectives.lagda.md">Source</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="../Negation/">Next</a></li>
        <li class="separator">&bullet;</li>
        
    </ul>
</nav>

</article>

            </div>
        </main>
        <footer class="site-footer h-card">
    <data class="u-url" href="../"></data>
    <div class="wrapper">
        <h2 class="footer-heading">Programming Language Foundations in Agda</h2>
        
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Philip Wadler</li>
                    <li>
                        
                        <a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/wadler" title="wadler"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;wadler</a></li>
    
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Wen Kokke</li>
                    <li>
                        
                        <a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;wenkokke</a></li>
    
    
    <li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#twitter"></use></svg>&nbsp;wenkokke</a></li>
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Jeremy G. Siek</li>
                    <li>
                        
                        <a class="u-email" href="mailto:jsiek@indiana.edu">jsiek@indiana.edu</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/jsiek" title="jsiek"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;jsiek</a></li>
    
    
    <li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#twitter"></use></svg>&nbsp;jeremysiek</a></li>
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        
        This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
    </div>
</footer>

    </body>
</html>
