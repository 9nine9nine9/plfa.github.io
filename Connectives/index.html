<!DOCTYPE html>
<html lang="en">
    <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../public/css/style.css">
  
  <title>Programming Language Foundations in Agda – Connectives</title>
  
  
  
</head>

    <body>
        <header class="site-header">
    <div class="wrapper">
        <a class="site-title" href="../">Programming Language Foundations in Agda</a>
        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="../">The Book</a>
                <a class="page-link" href="../Announcements/">Announcements</a>
                <a class="page-link" href="../GettingStarted/">Getting Started</a>
                <a class="page-link" href="../Citing/">Citing</a>
                <a class="page-link" href="https://agda-zh.github.io/PLFA-zh/">中文</a>
            </div>
        </nav>
    </div>
</header>

        <main class="page-content" aria-label="Content">
            <div class="wrapper">
                <article class="post">
    <nav class="pager">
    <ul class="pagination">
        
        <li><a class="pagelink" href="../Isomorphism/">Prev</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Connectives.lagda.md">Source</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="../Negation/">Next</a></li>
        <li class="separator">&bullet;</li>
        
    </ul>
</nav>

    <header class="post-header">
        <h1 class="post-title">Connectives: Conjunction, disjunction, and implication</h1>
    </header>
    <div class="post-content">
        <pre class="Agda"><a id="175" class="Keyword">module</a> <a id="182" href="../Connectives/" class="Module">plfa.part1.Connectives</a> <a id="205" class="Keyword">where</a>
</pre>
<!-- The ⊥ ⊎ A ≅ A exercise requires a (inj₁ ()) pattern,
     which the reader will not have seen. Restore this
     exercise, and possibly also associativity? Take the
     exercises from the final sections on distributivity
     and exponentials? -->
<p>This chapter introduces the basic logical connectives, by observing a correspondence between connectives of logic and data types, a principle known as <em>Propositions as Types</em>:</p>
<ul>
<li><em>conjunction</em> is <em>product</em>,</li>
<li><em>disjunction</em> is <em>sum</em>,</li>
<li><em>true</em> is <em>unit type</em>,</li>
<li><em>false</em> is <em>empty type</em>,</li>
<li><em>implication</em> is <em>function space</em>.</li>
</ul>
<h2 id="imports">Imports</h2>
<pre class="Agda"><a id="821" class="Keyword">import</a> <a id="828" href="https://agda.github.io/agda-stdlib/v1.6/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="866" class="Symbol">as</a> <a id="869" class="Module">Eq</a>
<a id="872" class="Keyword">open</a> <a id="877" href="https://agda.github.io/agda-stdlib/v1.6/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="880" class="Keyword">using</a> <a id="886" class="Symbol">(</a><a id="887" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="890" class="Symbol">;</a> <a id="892" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="896" class="Symbol">)</a>
<a id="898" class="Keyword">open</a> <a id="903" href="https://agda.github.io/agda-stdlib/v1.6/Relation.Binary.PropositionalEquality.Core.html#2708" class="Module">Eq.≡-Reasoning</a>
<a id="918" class="Keyword">open</a> <a id="923" class="Keyword">import</a> <a id="930" href="https://agda.github.io/agda-stdlib/v1.6/Data.Nat.html" class="Module">Data.Nat</a> <a id="939" class="Keyword">using</a> <a id="945" class="Symbol">(</a><a id="946" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="947" class="Symbol">)</a>
<a id="949" class="Keyword">open</a> <a id="954" class="Keyword">import</a> <a id="961" href="https://agda.github.io/agda-stdlib/v1.6/Function.html" class="Module">Function</a> <a id="970" class="Keyword">using</a> <a id="976" class="Symbol">(</a><a id="977" href="https://agda.github.io/agda-stdlib/v1.6/Function.Base.html#1031" class="Function Operator">_∘_</a><a id="980" class="Symbol">)</a>
<a id="982" class="Keyword">open</a> <a id="987" class="Keyword">import</a> <a id="994" href="../Isomorphism/" class="Module">plfa.part1.Isomorphism</a> <a id="1017" class="Keyword">using</a> <a id="1023" class="Symbol">(</a><a id="1024" href="../Isomorphism/#4333" class="Record Operator">_≃_</a><a id="1027" class="Symbol">;</a> <a id="1029" href="../Isomorphism/#9231" class="Record Operator">_≲_</a><a id="1032" class="Symbol">;</a> <a id="1034" href="../Isomorphism/#2670" class="Postulate">extensionality</a><a id="1048" class="Symbol">)</a>
<a id="1050" class="Keyword">open</a> <a id="1055" href="../Isomorphism/#8466" class="Module">plfa.part1.Isomorphism.≃-Reasoning</a>
</pre>
<h2 id="conjunction-is-product">Conjunction is product</h2>
Given two propositions <code>A</code> and <code>B</code>, the conjunction <code>A × B</code> holds if both <code>A</code> holds and <code>B</code> holds. We formalise this idea by declaring a suitable record type:
<pre class="Agda"><a id="1287" class="Keyword">data</a> <a id="_×_"></a><a id="1292" href="../Connectives/#1292" class="Datatype Operator">_×_</a> <a id="1296" class="Symbol">(</a><a id="1297" href="../Connectives/#1297" class="Bound">A</a> <a id="1299" href="../Connectives/#1299" class="Bound">B</a> <a id="1301" class="Symbol">:</a> <a id="1303" class="PrimitiveType">Set</a><a id="1306" class="Symbol">)</a> <a id="1308" class="Symbol">:</a> <a id="1310" class="PrimitiveType">Set</a> <a id="1314" class="Keyword">where</a>

  <a id="_×_.⟨_,_⟩"></a><a id="1323" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨_,_⟩</a> <a id="1329" class="Symbol">:</a>
      <a id="1337" href="../Connectives/#1297" class="Bound">A</a>
    <a id="1343" class="Symbol">→</a> <a id="1345" href="../Connectives/#1299" class="Bound">B</a>
      <a id="1353" class="Comment">-----</a>
    <a id="1363" class="Symbol">→</a> <a id="1365" href="../Connectives/#1297" class="Bound">A</a> <a id="1367" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="1369" href="../Connectives/#1299" class="Bound">B</a>
</pre>
<p>Evidence that <code>A × B</code> holds is of the form <code>⟨ M , N ⟩</code>, where <code>M</code> provides evidence that <code>A</code> holds and <code>N</code> provides evidence that <code>B</code> holds.</p>
Given evidence that <code>A × B</code> holds, we can conclude that both <code>A</code> holds and <code>B</code> holds:
<pre class="Agda"><a id="proj₁"></a><a id="1607" href="../Connectives/#1607" class="Function">proj₁</a> <a id="1613" class="Symbol">:</a> <a id="1615" class="Symbol">∀</a> <a id="1617" class="Symbol">{</a><a id="1618" href="../Connectives/#1618" class="Bound">A</a> <a id="1620" href="../Connectives/#1620" class="Bound">B</a> <a id="1622" class="Symbol">:</a> <a id="1624" class="PrimitiveType">Set</a><a id="1627" class="Symbol">}</a>
  <a id="1631" class="Symbol">→</a> <a id="1633" href="../Connectives/#1618" class="Bound">A</a> <a id="1635" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="1637" href="../Connectives/#1620" class="Bound">B</a>
    <a id="1643" class="Comment">-----</a>
  <a id="1651" class="Symbol">→</a> <a id="1653" href="../Connectives/#1618" class="Bound">A</a>
<a id="1655" href="../Connectives/#1607" class="Function">proj₁</a> <a id="1661" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="1663" href="../Connectives/#1663" class="Bound">x</a> <a id="1665" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="1667" href="../Connectives/#1667" class="Bound">y</a> <a id="1669" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="1671" class="Symbol">=</a> <a id="1673" href="../Connectives/#1663" class="Bound">x</a>

<a id="proj₂"></a><a id="1676" href="../Connectives/#1676" class="Function">proj₂</a> <a id="1682" class="Symbol">:</a> <a id="1684" class="Symbol">∀</a> <a id="1686" class="Symbol">{</a><a id="1687" href="../Connectives/#1687" class="Bound">A</a> <a id="1689" href="../Connectives/#1689" class="Bound">B</a> <a id="1691" class="Symbol">:</a> <a id="1693" class="PrimitiveType">Set</a><a id="1696" class="Symbol">}</a>
  <a id="1700" class="Symbol">→</a> <a id="1702" href="../Connectives/#1687" class="Bound">A</a> <a id="1704" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="1706" href="../Connectives/#1689" class="Bound">B</a>
    <a id="1712" class="Comment">-----</a>
  <a id="1720" class="Symbol">→</a> <a id="1722" href="../Connectives/#1689" class="Bound">B</a>
<a id="1724" href="../Connectives/#1676" class="Function">proj₂</a> <a id="1730" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="1732" href="../Connectives/#1732" class="Bound">x</a> <a id="1734" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="1736" href="../Connectives/#1736" class="Bound">y</a> <a id="1738" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="1740" class="Symbol">=</a> <a id="1742" href="../Connectives/#1736" class="Bound">y</a>
</pre>
<p>If <code>L</code> provides evidence that <code>A × B</code> holds, then <code>proj₁ L</code> provides evidence that <code>A</code> holds, and <code>proj₂ L</code> provides evidence that <code>B</code> holds.</p>
<p>When <code>⟨_,_⟩</code> appears in a term on the right-hand side of an equation we refer to it as a <em>constructor</em>, and when it appears in a pattern on the left-hand side of an equation we refer to it as a <em>destructor</em>. We may also refer to <code>proj₁</code> and <code>proj₂</code> as destructors, since they play a similar role.</p>
<p>Other terminology refers to <code>⟨_,_⟩</code> as <em>introducing</em> a conjunction, and to <code>proj₁</code> and <code>proj₂</code> as <em>eliminating</em> a conjunction; indeed, the former is sometimes given the name <code>×-I</code> and the latter two the names <code>×-E₁</code> and <code>×-E₂</code>. As we read the rules from top to bottom, introduction and elimination do what they say on the tin: the first <em>introduces</em> a formula for the connective, which appears in the conclusion but not in the hypotheses; the second <em>eliminates</em> a formula for the connective, which appears in a hypothesis but not in the conclusion. An introduction rule describes under what conditions we say the connective holds—how to <em>define</em> the connective. An elimination rule describes what we may conclude when the connective holds—how to <em>use</em> the connective.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
In this case, applying each destructor and reassembling the results with the constructor is the identity over products:
<pre class="Agda"><a id="η-×"></a><a id="3107" href="../Connectives/#3107" class="Function">η-×</a> <a id="3111" class="Symbol">:</a> <a id="3113" class="Symbol">∀</a> <a id="3115" class="Symbol">{</a><a id="3116" href="../Connectives/#3116" class="Bound">A</a> <a id="3118" href="../Connectives/#3118" class="Bound">B</a> <a id="3120" class="Symbol">:</a> <a id="3122" class="PrimitiveType">Set</a><a id="3125" class="Symbol">}</a> <a id="3127" class="Symbol">(</a><a id="3128" href="../Connectives/#3128" class="Bound">w</a> <a id="3130" class="Symbol">:</a> <a id="3132" href="../Connectives/#3116" class="Bound">A</a> <a id="3134" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="3136" href="../Connectives/#3118" class="Bound">B</a><a id="3137" class="Symbol">)</a> <a id="3139" class="Symbol">→</a> <a id="3141" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="3143" href="../Connectives/#1607" class="Function">proj₁</a> <a id="3149" href="../Connectives/#3128" class="Bound">w</a> <a id="3151" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="3153" href="../Connectives/#1676" class="Function">proj₂</a> <a id="3159" href="../Connectives/#3128" class="Bound">w</a> <a id="3161" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="3163" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="3165" href="../Connectives/#3128" class="Bound">w</a>
<a id="3167" href="../Connectives/#3107" class="Function">η-×</a> <a id="3171" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="3173" href="../Connectives/#3173" class="Bound">x</a> <a id="3175" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="3177" href="../Connectives/#3177" class="Bound">y</a> <a id="3179" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="3181" class="Symbol">=</a> <a id="3183" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>The pattern matching on the left-hand side is essential, since replacing <code>w</code> by <code>⟨ x , y ⟩</code> allows both sides of the propositional equality to simplify to the same term.</p>
We set the precedence of conjunction so that it binds less tightly than anything save disjunction:
<pre class="Agda"><a id="3466" class="Keyword">infixr</a> <a id="3473" class="Number">2</a> <a id="3475" href="../Connectives/#1292" class="Datatype Operator">_×_</a>
</pre>
<p>Thus, <code>m ≤ n × n ≤ p</code> parses as <code>(m ≤ n) × (n ≤ p)</code>.</p>
Alternatively, we can declare conjunction as a record type:
<pre class="Agda"><a id="3601" class="Keyword">record</a> <a id="_×′_"></a><a id="3608" href="../Connectives/#3608" class="Record Operator">_×′_</a> <a id="3613" class="Symbol">(</a><a id="3614" href="../Connectives/#3614" class="Bound">A</a> <a id="3616" href="../Connectives/#3616" class="Bound">B</a> <a id="3618" class="Symbol">:</a> <a id="3620" class="PrimitiveType">Set</a><a id="3623" class="Symbol">)</a> <a id="3625" class="Symbol">:</a> <a id="3627" class="PrimitiveType">Set</a> <a id="3631" class="Keyword">where</a>
  <a id="3639" class="Keyword">constructor</a> <a id="⟨_,_⟩′"></a><a id="3651" href="../Connectives/#3651" class="InductiveConstructor Operator">⟨_,_⟩′</a>
  <a id="3660" class="Keyword">field</a>
    <a id="_×′_.proj₁′"></a><a id="3670" href="../Connectives/#3670" class="Field">proj₁′</a> <a id="3677" class="Symbol">:</a> <a id="3679" href="../Connectives/#3614" class="Bound">A</a>
    <a id="_×′_.proj₂′"></a><a id="3685" href="../Connectives/#3685" class="Field">proj₂′</a> <a id="3692" class="Symbol">:</a> <a id="3694" href="../Connectives/#3616" class="Bound">B</a>
<a id="3696" class="Keyword">open</a> <a id="3701" href="../Connectives/#3608" class="Module Operator">_×′_</a>
</pre>
<p>The record construction <code>record { proj₁′ = M ; proj₂′ = N }</code> corresponds to the term <code>⟨ M , N ⟩</code> where <code>M</code> is a term of type <code>A</code> and <code>N</code> is a term of type <code>B</code>. The constructor declaration allows us to write <code>⟨ M , N ⟩′</code> in place of the record construction.</p>
The data type <code>_x_</code> and the record type <code>_×′_</code> behave similarly. One difference is that for data types we have to prove η-equality, but for record types, η-equality holds <em>by definition</em>. While proving <code>η-×′</code>, we do not have to pattern match on <code>w</code> to know that η-equality holds:
<pre class="Agda"><a id="η-×′"></a><a id="4252" href="../Connectives/#4252" class="Function">η-×′</a> <a id="4257" class="Symbol">:</a> <a id="4259" class="Symbol">∀</a> <a id="4261" class="Symbol">{</a><a id="4262" href="../Connectives/#4262" class="Bound">A</a> <a id="4264" href="../Connectives/#4264" class="Bound">B</a> <a id="4266" class="Symbol">:</a> <a id="4268" class="PrimitiveType">Set</a><a id="4271" class="Symbol">}</a> <a id="4273" class="Symbol">(</a><a id="4274" href="../Connectives/#4274" class="Bound">w</a> <a id="4276" class="Symbol">:</a> <a id="4278" href="../Connectives/#4262" class="Bound">A</a> <a id="4280" href="../Connectives/#3608" class="Record Operator">×′</a> <a id="4283" href="../Connectives/#4264" class="Bound">B</a><a id="4284" class="Symbol">)</a> <a id="4286" class="Symbol">→</a> <a id="4288" href="../Connectives/#3651" class="InductiveConstructor Operator">⟨</a> <a id="4290" href="../Connectives/#3670" class="Field">proj₁′</a> <a id="4297" href="../Connectives/#4274" class="Bound">w</a> <a id="4299" href="../Connectives/#3651" class="InductiveConstructor Operator">,</a> <a id="4301" href="../Connectives/#3685" class="Field">proj₂′</a> <a id="4308" href="../Connectives/#4274" class="Bound">w</a> <a id="4310" href="../Connectives/#3651" class="InductiveConstructor Operator">⟩′</a> <a id="4313" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="4315" href="../Connectives/#4274" class="Bound">w</a>
<a id="4317" href="../Connectives/#4252" class="Function">η-×′</a> <a id="4322" href="../Connectives/#4322" class="Bound">w</a> <a id="4324" class="Symbol">=</a> <a id="4326" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>It can be very convenient to have η-equality <em>definitionally</em>, and so the standard library defines <code>_×_</code> as a record type. We use the definition from the standard library in later chapters.</p>
Given two types <code>A</code> and <code>B</code>, we refer to <code>A × B</code> as the <em>product</em> of <code>A</code> and <code>B</code>. In set theory, it is also sometimes called the <em>Cartesian product</em>, and in computing it corresponds to a <em>record</em> type. Among other reasons for calling it the product, note that if type <code>A</code> has <code>m</code> distinct members, and type <code>B</code> has <code>n</code> distinct members, then the type <code>A × B</code> has <code>m * n</code> distinct members. For instance, consider a type <code>Bool</code> with two members, and a type <code>Tri</code> with three members:
<pre class="Agda"><a id="5013" class="Keyword">data</a> <a id="Bool"></a><a id="5018" href="../Connectives/#5018" class="Datatype">Bool</a> <a id="5023" class="Symbol">:</a> <a id="5025" class="PrimitiveType">Set</a> <a id="5029" class="Keyword">where</a>
  <a id="Bool.true"></a><a id="5037" href="../Connectives/#5037" class="InductiveConstructor">true</a>  <a id="5043" class="Symbol">:</a> <a id="5045" href="../Connectives/#5018" class="Datatype">Bool</a>
  <a id="Bool.false"></a><a id="5052" href="../Connectives/#5052" class="InductiveConstructor">false</a> <a id="5058" class="Symbol">:</a> <a id="5060" href="../Connectives/#5018" class="Datatype">Bool</a>

<a id="5066" class="Keyword">data</a> <a id="Tri"></a><a id="5071" href="../Connectives/#5071" class="Datatype">Tri</a> <a id="5075" class="Symbol">:</a> <a id="5077" class="PrimitiveType">Set</a> <a id="5081" class="Keyword">where</a>
  <a id="Tri.aa"></a><a id="5089" href="../Connectives/#5089" class="InductiveConstructor">aa</a> <a id="5092" class="Symbol">:</a> <a id="5094" href="../Connectives/#5071" class="Datatype">Tri</a>
  <a id="Tri.bb"></a><a id="5100" href="../Connectives/#5100" class="InductiveConstructor">bb</a> <a id="5103" class="Symbol">:</a> <a id="5105" href="../Connectives/#5071" class="Datatype">Tri</a>
  <a id="Tri.cc"></a><a id="5111" href="../Connectives/#5111" class="InductiveConstructor">cc</a> <a id="5114" class="Symbol">:</a> <a id="5116" href="../Connectives/#5071" class="Datatype">Tri</a>
</pre>
<p>Then the type <code>Bool × Tri</code> has six members:</p>
<pre><code>⟨ true  , aa ⟩    ⟨ true  , bb ⟩    ⟨ true ,  cc ⟩
⟨ false , aa ⟩    ⟨ false , bb ⟩    ⟨ false , cc ⟩</code></pre>
For example, the following function enumerates all possible arguments of type <code>Bool × Tri</code>:
<pre class="Agda"><a id="×-count"></a><a id="5376" href="../Connectives/#5376" class="Function">×-count</a> <a id="5384" class="Symbol">:</a> <a id="5386" href="../Connectives/#5018" class="Datatype">Bool</a> <a id="5391" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="5393" href="../Connectives/#5071" class="Datatype">Tri</a> <a id="5397" class="Symbol">→</a> <a id="5399" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="5401" href="../Connectives/#5376" class="Function">×-count</a> <a id="5409" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="5411" href="../Connectives/#5037" class="InductiveConstructor">true</a>  <a id="5417" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="5419" href="../Connectives/#5089" class="InductiveConstructor">aa</a> <a id="5422" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>  <a id="5425" class="Symbol">=</a>  <a id="5428" class="Number">1</a>
<a id="5430" href="../Connectives/#5376" class="Function">×-count</a> <a id="5438" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="5440" href="../Connectives/#5037" class="InductiveConstructor">true</a>  <a id="5446" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="5448" href="../Connectives/#5100" class="InductiveConstructor">bb</a> <a id="5451" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>  <a id="5454" class="Symbol">=</a>  <a id="5457" class="Number">2</a>
<a id="5459" href="../Connectives/#5376" class="Function">×-count</a> <a id="5467" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="5469" href="../Connectives/#5037" class="InductiveConstructor">true</a>  <a id="5475" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="5477" href="../Connectives/#5111" class="InductiveConstructor">cc</a> <a id="5480" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>  <a id="5483" class="Symbol">=</a>  <a id="5486" class="Number">3</a>
<a id="5488" href="../Connectives/#5376" class="Function">×-count</a> <a id="5496" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="5498" href="../Connectives/#5052" class="InductiveConstructor">false</a> <a id="5504" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="5506" href="../Connectives/#5089" class="InductiveConstructor">aa</a> <a id="5509" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>  <a id="5512" class="Symbol">=</a>  <a id="5515" class="Number">4</a>
<a id="5517" href="../Connectives/#5376" class="Function">×-count</a> <a id="5525" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="5527" href="../Connectives/#5052" class="InductiveConstructor">false</a> <a id="5533" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="5535" href="../Connectives/#5100" class="InductiveConstructor">bb</a> <a id="5538" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>  <a id="5541" class="Symbol">=</a>  <a id="5544" class="Number">5</a>
<a id="5546" href="../Connectives/#5376" class="Function">×-count</a> <a id="5554" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="5556" href="../Connectives/#5052" class="InductiveConstructor">false</a> <a id="5562" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="5564" href="../Connectives/#5111" class="InductiveConstructor">cc</a> <a id="5567" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>  <a id="5570" class="Symbol">=</a>  <a id="5573" class="Number">6</a>
</pre>
<p>Product on types also shares a property with product on numbers in that there is a sense in which it is commutative and associative. In particular, product is commutative and associative <em>up to isomorphism</em>.</p>
For commutativity, the <code>to</code> function swaps a pair, taking <code>⟨ x , y ⟩</code> to <code>⟨ y , x ⟩</code>, and the <code>from</code> function does the same (up to renaming). Instantiating the patterns correctly in <code>from∘to</code> and <code>to∘from</code> is essential. Replacing the definition of <code>from∘to</code> by <code>λ w → refl</code> will not work; and similarly for <code>to∘from</code>:
<pre class="Agda"><a id="×-comm"></a><a id="6112" href="../Connectives/#6112" class="Function">×-comm</a> <a id="6119" class="Symbol">:</a> <a id="6121" class="Symbol">∀</a> <a id="6123" class="Symbol">{</a><a id="6124" href="../Connectives/#6124" class="Bound">A</a> <a id="6126" href="../Connectives/#6126" class="Bound">B</a> <a id="6128" class="Symbol">:</a> <a id="6130" class="PrimitiveType">Set</a><a id="6133" class="Symbol">}</a> <a id="6135" class="Symbol">→</a> <a id="6137" href="../Connectives/#6124" class="Bound">A</a> <a id="6139" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="6141" href="../Connectives/#6126" class="Bound">B</a> <a id="6143" href="../Isomorphism/#4333" class="Record Operator">≃</a> <a id="6145" href="../Connectives/#6126" class="Bound">B</a> <a id="6147" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="6149" href="../Connectives/#6124" class="Bound">A</a>
<a id="6151" href="../Connectives/#6112" class="Function">×-comm</a> <a id="6158" class="Symbol">=</a>
  <a id="6162" class="Keyword">record</a>
    <a id="6173" class="Symbol">{</a> <a id="6175" href="../Isomorphism/#4373" class="Field">to</a>       <a id="6184" class="Symbol">=</a>  <a id="6187" class="Symbol">λ{</a> <a id="6190" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="6192" href="../Connectives/#6192" class="Bound">x</a> <a id="6194" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="6196" href="../Connectives/#6196" class="Bound">y</a> <a id="6198" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="6200" class="Symbol">→</a> <a id="6202" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="6204" href="../Connectives/#6196" class="Bound">y</a> <a id="6206" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="6208" href="../Connectives/#6192" class="Bound">x</a> <a id="6210" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="6212" class="Symbol">}</a>
    <a id="6218" class="Symbol">;</a> <a id="6220" href="../Isomorphism/#4390" class="Field">from</a>     <a id="6229" class="Symbol">=</a>  <a id="6232" class="Symbol">λ{</a> <a id="6235" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="6237" href="../Connectives/#6237" class="Bound">y</a> <a id="6239" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="6241" href="../Connectives/#6241" class="Bound">x</a> <a id="6243" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="6245" class="Symbol">→</a> <a id="6247" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="6249" href="../Connectives/#6241" class="Bound">x</a> <a id="6251" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="6253" href="../Connectives/#6237" class="Bound">y</a> <a id="6255" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="6257" class="Symbol">}</a>
    <a id="6263" class="Symbol">;</a> <a id="6265" href="../Isomorphism/#4407" class="Field">from∘to</a>  <a id="6274" class="Symbol">=</a>  <a id="6277" class="Symbol">λ{</a> <a id="6280" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="6282" href="../Connectives/#6282" class="Bound">x</a> <a id="6284" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="6286" href="../Connectives/#6286" class="Bound">y</a> <a id="6288" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="6290" class="Symbol">→</a> <a id="6292" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="6297" class="Symbol">}</a>
    <a id="6303" class="Symbol">;</a> <a id="6305" href="../Isomorphism/#4449" class="Field">to∘from</a>  <a id="6314" class="Symbol">=</a>  <a id="6317" class="Symbol">λ{</a> <a id="6320" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="6322" href="../Connectives/#6322" class="Bound">y</a> <a id="6324" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="6326" href="../Connectives/#6326" class="Bound">x</a> <a id="6328" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="6330" class="Symbol">→</a> <a id="6332" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="6337" class="Symbol">}</a>
    <a id="6343" class="Symbol">}</a>
</pre>
<p>Being <em>commutative</em> is different from being <em>commutative up to isomorphism</em>. Compare the two statements:</p>
<pre><code>m * n ≡ n * m
A × B ≃ B × A</code></pre>
<p>In the first case, we might have that <code>m</code> is <code>2</code> and <code>n</code> is <code>3</code>, and both <code>m * n</code> and <code>n * m</code> are equal to <code>6</code>. In the second case, we might have that <code>A</code> is <code>Bool</code> and <code>B</code> is <code>Tri</code>, and <code>Bool × Tri</code> is <em>not</em> the same as <code>Tri × Bool</code>. But there is an isomorphism between the two types. For instance, <code>⟨ true , aa ⟩</code>, which is a member of the former, corresponds to <code>⟨ aa , true ⟩</code>, which is a member of the latter.</p>
For associativity, the <code>to</code> function reassociates two uses of pairing, taking <code>⟨ ⟨ x , y ⟩ , z ⟩</code> to <code>⟨ x , ⟨ y , z ⟩ ⟩</code>, and the <code>from</code> function does the inverse. Again, the evidence of left and right inverse requires matching against a suitable pattern to enable simplification:
<pre class="Agda"><a id="×-assoc"></a><a id="7199" href="../Connectives/#7199" class="Function">×-assoc</a> <a id="7207" class="Symbol">:</a> <a id="7209" class="Symbol">∀</a> <a id="7211" class="Symbol">{</a><a id="7212" href="../Connectives/#7212" class="Bound">A</a> <a id="7214" href="../Connectives/#7214" class="Bound">B</a> <a id="7216" href="../Connectives/#7216" class="Bound">C</a> <a id="7218" class="Symbol">:</a> <a id="7220" class="PrimitiveType">Set</a><a id="7223" class="Symbol">}</a> <a id="7225" class="Symbol">→</a> <a id="7227" class="Symbol">(</a><a id="7228" href="../Connectives/#7212" class="Bound">A</a> <a id="7230" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="7232" href="../Connectives/#7214" class="Bound">B</a><a id="7233" class="Symbol">)</a> <a id="7235" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="7237" href="../Connectives/#7216" class="Bound">C</a> <a id="7239" href="../Isomorphism/#4333" class="Record Operator">≃</a> <a id="7241" href="../Connectives/#7212" class="Bound">A</a> <a id="7243" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="7245" class="Symbol">(</a><a id="7246" href="../Connectives/#7214" class="Bound">B</a> <a id="7248" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="7250" href="../Connectives/#7216" class="Bound">C</a><a id="7251" class="Symbol">)</a>
<a id="7253" href="../Connectives/#7199" class="Function">×-assoc</a> <a id="7261" class="Symbol">=</a>
  <a id="7265" class="Keyword">record</a>
    <a id="7276" class="Symbol">{</a> <a id="7278" href="../Isomorphism/#4373" class="Field">to</a>      <a id="7286" class="Symbol">=</a> <a id="7288" class="Symbol">λ{</a> <a id="7291" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7293" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7295" href="../Connectives/#7295" class="Bound">x</a> <a id="7297" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7299" href="../Connectives/#7299" class="Bound">y</a> <a id="7301" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7303" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7305" href="../Connectives/#7305" class="Bound">z</a> <a id="7307" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7309" class="Symbol">→</a> <a id="7311" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7313" href="../Connectives/#7295" class="Bound">x</a> <a id="7315" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7317" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7319" href="../Connectives/#7299" class="Bound">y</a> <a id="7321" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7323" href="../Connectives/#7305" class="Bound">z</a> <a id="7325" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7327" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7329" class="Symbol">}</a>
    <a id="7335" class="Symbol">;</a> <a id="7337" href="../Isomorphism/#4390" class="Field">from</a>    <a id="7345" class="Symbol">=</a> <a id="7347" class="Symbol">λ{</a> <a id="7350" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7352" href="../Connectives/#7352" class="Bound">x</a> <a id="7354" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7356" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7358" href="../Connectives/#7358" class="Bound">y</a> <a id="7360" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7362" href="../Connectives/#7362" class="Bound">z</a> <a id="7364" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7366" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7368" class="Symbol">→</a> <a id="7370" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7372" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7374" href="../Connectives/#7352" class="Bound">x</a> <a id="7376" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7378" href="../Connectives/#7358" class="Bound">y</a> <a id="7380" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7382" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7384" href="../Connectives/#7362" class="Bound">z</a> <a id="7386" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7388" class="Symbol">}</a>
    <a id="7394" class="Symbol">;</a> <a id="7396" href="../Isomorphism/#4407" class="Field">from∘to</a> <a id="7404" class="Symbol">=</a> <a id="7406" class="Symbol">λ{</a> <a id="7409" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7411" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7413" href="../Connectives/#7413" class="Bound">x</a> <a id="7415" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7417" href="../Connectives/#7417" class="Bound">y</a> <a id="7419" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7421" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7423" href="../Connectives/#7423" class="Bound">z</a> <a id="7425" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7427" class="Symbol">→</a> <a id="7429" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="7434" class="Symbol">}</a>
    <a id="7440" class="Symbol">;</a> <a id="7442" href="../Isomorphism/#4449" class="Field">to∘from</a> <a id="7450" class="Symbol">=</a> <a id="7452" class="Symbol">λ{</a> <a id="7455" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7457" href="../Connectives/#7457" class="Bound">x</a> <a id="7459" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7461" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7463" href="../Connectives/#7463" class="Bound">y</a> <a id="7465" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7467" href="../Connectives/#7467" class="Bound">z</a> <a id="7469" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7471" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7473" class="Symbol">→</a> <a id="7475" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="7480" class="Symbol">}</a>
    <a id="7486" class="Symbol">}</a>
</pre>
<p>Being <em>associative</em> is not the same as being <em>associative up to isomorphism</em>. Compare the two statements:</p>
<pre><code>(m * n) * p ≡ m * (n * p)
(A × B) × C ≃ A × (B × C)</code></pre>
<p>For example, the type <code>(ℕ × Bool) × Tri</code> is <em>not</em> the same as <code>ℕ × (Bool × Tri)</code>. But there is an isomorphism between the two types. For instance <code>⟨ ⟨ 1 , true ⟩ , aa ⟩</code>, which is a member of the former, corresponds to <code>⟨ 1 , ⟨ true , aa ⟩ ⟩</code>, which is a member of the latter.</p>
<h4 id="exercise-recommended">Exercise <code>⇔≃×</code> (recommended)</h4>
<p>Show that <code>A ⇔ B</code> as defined <a href="../Isomorphism/#iff">earlier</a> is isomorphic to <code>(A → B) × (B → A)</code>.</p>
<pre class="Agda"><a id="8076" class="Comment">-- Your code goes here</a>
</pre>
<h2 id="truth-is-unit">Truth is unit</h2>
Truth <code>⊤</code> always holds. We formalise this idea by declaring a suitable record type:
<pre class="Agda"><a id="8211" class="Keyword">data</a> <a id="⊤"></a><a id="8216" href="../Connectives/#8216" class="Datatype">⊤</a> <a id="8218" class="Symbol">:</a> <a id="8220" class="PrimitiveType">Set</a> <a id="8224" class="Keyword">where</a>

  <a id="⊤.tt"></a><a id="8233" href="../Connectives/#8233" class="InductiveConstructor">tt</a> <a id="8236" class="Symbol">:</a>
    <a id="8242" class="Comment">--</a>
    <a id="8249" href="../Connectives/#8216" class="Datatype">⊤</a>
</pre>
<p>Evidence that <code>⊤</code> holds is of the form <code>tt</code>.</p>
<p>There is an introduction rule, but no elimination rule. Given evidence that <code>⊤</code> holds, there is nothing more of interest we can conclude. Since truth always holds, knowing that it holds tells us nothing new.</p>
The nullary case of <code>η-×</code> is <code>η-⊤</code>, which asserts that any value of type <code>⊤</code> must be equal to <code>tt</code>:
<pre class="Agda"><a id="η-⊤"></a><a id="8615" href="../Connectives/#8615" class="Function">η-⊤</a> <a id="8619" class="Symbol">:</a> <a id="8621" class="Symbol">∀</a> <a id="8623" class="Symbol">(</a><a id="8624" href="../Connectives/#8624" class="Bound">w</a> <a id="8626" class="Symbol">:</a> <a id="8628" href="../Connectives/#8216" class="Datatype">⊤</a><a id="8629" class="Symbol">)</a> <a id="8631" class="Symbol">→</a> <a id="8633" href="../Connectives/#8233" class="InductiveConstructor">tt</a> <a id="8636" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="8638" href="../Connectives/#8624" class="Bound">w</a>
<a id="8640" href="../Connectives/#8615" class="Function">η-⊤</a> <a id="8644" href="../Connectives/#8233" class="InductiveConstructor">tt</a> <a id="8647" class="Symbol">=</a> <a id="8649" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>The pattern matching on the left-hand side is essential. Replacing <code>w</code> by <code>tt</code> allows both sides of the propositional equality to simplify to the same term.</p>
Alternatively, we can declare truth as an empty record:
<pre class="Agda"><a id="8876" class="Keyword">record</a> <a id="⊤′"></a><a id="8883" href="../Connectives/#8883" class="Record">⊤′</a> <a id="8886" class="Symbol">:</a> <a id="8888" class="PrimitiveType">Set</a> <a id="8892" class="Keyword">where</a>
  <a id="8900" class="Keyword">constructor</a> <a id="tt′"></a><a id="8912" href="../Connectives/#8912" class="InductiveConstructor">tt′</a>
</pre>
<p>The record construction <code>record {}</code> corresponds to the term <code>tt</code>. The constructor declaration allows us to write <code>tt′</code>.</p>
As with the product, the data type <code>⊤</code> and the record type <code>⊤′</code> behave similarly, but η-equality holds <em>by definition</em> for the record type. While proving <code>η-⊤′</code>, we do not have to pattern match on <code>w</code>—Agda <em>knows</em> it is equal to <code>tt′</code>:
<pre class="Agda"><a id="η-⊤′"></a><a id="9283" href="../Connectives/#9283" class="Function">η-⊤′</a> <a id="9288" class="Symbol">:</a> <a id="9290" class="Symbol">∀</a> <a id="9292" class="Symbol">(</a><a id="9293" href="../Connectives/#9293" class="Bound">w</a> <a id="9295" class="Symbol">:</a> <a id="9297" href="../Connectives/#8883" class="Record">⊤′</a><a id="9299" class="Symbol">)</a> <a id="9301" class="Symbol">→</a> <a id="9303" href="../Connectives/#8912" class="InductiveConstructor">tt′</a> <a id="9307" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="9309" href="../Connectives/#9293" class="Bound">w</a>
<a id="9311" href="../Connectives/#9283" class="Function">η-⊤′</a> <a id="9316" href="../Connectives/#9316" class="Bound">w</a> <a id="9318" class="Symbol">=</a> <a id="9320" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
Agda knows that <em>any</em> value of type <code>⊤′</code> must be <code>tt′</code>, so any time we need a value of type <code>⊤′</code>, we can tell Agda to figure it out:
<pre class="Agda"><a id="truth′"></a><a id="9466" href="../Connectives/#9466" class="Function">truth′</a> <a id="9473" class="Symbol">:</a> <a id="9475" href="../Connectives/#8883" class="Record">⊤′</a>
<a id="9478" href="../Connectives/#9466" class="Function">truth′</a> <a id="9485" class="Symbol">=</a> <a id="9487" class="Symbol">_</a>
</pre>
We refer to <code>⊤</code> as the <em>unit</em> type. And, indeed, type <code>⊤</code> has exactly one member, <code>tt</code>. For example, the following function enumerates all possible arguments of type <code>⊤</code>:
<pre class="Agda"><a id="⊤-count"></a><a id="9670" href="../Connectives/#9670" class="Function">⊤-count</a> <a id="9678" class="Symbol">:</a> <a id="9680" href="../Connectives/#8216" class="Datatype">⊤</a> <a id="9682" class="Symbol">→</a> <a id="9684" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="9686" href="../Connectives/#9670" class="Function">⊤-count</a> <a id="9694" href="../Connectives/#8233" class="InductiveConstructor">tt</a> <a id="9697" class="Symbol">=</a> <a id="9699" class="Number">1</a>
</pre>
For numbers, one is the identity of multiplication. Correspondingly, unit is the identity of product <em>up to isomorphism</em>. For left identity, the <code>to</code> function takes <code>⟨ tt , x ⟩</code> to <code>x</code>, and the <code>from</code> function does the inverse. The evidence of left inverse requires matching against a suitable pattern to enable simplification:
<pre class="Agda"><a id="⊤-identityˡ"></a><a id="10040" href="../Connectives/#10040" class="Function">⊤-identityˡ</a> <a id="10052" class="Symbol">:</a> <a id="10054" class="Symbol">∀</a> <a id="10056" class="Symbol">{</a><a id="10057" href="../Connectives/#10057" class="Bound">A</a> <a id="10059" class="Symbol">:</a> <a id="10061" class="PrimitiveType">Set</a><a id="10064" class="Symbol">}</a> <a id="10066" class="Symbol">→</a> <a id="10068" href="../Connectives/#8216" class="Datatype">⊤</a> <a id="10070" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="10072" href="../Connectives/#10057" class="Bound">A</a> <a id="10074" href="../Isomorphism/#4333" class="Record Operator">≃</a> <a id="10076" href="../Connectives/#10057" class="Bound">A</a>
<a id="10078" href="../Connectives/#10040" class="Function">⊤-identityˡ</a> <a id="10090" class="Symbol">=</a>
  <a id="10094" class="Keyword">record</a>
    <a id="10105" class="Symbol">{</a> <a id="10107" href="../Isomorphism/#4373" class="Field">to</a>      <a id="10115" class="Symbol">=</a> <a id="10117" class="Symbol">λ{</a> <a id="10120" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="10122" href="../Connectives/#8233" class="InductiveConstructor">tt</a> <a id="10125" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="10127" href="../Connectives/#10127" class="Bound">x</a> <a id="10129" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="10131" class="Symbol">→</a> <a id="10133" href="../Connectives/#10127" class="Bound">x</a> <a id="10135" class="Symbol">}</a>
    <a id="10141" class="Symbol">;</a> <a id="10143" href="../Isomorphism/#4390" class="Field">from</a>    <a id="10151" class="Symbol">=</a> <a id="10153" class="Symbol">λ{</a> <a id="10156" href="../Connectives/#10156" class="Bound">x</a> <a id="10158" class="Symbol">→</a> <a id="10160" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="10162" href="../Connectives/#8233" class="InductiveConstructor">tt</a> <a id="10165" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="10167" href="../Connectives/#10156" class="Bound">x</a> <a id="10169" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="10171" class="Symbol">}</a>
    <a id="10177" class="Symbol">;</a> <a id="10179" href="../Isomorphism/#4407" class="Field">from∘to</a> <a id="10187" class="Symbol">=</a> <a id="10189" class="Symbol">λ{</a> <a id="10192" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="10194" href="../Connectives/#8233" class="InductiveConstructor">tt</a> <a id="10197" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="10199" href="../Connectives/#10199" class="Bound">x</a> <a id="10201" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="10203" class="Symbol">→</a> <a id="10205" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="10210" class="Symbol">}</a>
    <a id="10216" class="Symbol">;</a> <a id="10218" href="../Isomorphism/#4449" class="Field">to∘from</a> <a id="10226" class="Symbol">=</a> <a id="10228" class="Symbol">λ{</a> <a id="10231" href="../Connectives/#10231" class="Bound">x</a> <a id="10233" class="Symbol">→</a> <a id="10235" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="10240" class="Symbol">}</a>
    <a id="10246" class="Symbol">}</a>
</pre>
<p>Having an <em>identity</em> is different from having an identity <em>up to isomorphism</em>. Compare the two statements:</p>
<pre><code>1 * m ≡ m
⊤ × A ≃ A</code></pre>
<p>In the first case, we might have that <code>m</code> is <code>2</code>, and both <code>1 * m</code> and <code>m</code> are equal to <code>2</code>. In the second case, we might have that <code>A</code> is <code>Bool</code>, and <code>⊤ × Bool</code> is <em>not</em> the same as <code>Bool</code>. But there is an isomorphism between the two types. For instance, <code>⟨ tt , true ⟩</code>, which is a member of the former, corresponds to <code>true</code>, which is a member of the latter.</p>
Right identity follows from commutativity of product and left identity:
<pre class="Agda"><a id="⊤-identityʳ"></a><a id="10832" href="../Connectives/#10832" class="Function">⊤-identityʳ</a> <a id="10844" class="Symbol">:</a> <a id="10846" class="Symbol">∀</a> <a id="10848" class="Symbol">{</a><a id="10849" href="../Connectives/#10849" class="Bound">A</a> <a id="10851" class="Symbol">:</a> <a id="10853" class="PrimitiveType">Set</a><a id="10856" class="Symbol">}</a> <a id="10858" class="Symbol">→</a> <a id="10860" class="Symbol">(</a><a id="10861" href="../Connectives/#10849" class="Bound">A</a> <a id="10863" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="10865" href="../Connectives/#8216" class="Datatype">⊤</a><a id="10866" class="Symbol">)</a> <a id="10868" href="../Isomorphism/#4333" class="Record Operator">≃</a> <a id="10870" href="../Connectives/#10849" class="Bound">A</a>
<a id="10872" href="../Connectives/#10832" class="Function">⊤-identityʳ</a> <a id="10884" class="Symbol">{</a><a id="10885" href="../Connectives/#10885" class="Bound">A</a><a id="10886" class="Symbol">}</a> <a id="10888" class="Symbol">=</a>
  <a id="10892" href="../Isomorphism/#8542" class="Function Operator">≃-begin</a>
    <a id="10904" class="Symbol">(</a><a id="10905" href="../Connectives/#10885" class="Bound">A</a> <a id="10907" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="10909" href="../Connectives/#8216" class="Datatype">⊤</a><a id="10910" class="Symbol">)</a>
  <a id="10914" href="../Isomorphism/#8626" class="Function Operator">≃⟨</a> <a id="10917" href="../Connectives/#6112" class="Function">×-comm</a> <a id="10924" href="../Isomorphism/#8626" class="Function Operator">⟩</a>
    <a id="10930" class="Symbol">(</a><a id="10931" href="../Connectives/#8216" class="Datatype">⊤</a> <a id="10933" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="10935" href="../Connectives/#10885" class="Bound">A</a><a id="10936" class="Symbol">)</a>
  <a id="10940" href="../Isomorphism/#8626" class="Function Operator">≃⟨</a> <a id="10943" href="../Connectives/#10040" class="Function">⊤-identityˡ</a> <a id="10955" href="../Isomorphism/#8626" class="Function Operator">⟩</a>
    <a id="10961" href="../Connectives/#10885" class="Bound">A</a>
  <a id="10965" href="../Isomorphism/#8745" class="Function Operator">≃-∎</a>
</pre>
<p>Here we have used a chain of isomorphisms, analogous to that used for equality.</p>
<h2 id="disjunction-is-sum">Disjunction is sum</h2>
Given two propositions <code>A</code> and <code>B</code>, the disjunction <code>A ⊎ B</code> holds if either <code>A</code> holds or <code>B</code> holds. We formalise this idea by declaring a suitable inductive type:
<pre class="Agda"><a id="11246" class="Keyword">data</a> <a id="_⊎_"></a><a id="11251" href="../Connectives/#11251" class="Datatype Operator">_⊎_</a> <a id="11255" class="Symbol">(</a><a id="11256" href="../Connectives/#11256" class="Bound">A</a> <a id="11258" href="../Connectives/#11258" class="Bound">B</a> <a id="11260" class="Symbol">:</a> <a id="11262" class="PrimitiveType">Set</a><a id="11265" class="Symbol">)</a> <a id="11267" class="Symbol">:</a> <a id="11269" class="PrimitiveType">Set</a> <a id="11273" class="Keyword">where</a>

  <a id="_⊎_.inj₁"></a><a id="11282" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="11287" class="Symbol">:</a>
      <a id="11295" href="../Connectives/#11256" class="Bound">A</a>
      <a id="11303" class="Comment">-----</a>
    <a id="11313" class="Symbol">→</a> <a id="11315" href="../Connectives/#11256" class="Bound">A</a> <a id="11317" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="11319" href="../Connectives/#11258" class="Bound">B</a>

  <a id="_⊎_.inj₂"></a><a id="11324" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="11329" class="Symbol">:</a>
      <a id="11337" href="../Connectives/#11258" class="Bound">B</a>
      <a id="11345" class="Comment">-----</a>
    <a id="11355" class="Symbol">→</a> <a id="11357" href="../Connectives/#11256" class="Bound">A</a> <a id="11359" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="11361" href="../Connectives/#11258" class="Bound">B</a>
</pre>
<p>Evidence that <code>A ⊎ B</code> holds is either of the form <code>inj₁ M</code>, where <code>M</code> provides evidence that <code>A</code> holds, or <code>inj₂ N</code>, where <code>N</code> provides evidence that <code>B</code> holds.</p>
Given evidence that <code>A → C</code> and <code>B → C</code> both hold, then given evidence that <code>A ⊎ B</code> holds we can conclude that <code>C</code> holds:
<pre class="Agda"><a id="case-⊎"></a><a id="11655" href="../Connectives/#11655" class="Function">case-⊎</a> <a id="11662" class="Symbol">:</a> <a id="11664" class="Symbol">∀</a> <a id="11666" class="Symbol">{</a><a id="11667" href="../Connectives/#11667" class="Bound">A</a> <a id="11669" href="../Connectives/#11669" class="Bound">B</a> <a id="11671" href="../Connectives/#11671" class="Bound">C</a> <a id="11673" class="Symbol">:</a> <a id="11675" class="PrimitiveType">Set</a><a id="11678" class="Symbol">}</a>
  <a id="11682" class="Symbol">→</a> <a id="11684" class="Symbol">(</a><a id="11685" href="../Connectives/#11667" class="Bound">A</a> <a id="11687" class="Symbol">→</a> <a id="11689" href="../Connectives/#11671" class="Bound">C</a><a id="11690" class="Symbol">)</a>
  <a id="11694" class="Symbol">→</a> <a id="11696" class="Symbol">(</a><a id="11697" href="../Connectives/#11669" class="Bound">B</a> <a id="11699" class="Symbol">→</a> <a id="11701" href="../Connectives/#11671" class="Bound">C</a><a id="11702" class="Symbol">)</a>
  <a id="11706" class="Symbol">→</a> <a id="11708" href="../Connectives/#11667" class="Bound">A</a> <a id="11710" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="11712" href="../Connectives/#11669" class="Bound">B</a>
    <a id="11718" class="Comment">-----------</a>
  <a id="11732" class="Symbol">→</a> <a id="11734" href="../Connectives/#11671" class="Bound">C</a>
<a id="11736" href="../Connectives/#11655" class="Function">case-⊎</a> <a id="11743" href="../Connectives/#11743" class="Bound">f</a> <a id="11745" href="../Connectives/#11745" class="Bound">g</a> <a id="11747" class="Symbol">(</a><a id="11748" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="11753" href="../Connectives/#11753" class="Bound">x</a><a id="11754" class="Symbol">)</a> <a id="11756" class="Symbol">=</a> <a id="11758" href="../Connectives/#11743" class="Bound">f</a> <a id="11760" href="../Connectives/#11753" class="Bound">x</a>
<a id="11762" href="../Connectives/#11655" class="Function">case-⊎</a> <a id="11769" href="../Connectives/#11769" class="Bound">f</a> <a id="11771" href="../Connectives/#11771" class="Bound">g</a> <a id="11773" class="Symbol">(</a><a id="11774" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="11779" href="../Connectives/#11779" class="Bound">y</a><a id="11780" class="Symbol">)</a> <a id="11782" class="Symbol">=</a> <a id="11784" href="../Connectives/#11771" class="Bound">g</a> <a id="11786" href="../Connectives/#11779" class="Bound">y</a>
</pre>
<p>Pattern matching against <code>inj₁</code> and <code>inj₂</code> is typical of how we exploit evidence that a disjunction holds.</p>
<p>When <code>inj₁</code> and <code>inj₂</code> appear on the right-hand side of an equation we refer to them as <em>constructors</em>, and when they appear on the left-hand side we refer to them as <em>destructors</em>. We also refer to <code>case-⊎</code> as a destructor, since it plays a similar role. Other terminology refers to <code>inj₁</code> and <code>inj₂</code> as <em>introducing</em> a disjunction, and to <code>case-⊎</code> as <em>eliminating</em> a disjunction; indeed the former are sometimes given the names <code>⊎-I₁</code> and <code>⊎-I₂</code> and the latter the name <code>⊎-E</code>.</p>
Applying the destructor to each of the constructors is the identity:
<pre class="Agda"><a id="η-⊎"></a><a id="12455" href="../Connectives/#12455" class="Function">η-⊎</a> <a id="12459" class="Symbol">:</a> <a id="12461" class="Symbol">∀</a> <a id="12463" class="Symbol">{</a><a id="12464" href="../Connectives/#12464" class="Bound">A</a> <a id="12466" href="../Connectives/#12466" class="Bound">B</a> <a id="12468" class="Symbol">:</a> <a id="12470" class="PrimitiveType">Set</a><a id="12473" class="Symbol">}</a> <a id="12475" class="Symbol">(</a><a id="12476" href="../Connectives/#12476" class="Bound">w</a> <a id="12478" class="Symbol">:</a> <a id="12480" href="../Connectives/#12464" class="Bound">A</a> <a id="12482" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="12484" href="../Connectives/#12466" class="Bound">B</a><a id="12485" class="Symbol">)</a> <a id="12487" class="Symbol">→</a> <a id="12489" href="../Connectives/#11655" class="Function">case-⊎</a> <a id="12496" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="12501" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="12506" href="../Connectives/#12476" class="Bound">w</a> <a id="12508" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="12510" href="../Connectives/#12476" class="Bound">w</a>
<a id="12512" href="../Connectives/#12455" class="Function">η-⊎</a> <a id="12516" class="Symbol">(</a><a id="12517" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="12522" href="../Connectives/#12522" class="Bound">x</a><a id="12523" class="Symbol">)</a> <a id="12525" class="Symbol">=</a> <a id="12527" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="12532" href="../Connectives/#12455" class="Function">η-⊎</a> <a id="12536" class="Symbol">(</a><a id="12537" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="12542" href="../Connectives/#12542" class="Bound">y</a><a id="12543" class="Symbol">)</a> <a id="12545" class="Symbol">=</a> <a id="12547" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
More generally, we can also throw in an arbitrary function from a disjunction:
<pre class="Agda"><a id="uniq-⊎"></a><a id="12639" href="../Connectives/#12639" class="Function">uniq-⊎</a> <a id="12646" class="Symbol">:</a> <a id="12648" class="Symbol">∀</a> <a id="12650" class="Symbol">{</a><a id="12651" href="../Connectives/#12651" class="Bound">A</a> <a id="12653" href="../Connectives/#12653" class="Bound">B</a> <a id="12655" href="../Connectives/#12655" class="Bound">C</a> <a id="12657" class="Symbol">:</a> <a id="12659" class="PrimitiveType">Set</a><a id="12662" class="Symbol">}</a> <a id="12664" class="Symbol">(</a><a id="12665" href="../Connectives/#12665" class="Bound">h</a> <a id="12667" class="Symbol">:</a> <a id="12669" href="../Connectives/#12651" class="Bound">A</a> <a id="12671" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="12673" href="../Connectives/#12653" class="Bound">B</a> <a id="12675" class="Symbol">→</a> <a id="12677" href="../Connectives/#12655" class="Bound">C</a><a id="12678" class="Symbol">)</a> <a id="12680" class="Symbol">(</a><a id="12681" href="../Connectives/#12681" class="Bound">w</a> <a id="12683" class="Symbol">:</a> <a id="12685" href="../Connectives/#12651" class="Bound">A</a> <a id="12687" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="12689" href="../Connectives/#12653" class="Bound">B</a><a id="12690" class="Symbol">)</a> <a id="12692" class="Symbol">→</a>
  <a id="12696" href="../Connectives/#11655" class="Function">case-⊎</a> <a id="12703" class="Symbol">(</a><a id="12704" href="../Connectives/#12665" class="Bound">h</a> <a id="12706" href="https://agda.github.io/agda-stdlib/v1.6/Function.Base.html#1031" class="Function Operator">∘</a> <a id="12708" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a><a id="12712" class="Symbol">)</a> <a id="12714" class="Symbol">(</a><a id="12715" href="../Connectives/#12665" class="Bound">h</a> <a id="12717" href="https://agda.github.io/agda-stdlib/v1.6/Function.Base.html#1031" class="Function Operator">∘</a> <a id="12719" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a><a id="12723" class="Symbol">)</a> <a id="12725" href="../Connectives/#12681" class="Bound">w</a> <a id="12727" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="12729" href="../Connectives/#12665" class="Bound">h</a> <a id="12731" href="../Connectives/#12681" class="Bound">w</a>
<a id="12733" href="../Connectives/#12639" class="Function">uniq-⊎</a> <a id="12740" href="../Connectives/#12740" class="Bound">h</a> <a id="12742" class="Symbol">(</a><a id="12743" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="12748" href="../Connectives/#12748" class="Bound">x</a><a id="12749" class="Symbol">)</a> <a id="12751" class="Symbol">=</a> <a id="12753" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="12758" href="../Connectives/#12639" class="Function">uniq-⊎</a> <a id="12765" href="../Connectives/#12765" class="Bound">h</a> <a id="12767" class="Symbol">(</a><a id="12768" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="12773" href="../Connectives/#12773" class="Bound">y</a><a id="12774" class="Symbol">)</a> <a id="12776" class="Symbol">=</a> <a id="12778" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>The pattern matching on the left-hand side is essential. Replacing <code>w</code> by <code>inj₁ x</code> allows both sides of the propositional equality to simplify to the same term, and similarly for <code>inj₂ y</code>.</p>
We set the precedence of disjunction so that it binds less tightly than any other declared operator:
<pre class="Agda"><a id="13083" class="Keyword">infixr</a> <a id="13090" class="Number">1</a> <a id="13092" href="../Connectives/#11251" class="Datatype Operator">_⊎_</a>
</pre>
<p>Thus, <code>A × C ⊎ B × C</code> parses as <code>(A × C) ⊎ (B × C)</code>.</p>
<p>Given two types <code>A</code> and <code>B</code>, we refer to <code>A ⊎ B</code> as the <em>sum</em> of <code>A</code> and <code>B</code>. In set theory, it is also sometimes called the <em>disjoint union</em>, and in computing it corresponds to a <em>variant record</em> type. Among other reasons for calling it the sum, note that if type <code>A</code> has <code>m</code> distinct members, and type <code>B</code> has <code>n</code> distinct members, then the type <code>A ⊎ B</code> has <code>m + n</code> distinct members. For instance, consider a type <code>Bool</code> with two members, and a type <code>Tri</code> with three members, as defined earlier. Then the type <code>Bool ⊎ Tri</code> has five members:</p>
<pre><code>inj₁ true     inj₂ aa
inj₁ false    inj₂ bb
              inj₂ cc</code></pre>
For example, the following function enumerates all possible arguments of type <code>Bool ⊎ Tri</code>:
<pre class="Agda"><a id="⊎-count"></a><a id="13874" href="../Connectives/#13874" class="Function">⊎-count</a> <a id="13882" class="Symbol">:</a> <a id="13884" href="../Connectives/#5018" class="Datatype">Bool</a> <a id="13889" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="13891" href="../Connectives/#5071" class="Datatype">Tri</a> <a id="13895" class="Symbol">→</a> <a id="13897" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="13899" href="../Connectives/#13874" class="Function">⊎-count</a> <a id="13907" class="Symbol">(</a><a id="13908" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="13913" href="../Connectives/#5037" class="InductiveConstructor">true</a><a id="13917" class="Symbol">)</a>   <a id="13921" class="Symbol">=</a>  <a id="13924" class="Number">1</a>
<a id="13926" href="../Connectives/#13874" class="Function">⊎-count</a> <a id="13934" class="Symbol">(</a><a id="13935" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="13940" href="../Connectives/#5052" class="InductiveConstructor">false</a><a id="13945" class="Symbol">)</a>  <a id="13948" class="Symbol">=</a>  <a id="13951" class="Number">2</a>
<a id="13953" href="../Connectives/#13874" class="Function">⊎-count</a> <a id="13961" class="Symbol">(</a><a id="13962" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="13967" href="../Connectives/#5089" class="InductiveConstructor">aa</a><a id="13969" class="Symbol">)</a>     <a id="13975" class="Symbol">=</a>  <a id="13978" class="Number">3</a>
<a id="13980" href="../Connectives/#13874" class="Function">⊎-count</a> <a id="13988" class="Symbol">(</a><a id="13989" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="13994" href="../Connectives/#5100" class="InductiveConstructor">bb</a><a id="13996" class="Symbol">)</a>     <a id="14002" class="Symbol">=</a>  <a id="14005" class="Number">4</a>
<a id="14007" href="../Connectives/#13874" class="Function">⊎-count</a> <a id="14015" class="Symbol">(</a><a id="14016" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="14021" href="../Connectives/#5111" class="InductiveConstructor">cc</a><a id="14023" class="Symbol">)</a>     <a id="14029" class="Symbol">=</a>  <a id="14032" class="Number">5</a>
</pre>
<p>Sum on types also shares a property with sum on numbers in that it is commutative and associative <em>up to isomorphism</em>.</p>
<h4 id="exercise--comm-recommended">Exercise <code>⊎-comm</code> (recommended)</h4>
<p>Show sum is commutative up to isomorphism.</p>
<pre class="Agda"><a id="14245" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise--assoc-practice">Exercise <code>⊎-assoc</code> (practice)</h4>
<p>Show sum is associative up to isomorphism.</p>
<pre class="Agda"><a id="14357" class="Comment">-- Your code goes here</a>
</pre>
<h2 id="false-is-empty">False is empty</h2>
False <code>⊥</code> never holds. We formalise this idea by declaring a suitable inductive type:
<pre class="Agda"><a id="14495" class="Keyword">data</a> <a id="⊥"></a><a id="14500" href="../Connectives/#14500" class="Datatype">⊥</a> <a id="14502" class="Symbol">:</a> <a id="14504" class="PrimitiveType">Set</a> <a id="14508" class="Keyword">where</a>
  <a id="14516" class="Comment">-- no clauses!</a>
</pre>
<p>There is no possible evidence that <code>⊥</code> holds.</p>
Dual to <code>⊤</code>, for <code>⊥</code> there is no introduction rule but an elimination rule. Since false never holds, knowing that it holds tells us we are in a paradoxical situation. Given evidence that <code>⊥</code> holds, we might conclude anything! This is a basic principle of logic, known in medieval times by the Latin phrase <em>ex falso</em>, and known to children through phrases such as “if pigs had wings, then I’d be the Queen of Sheba”. We formalise it as follows:
<pre class="Agda"><a id="⊥-elim"></a><a id="15034" href="../Connectives/#15034" class="Function">⊥-elim</a> <a id="15041" class="Symbol">:</a> <a id="15043" class="Symbol">∀</a> <a id="15045" class="Symbol">{</a><a id="15046" href="../Connectives/#15046" class="Bound">A</a> <a id="15048" class="Symbol">:</a> <a id="15050" class="PrimitiveType">Set</a><a id="15053" class="Symbol">}</a>
  <a id="15057" class="Symbol">→</a> <a id="15059" href="../Connectives/#14500" class="Datatype">⊥</a>
    <a id="15065" class="Comment">--</a>
  <a id="15070" class="Symbol">→</a> <a id="15072" href="../Connectives/#15046" class="Bound">A</a>
<a id="15074" href="../Connectives/#15034" class="Function">⊥-elim</a> <a id="15081" class="Symbol">()</a>
</pre>
<p>This is our first use of the <em>absurd pattern</em> <code>()</code>. Here since <code>⊥</code> is a type with no members, we indicate that it is <em>never</em> possible to match against a value of this type by using the pattern <code>()</code>.</p>
<p>The nullary case of <code>case-⊎</code> is <code>⊥-elim</code>. By analogy, we might have called it <code>case-⊥</code>, but chose to stick with the name in the standard library.</p>
The nullary case of <code>uniq-⊎</code> is <code>uniq-⊥</code>, which asserts that <code>⊥-elim</code> is equal to any arbitrary function from <code>⊥</code>:
<pre class="Agda"><a id="uniq-⊥"></a><a id="15555" href="../Connectives/#15555" class="Function">uniq-⊥</a> <a id="15562" class="Symbol">:</a> <a id="15564" class="Symbol">∀</a> <a id="15566" class="Symbol">{</a><a id="15567" href="../Connectives/#15567" class="Bound">C</a> <a id="15569" class="Symbol">:</a> <a id="15571" class="PrimitiveType">Set</a><a id="15574" class="Symbol">}</a> <a id="15576" class="Symbol">(</a><a id="15577" href="../Connectives/#15577" class="Bound">h</a> <a id="15579" class="Symbol">:</a> <a id="15581" href="../Connectives/#14500" class="Datatype">⊥</a> <a id="15583" class="Symbol">→</a> <a id="15585" href="../Connectives/#15567" class="Bound">C</a><a id="15586" class="Symbol">)</a> <a id="15588" class="Symbol">(</a><a id="15589" href="../Connectives/#15589" class="Bound">w</a> <a id="15591" class="Symbol">:</a> <a id="15593" href="../Connectives/#14500" class="Datatype">⊥</a><a id="15594" class="Symbol">)</a> <a id="15596" class="Symbol">→</a> <a id="15598" href="../Connectives/#15034" class="Function">⊥-elim</a> <a id="15605" href="../Connectives/#15589" class="Bound">w</a> <a id="15607" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="15609" href="../Connectives/#15577" class="Bound">h</a> <a id="15611" href="../Connectives/#15589" class="Bound">w</a>
<a id="15613" href="../Connectives/#15555" class="Function">uniq-⊥</a> <a id="15620" href="../Connectives/#15620" class="Bound">h</a> <a id="15622" class="Symbol">()</a>
</pre>
<p>Using the absurd pattern asserts there are no possible values for <code>w</code>, so the equation holds trivially.</p>
We refer to <code>⊥</code> as the <em>empty</em> type. And, indeed, type <code>⊥</code> has no members. For example, the following function enumerates all possible arguments of type <code>⊥</code>:
<pre class="Agda"><a id="⊥-count"></a><a id="15896" href="../Connectives/#15896" class="Function">⊥-count</a> <a id="15904" class="Symbol">:</a> <a id="15906" href="../Connectives/#14500" class="Datatype">⊥</a> <a id="15908" class="Symbol">→</a> <a id="15910" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="15912" href="../Connectives/#15896" class="Function">⊥-count</a> <a id="15920" class="Symbol">()</a>
</pre>
<p>Here again the absurd pattern <code>()</code> indicates that no value can match type <code>⊥</code>.</p>
<p>For numbers, zero is the identity of addition. Correspondingly, empty is the identity of sums <em>up to isomorphism</em>.</p>
<h4 id="exercise--identityˡ-recommended">Exercise <code>⊥-identityˡ</code> (recommended)</h4>
<p>Show empty is the left identity of sums up to isomorphism.</p>
<pre class="Agda"><a id="16230" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise--identityʳ-practice">Exercise <code>⊥-identityʳ</code> (practice)</h4>
<p>Show empty is the right identity of sums up to isomorphism.</p>
<pre class="Agda"><a id="16363" class="Comment">-- Your code goes here</a>
</pre>
<h2 name="implication" id="implication-is-function">Implication is function</h2>
<p>Given two propositions <code>A</code> and <code>B</code>, the implication <code>A → B</code> holds if whenever <code>A</code> holds then <code>B</code> must also hold. We formalise implication using the function type, which has appeared throughout this book.</p>
<p>Evidence that <code>A → B</code> holds is of the form</p>
<pre><code>λ (x : A) → N</code></pre>
<p>where <code>N</code> is a term of type <code>B</code> containing as a free variable <code>x</code> of type <code>A</code>. Given a term <code>L</code> providing evidence that <code>A → B</code> holds, and a term <code>M</code> providing evidence that <code>A</code> holds, the term <code>L M</code> provides evidence that <code>B</code> holds. In other words, evidence that <code>A → B</code> holds is a function that converts evidence that <code>A</code> holds into evidence that <code>B</code> holds.</p>
Put another way, if we know that <code>A → B</code> and <code>A</code> both hold, then we may conclude that <code>B</code> holds:
<pre class="Agda"><a id="→-elim"></a><a id="17170" href="../Connectives/#17170" class="Function">→-elim</a> <a id="17177" class="Symbol">:</a> <a id="17179" class="Symbol">∀</a> <a id="17181" class="Symbol">{</a><a id="17182" href="../Connectives/#17182" class="Bound">A</a> <a id="17184" href="../Connectives/#17184" class="Bound">B</a> <a id="17186" class="Symbol">:</a> <a id="17188" class="PrimitiveType">Set</a><a id="17191" class="Symbol">}</a>
  <a id="17195" class="Symbol">→</a> <a id="17197" class="Symbol">(</a><a id="17198" href="../Connectives/#17182" class="Bound">A</a> <a id="17200" class="Symbol">→</a> <a id="17202" href="../Connectives/#17184" class="Bound">B</a><a id="17203" class="Symbol">)</a>
  <a id="17207" class="Symbol">→</a> <a id="17209" href="../Connectives/#17182" class="Bound">A</a>
    <a id="17215" class="Comment">-------</a>
  <a id="17225" class="Symbol">→</a> <a id="17227" href="../Connectives/#17184" class="Bound">B</a>
<a id="17229" href="../Connectives/#17170" class="Function">→-elim</a> <a id="17236" href="../Connectives/#17236" class="Bound">L</a> <a id="17238" href="../Connectives/#17238" class="Bound">M</a> <a id="17240" class="Symbol">=</a> <a id="17242" href="../Connectives/#17236" class="Bound">L</a> <a id="17244" href="../Connectives/#17238" class="Bound">M</a>
</pre>
<p>In medieval times, this rule was known by the name <em>modus ponens</em>. It corresponds to function application.</p>
<p>Defining a function, with a named definition or a lambda abstraction, is referred to as <em>introducing</em> a function, while applying a function is referred to as <em>eliminating</em> the function.</p>
Elimination followed by introduction is the identity:
<pre class="Agda"><a id="η-→"></a><a id="17603" href="../Connectives/#17603" class="Function">η-→</a> <a id="17607" class="Symbol">:</a> <a id="17609" class="Symbol">∀</a> <a id="17611" class="Symbol">{</a><a id="17612" href="../Connectives/#17612" class="Bound">A</a> <a id="17614" href="../Connectives/#17614" class="Bound">B</a> <a id="17616" class="Symbol">:</a> <a id="17618" class="PrimitiveType">Set</a><a id="17621" class="Symbol">}</a> <a id="17623" class="Symbol">(</a><a id="17624" href="../Connectives/#17624" class="Bound">f</a> <a id="17626" class="Symbol">:</a> <a id="17628" href="../Connectives/#17612" class="Bound">A</a> <a id="17630" class="Symbol">→</a> <a id="17632" href="../Connectives/#17614" class="Bound">B</a><a id="17633" class="Symbol">)</a> <a id="17635" class="Symbol">→</a> <a id="17637" class="Symbol">(λ</a> <a id="17640" class="Symbol">(</a><a id="17641" href="../Connectives/#17641" class="Bound">x</a> <a id="17643" class="Symbol">:</a> <a id="17645" href="../Connectives/#17612" class="Bound">A</a><a id="17646" class="Symbol">)</a> <a id="17648" class="Symbol">→</a> <a id="17650" href="../Connectives/#17624" class="Bound">f</a> <a id="17652" href="../Connectives/#17641" class="Bound">x</a><a id="17653" class="Symbol">)</a> <a id="17655" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="17657" href="../Connectives/#17624" class="Bound">f</a>
<a id="17659" href="../Connectives/#17603" class="Function">η-→</a> <a id="17663" href="../Connectives/#17663" class="Bound">f</a> <a id="17665" class="Symbol">=</a> <a id="17667" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>Implication binds less tightly than any other operator. Thus, <code>A ⊎ B → B ⊎ A</code> parses as <code>(A ⊎ B) → (B ⊎ A)</code>.</p>
<p>Given two types <code>A</code> and <code>B</code>, we refer to <code>A → B</code> as the <em>function</em> space from <code>A</code> to <code>B</code>. It is also sometimes called the <em>exponential</em>, with <code>B</code> raised to the <code>A</code> power. Among other reasons for calling it the exponential, note that if type <code>A</code> has <code>m</code> distinct members, and type <code>B</code> has <code>n</code> distinct members, then the type <code>A → B</code> has <code>nᵐ</code> distinct members. For instance, consider a type <code>Bool</code> with two members and a type <code>Tri</code> with three members, as defined earlier. Then the type <code>Bool → Tri</code> has nine (that is, three squared) members:</p>
<pre><code>λ{true → aa; false → aa}  λ{true → aa; false → bb}  λ{true → aa; false → cc}
λ{true → bb; false → aa}  λ{true → bb; false → bb}  λ{true → bb; false → cc}
λ{true → cc; false → aa}  λ{true → cc; false → bb}  λ{true → cc; false → cc}</code></pre>
For example, the following function enumerates all possible arguments of the type <code>Bool → Tri</code>:
<pre class="Agda"><a id="→-count"></a><a id="18675" href="../Connectives/#18675" class="Function">→-count</a> <a id="18683" class="Symbol">:</a> <a id="18685" class="Symbol">(</a><a id="18686" href="../Connectives/#5018" class="Datatype">Bool</a> <a id="18691" class="Symbol">→</a> <a id="18693" href="../Connectives/#5071" class="Datatype">Tri</a><a id="18696" class="Symbol">)</a> <a id="18698" class="Symbol">→</a> <a id="18700" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="18702" href="../Connectives/#18675" class="Function">→-count</a> <a id="18710" href="../Connectives/#18710" class="Bound">f</a> <a id="18712" class="Keyword">with</a> <a id="18717" href="../Connectives/#18710" class="Bound">f</a> <a id="18719" href="../Connectives/#5037" class="InductiveConstructor">true</a> <a id="18724" class="Symbol">|</a> <a id="18726" href="../Connectives/#18710" class="Bound">f</a> <a id="18728" href="../Connectives/#5052" class="InductiveConstructor">false</a>
<a id="18734" class="Symbol">...</a>          <a id="18747" class="Symbol">|</a> <a id="18749" href="../Connectives/#5089" class="InductiveConstructor">aa</a>     <a id="18756" class="Symbol">|</a> <a id="18758" href="../Connectives/#5089" class="InductiveConstructor">aa</a>      <a id="18766" class="Symbol">=</a>   <a id="18770" class="Number">1</a>
<a id="18772" class="Symbol">...</a>          <a id="18785" class="Symbol">|</a> <a id="18787" href="../Connectives/#5089" class="InductiveConstructor">aa</a>     <a id="18794" class="Symbol">|</a> <a id="18796" href="../Connectives/#5100" class="InductiveConstructor">bb</a>      <a id="18804" class="Symbol">=</a>   <a id="18808" class="Number">2</a>
<a id="18810" class="Symbol">...</a>          <a id="18823" class="Symbol">|</a> <a id="18825" href="../Connectives/#5089" class="InductiveConstructor">aa</a>     <a id="18832" class="Symbol">|</a> <a id="18834" href="../Connectives/#5111" class="InductiveConstructor">cc</a>      <a id="18842" class="Symbol">=</a>   <a id="18846" class="Number">3</a>
<a id="18848" class="Symbol">...</a>          <a id="18861" class="Symbol">|</a> <a id="18863" href="../Connectives/#5100" class="InductiveConstructor">bb</a>     <a id="18870" class="Symbol">|</a> <a id="18872" href="../Connectives/#5089" class="InductiveConstructor">aa</a>      <a id="18880" class="Symbol">=</a>   <a id="18884" class="Number">4</a>
<a id="18886" class="Symbol">...</a>          <a id="18899" class="Symbol">|</a> <a id="18901" href="../Connectives/#5100" class="InductiveConstructor">bb</a>     <a id="18908" class="Symbol">|</a> <a id="18910" href="../Connectives/#5100" class="InductiveConstructor">bb</a>      <a id="18918" class="Symbol">=</a>   <a id="18922" class="Number">5</a>
<a id="18924" class="Symbol">...</a>          <a id="18937" class="Symbol">|</a> <a id="18939" href="../Connectives/#5100" class="InductiveConstructor">bb</a>     <a id="18946" class="Symbol">|</a> <a id="18948" href="../Connectives/#5111" class="InductiveConstructor">cc</a>      <a id="18956" class="Symbol">=</a>   <a id="18960" class="Number">6</a>
<a id="18962" class="Symbol">...</a>          <a id="18975" class="Symbol">|</a> <a id="18977" href="../Connectives/#5111" class="InductiveConstructor">cc</a>     <a id="18984" class="Symbol">|</a> <a id="18986" href="../Connectives/#5089" class="InductiveConstructor">aa</a>      <a id="18994" class="Symbol">=</a>   <a id="18998" class="Number">7</a>
<a id="19000" class="Symbol">...</a>          <a id="19013" class="Symbol">|</a> <a id="19015" href="../Connectives/#5111" class="InductiveConstructor">cc</a>     <a id="19022" class="Symbol">|</a> <a id="19024" href="../Connectives/#5100" class="InductiveConstructor">bb</a>      <a id="19032" class="Symbol">=</a>   <a id="19036" class="Number">8</a>
<a id="19038" class="Symbol">...</a>          <a id="19051" class="Symbol">|</a> <a id="19053" href="../Connectives/#5111" class="InductiveConstructor">cc</a>     <a id="19060" class="Symbol">|</a> <a id="19062" href="../Connectives/#5111" class="InductiveConstructor">cc</a>      <a id="19070" class="Symbol">=</a>   <a id="19074" class="Number">9</a>
</pre>
<p>Exponential on types also share a property with exponential on numbers in that many of the standard identities for numbers carry over to the types.</p>
<p>Corresponding to the law</p>
<pre><code>(p ^ n) ^ m  ≡  p ^ (n * m)</code></pre>
<p>we have the isomorphism</p>
<pre><code>A → (B → C)  ≃  (A × B) → C</code></pre>
Both types can be viewed as functions that given evidence that <code>A</code> holds and evidence that <code>B</code> holds can return evidence that <code>C</code> holds. This isomorphism sometimes goes by the name <em>currying</em>. The proof of the right inverse requires extensionality:
<pre class="Agda"><a id="currying"></a><a id="19600" href="../Connectives/#19600" class="Function">currying</a> <a id="19609" class="Symbol">:</a> <a id="19611" class="Symbol">∀</a> <a id="19613" class="Symbol">{</a><a id="19614" href="../Connectives/#19614" class="Bound">A</a> <a id="19616" href="../Connectives/#19616" class="Bound">B</a> <a id="19618" href="../Connectives/#19618" class="Bound">C</a> <a id="19620" class="Symbol">:</a> <a id="19622" class="PrimitiveType">Set</a><a id="19625" class="Symbol">}</a> <a id="19627" class="Symbol">→</a> <a id="19629" class="Symbol">(</a><a id="19630" href="../Connectives/#19614" class="Bound">A</a> <a id="19632" class="Symbol">→</a> <a id="19634" href="../Connectives/#19616" class="Bound">B</a> <a id="19636" class="Symbol">→</a> <a id="19638" href="../Connectives/#19618" class="Bound">C</a><a id="19639" class="Symbol">)</a> <a id="19641" href="../Isomorphism/#4333" class="Record Operator">≃</a> <a id="19643" class="Symbol">(</a><a id="19644" href="../Connectives/#19614" class="Bound">A</a> <a id="19646" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="19648" href="../Connectives/#19616" class="Bound">B</a> <a id="19650" class="Symbol">→</a> <a id="19652" href="../Connectives/#19618" class="Bound">C</a><a id="19653" class="Symbol">)</a>
<a id="19655" href="../Connectives/#19600" class="Function">currying</a> <a id="19664" class="Symbol">=</a>
  <a id="19668" class="Keyword">record</a>
    <a id="19679" class="Symbol">{</a> <a id="19681" href="../Isomorphism/#4373" class="Field">to</a>      <a id="19689" class="Symbol">=</a>  <a id="19692" class="Symbol">λ{</a> <a id="19695" href="../Connectives/#19695" class="Bound">f</a> <a id="19697" class="Symbol">→</a> <a id="19699" class="Symbol">λ{</a> <a id="19702" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="19704" href="../Connectives/#19704" class="Bound">x</a> <a id="19706" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="19708" href="../Connectives/#19708" class="Bound">y</a> <a id="19710" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="19712" class="Symbol">→</a> <a id="19714" href="../Connectives/#19695" class="Bound">f</a> <a id="19716" href="../Connectives/#19704" class="Bound">x</a> <a id="19718" href="../Connectives/#19708" class="Bound">y</a> <a id="19720" class="Symbol">}}</a>
    <a id="19727" class="Symbol">;</a> <a id="19729" href="../Isomorphism/#4390" class="Field">from</a>    <a id="19737" class="Symbol">=</a>  <a id="19740" class="Symbol">λ{</a> <a id="19743" href="../Connectives/#19743" class="Bound">g</a> <a id="19745" class="Symbol">→</a> <a id="19747" class="Symbol">λ{</a> <a id="19750" href="../Connectives/#19750" class="Bound">x</a> <a id="19752" class="Symbol">→</a> <a id="19754" class="Symbol">λ{</a> <a id="19757" href="../Connectives/#19757" class="Bound">y</a> <a id="19759" class="Symbol">→</a> <a id="19761" href="../Connectives/#19743" class="Bound">g</a> <a id="19763" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="19765" href="../Connectives/#19750" class="Bound">x</a> <a id="19767" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="19769" href="../Connectives/#19757" class="Bound">y</a> <a id="19771" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="19773" class="Symbol">}}}</a>
    <a id="19781" class="Symbol">;</a> <a id="19783" href="../Isomorphism/#4407" class="Field">from∘to</a> <a id="19791" class="Symbol">=</a>  <a id="19794" class="Symbol">λ{</a> <a id="19797" href="../Connectives/#19797" class="Bound">f</a> <a id="19799" class="Symbol">→</a> <a id="19801" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="19806" class="Symbol">}</a>
    <a id="19812" class="Symbol">;</a> <a id="19814" href="../Isomorphism/#4449" class="Field">to∘from</a> <a id="19822" class="Symbol">=</a>  <a id="19825" class="Symbol">λ{</a> <a id="19828" href="../Connectives/#19828" class="Bound">g</a> <a id="19830" class="Symbol">→</a> <a id="19832" href="../Isomorphism/#2670" class="Postulate">extensionality</a> <a id="19847" class="Symbol">λ{</a> <a id="19850" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="19852" href="../Connectives/#19852" class="Bound">x</a> <a id="19854" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="19856" href="../Connectives/#19856" class="Bound">y</a> <a id="19858" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="19860" class="Symbol">→</a> <a id="19862" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="19867" class="Symbol">}}</a>
    <a id="19874" class="Symbol">}</a>
</pre>
<p>Currying tells us that instead of a function that takes a pair of arguments, we can have a function that takes the first argument and returns a function that expects the second argument. Thus, for instance, our way of writing addition</p>
<pre><code>_+_ : ℕ → ℕ → ℕ</code></pre>
<p>is isomorphic to a function that accepts a pair of arguments:</p>
<pre><code>_+′_ : (ℕ × ℕ) → ℕ</code></pre>
<p>Agda is optimised for currying, so <code>2 + 3</code> abbreviates <code>_+_ 2 3</code>. In a language optimised for pairing, we would instead take <code>2 +′ 3</code> as an abbreviation for <code>_+′_ ⟨ 2 , 3 ⟩</code>.</p>
<p>Corresponding to the law</p>
<pre><code>p ^ (n + m) = (p ^ n) * (p ^ m)</code></pre>
<p>we have the isomorphism:</p>
<pre><code>(A ⊎ B) → C  ≃  (A → C) × (B → C)</code></pre>
That is, the assertion that if either <code>A</code> holds or <code>B</code> holds then <code>C</code> holds is the same as the assertion that if <code>A</code> holds then <code>C</code> holds and if <code>B</code> holds then <code>C</code> holds. The proof of the left inverse requires extensionality:
<pre class="Agda"><a id="→-distrib-⊎"></a><a id="20761" href="../Connectives/#20761" class="Function">→-distrib-⊎</a> <a id="20773" class="Symbol">:</a> <a id="20775" class="Symbol">∀</a> <a id="20777" class="Symbol">{</a><a id="20778" href="../Connectives/#20778" class="Bound">A</a> <a id="20780" href="../Connectives/#20780" class="Bound">B</a> <a id="20782" href="../Connectives/#20782" class="Bound">C</a> <a id="20784" class="Symbol">:</a> <a id="20786" class="PrimitiveType">Set</a><a id="20789" class="Symbol">}</a> <a id="20791" class="Symbol">→</a> <a id="20793" class="Symbol">(</a><a id="20794" href="../Connectives/#20778" class="Bound">A</a> <a id="20796" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="20798" href="../Connectives/#20780" class="Bound">B</a> <a id="20800" class="Symbol">→</a> <a id="20802" href="../Connectives/#20782" class="Bound">C</a><a id="20803" class="Symbol">)</a> <a id="20805" href="../Isomorphism/#4333" class="Record Operator">≃</a> <a id="20807" class="Symbol">((</a><a id="20809" href="../Connectives/#20778" class="Bound">A</a> <a id="20811" class="Symbol">→</a> <a id="20813" href="../Connectives/#20782" class="Bound">C</a><a id="20814" class="Symbol">)</a> <a id="20816" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="20818" class="Symbol">(</a><a id="20819" href="../Connectives/#20780" class="Bound">B</a> <a id="20821" class="Symbol">→</a> <a id="20823" href="../Connectives/#20782" class="Bound">C</a><a id="20824" class="Symbol">))</a>
<a id="20827" href="../Connectives/#20761" class="Function">→-distrib-⊎</a> <a id="20839" class="Symbol">=</a>
  <a id="20843" class="Keyword">record</a>
    <a id="20854" class="Symbol">{</a> <a id="20856" href="../Isomorphism/#4373" class="Field">to</a>      <a id="20864" class="Symbol">=</a> <a id="20866" class="Symbol">λ{</a> <a id="20869" href="../Connectives/#20869" class="Bound">f</a> <a id="20871" class="Symbol">→</a> <a id="20873" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="20875" href="../Connectives/#20869" class="Bound">f</a> <a id="20877" href="https://agda.github.io/agda-stdlib/v1.6/Function.Base.html#1031" class="Function Operator">∘</a> <a id="20879" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="20884" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="20886" href="../Connectives/#20869" class="Bound">f</a> <a id="20888" href="https://agda.github.io/agda-stdlib/v1.6/Function.Base.html#1031" class="Function Operator">∘</a> <a id="20890" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="20895" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="20897" class="Symbol">}</a>
    <a id="20903" class="Symbol">;</a> <a id="20905" href="../Isomorphism/#4390" class="Field">from</a>    <a id="20913" class="Symbol">=</a> <a id="20915" class="Symbol">λ{</a> <a id="20918" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="20920" href="../Connectives/#20920" class="Bound">g</a> <a id="20922" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="20924" href="../Connectives/#20924" class="Bound">h</a> <a id="20926" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="20928" class="Symbol">→</a> <a id="20930" class="Symbol">λ{</a> <a id="20933" class="Symbol">(</a><a id="20934" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="20939" href="../Connectives/#20939" class="Bound">x</a><a id="20940" class="Symbol">)</a> <a id="20942" class="Symbol">→</a> <a id="20944" href="../Connectives/#20920" class="Bound">g</a> <a id="20946" href="../Connectives/#20939" class="Bound">x</a> <a id="20948" class="Symbol">;</a> <a id="20950" class="Symbol">(</a><a id="20951" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="20956" href="../Connectives/#20956" class="Bound">y</a><a id="20957" class="Symbol">)</a> <a id="20959" class="Symbol">→</a> <a id="20961" href="../Connectives/#20924" class="Bound">h</a> <a id="20963" href="../Connectives/#20956" class="Bound">y</a> <a id="20965" class="Symbol">}</a> <a id="20967" class="Symbol">}</a>
    <a id="20973" class="Symbol">;</a> <a id="20975" href="../Isomorphism/#4407" class="Field">from∘to</a> <a id="20983" class="Symbol">=</a> <a id="20985" class="Symbol">λ{</a> <a id="20988" href="../Connectives/#20988" class="Bound">f</a> <a id="20990" class="Symbol">→</a> <a id="20992" href="../Isomorphism/#2670" class="Postulate">extensionality</a> <a id="21007" class="Symbol">λ{</a> <a id="21010" class="Symbol">(</a><a id="21011" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="21016" href="../Connectives/#21016" class="Bound">x</a><a id="21017" class="Symbol">)</a> <a id="21019" class="Symbol">→</a> <a id="21021" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="21026" class="Symbol">;</a> <a id="21028" class="Symbol">(</a><a id="21029" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="21034" href="../Connectives/#21034" class="Bound">y</a><a id="21035" class="Symbol">)</a> <a id="21037" class="Symbol">→</a> <a id="21039" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="21044" class="Symbol">}</a> <a id="21046" class="Symbol">}</a>
    <a id="21052" class="Symbol">;</a> <a id="21054" href="../Isomorphism/#4449" class="Field">to∘from</a> <a id="21062" class="Symbol">=</a> <a id="21064" class="Symbol">λ{</a> <a id="21067" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="21069" href="../Connectives/#21069" class="Bound">g</a> <a id="21071" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="21073" href="../Connectives/#21073" class="Bound">h</a> <a id="21075" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="21077" class="Symbol">→</a> <a id="21079" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="21084" class="Symbol">}</a>
    <a id="21090" class="Symbol">}</a>
</pre>
<p>Corresponding to the law</p>
<pre><code>(p * n) ^ m = (p ^ m) * (n ^ m)</code></pre>
<p>we have the isomorphism:</p>
<pre><code>A → B × C  ≃  (A → B) × (A → C)</code></pre>
That is, the assertion that if <code>A</code> holds then <code>B</code> holds and <code>C</code> holds is the same as the assertion that if <code>A</code> holds then <code>B</code> holds and if <code>A</code> holds then <code>C</code> holds. The proof of left inverse requires both extensionality and the rule <code>η-×</code> for products:
<pre class="Agda"><a id="→-distrib-×"></a><a id="21481" href="../Connectives/#21481" class="Function">→-distrib-×</a> <a id="21493" class="Symbol">:</a> <a id="21495" class="Symbol">∀</a> <a id="21497" class="Symbol">{</a><a id="21498" href="../Connectives/#21498" class="Bound">A</a> <a id="21500" href="../Connectives/#21500" class="Bound">B</a> <a id="21502" href="../Connectives/#21502" class="Bound">C</a> <a id="21504" class="Symbol">:</a> <a id="21506" class="PrimitiveType">Set</a><a id="21509" class="Symbol">}</a> <a id="21511" class="Symbol">→</a> <a id="21513" class="Symbol">(</a><a id="21514" href="../Connectives/#21498" class="Bound">A</a> <a id="21516" class="Symbol">→</a> <a id="21518" href="../Connectives/#21500" class="Bound">B</a> <a id="21520" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="21522" href="../Connectives/#21502" class="Bound">C</a><a id="21523" class="Symbol">)</a> <a id="21525" href="../Isomorphism/#4333" class="Record Operator">≃</a> <a id="21527" class="Symbol">(</a><a id="21528" href="../Connectives/#21498" class="Bound">A</a> <a id="21530" class="Symbol">→</a> <a id="21532" href="../Connectives/#21500" class="Bound">B</a><a id="21533" class="Symbol">)</a> <a id="21535" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="21537" class="Symbol">(</a><a id="21538" href="../Connectives/#21498" class="Bound">A</a> <a id="21540" class="Symbol">→</a> <a id="21542" href="../Connectives/#21502" class="Bound">C</a><a id="21543" class="Symbol">)</a>
<a id="21545" href="../Connectives/#21481" class="Function">→-distrib-×</a> <a id="21557" class="Symbol">=</a>
  <a id="21561" class="Keyword">record</a>
    <a id="21572" class="Symbol">{</a> <a id="21574" href="../Isomorphism/#4373" class="Field">to</a>      <a id="21582" class="Symbol">=</a> <a id="21584" class="Symbol">λ{</a> <a id="21587" href="../Connectives/#21587" class="Bound">f</a> <a id="21589" class="Symbol">→</a> <a id="21591" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="21593" href="../Connectives/#1607" class="Function">proj₁</a> <a id="21599" href="https://agda.github.io/agda-stdlib/v1.6/Function.Base.html#1031" class="Function Operator">∘</a> <a id="21601" href="../Connectives/#21587" class="Bound">f</a> <a id="21603" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="21605" href="../Connectives/#1676" class="Function">proj₂</a> <a id="21611" href="https://agda.github.io/agda-stdlib/v1.6/Function.Base.html#1031" class="Function Operator">∘</a> <a id="21613" href="../Connectives/#21587" class="Bound">f</a> <a id="21615" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="21617" class="Symbol">}</a>
    <a id="21623" class="Symbol">;</a> <a id="21625" href="../Isomorphism/#4390" class="Field">from</a>    <a id="21633" class="Symbol">=</a> <a id="21635" class="Symbol">λ{</a> <a id="21638" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="21640" href="../Connectives/#21640" class="Bound">g</a> <a id="21642" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="21644" href="../Connectives/#21644" class="Bound">h</a> <a id="21646" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="21648" class="Symbol">→</a> <a id="21650" class="Symbol">λ</a> <a id="21652" href="../Connectives/#21652" class="Bound">x</a> <a id="21654" class="Symbol">→</a> <a id="21656" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="21658" href="../Connectives/#21640" class="Bound">g</a> <a id="21660" href="../Connectives/#21652" class="Bound">x</a> <a id="21662" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="21664" href="../Connectives/#21644" class="Bound">h</a> <a id="21666" href="../Connectives/#21652" class="Bound">x</a> <a id="21668" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="21670" class="Symbol">}</a>
    <a id="21676" class="Symbol">;</a> <a id="21678" href="../Isomorphism/#4407" class="Field">from∘to</a> <a id="21686" class="Symbol">=</a> <a id="21688" class="Symbol">λ{</a> <a id="21691" href="../Connectives/#21691" class="Bound">f</a> <a id="21693" class="Symbol">→</a> <a id="21695" href="../Isomorphism/#2670" class="Postulate">extensionality</a> <a id="21710" class="Symbol">λ{</a> <a id="21713" href="../Connectives/#21713" class="Bound">x</a> <a id="21715" class="Symbol">→</a> <a id="21717" href="../Connectives/#3107" class="Function">η-×</a> <a id="21721" class="Symbol">(</a><a id="21722" href="../Connectives/#21691" class="Bound">f</a> <a id="21724" href="../Connectives/#21713" class="Bound">x</a><a id="21725" class="Symbol">)</a> <a id="21727" class="Symbol">}</a> <a id="21729" class="Symbol">}</a>
    <a id="21735" class="Symbol">;</a> <a id="21737" href="../Isomorphism/#4449" class="Field">to∘from</a> <a id="21745" class="Symbol">=</a> <a id="21747" class="Symbol">λ{</a> <a id="21750" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="21752" href="../Connectives/#21752" class="Bound">g</a> <a id="21754" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="21756" href="../Connectives/#21756" class="Bound">h</a> <a id="21758" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="21760" class="Symbol">→</a> <a id="21762" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="21767" class="Symbol">}</a>
    <a id="21773" class="Symbol">}</a>
</pre>
<h2 id="distribution">Distribution</h2>
Products distribute over sum, up to isomorphism. The code to validate this fact is similar in structure to our previous results:
<pre class="Agda"><a id="×-distrib-⊎"></a><a id="21932" href="../Connectives/#21932" class="Function">×-distrib-⊎</a> <a id="21944" class="Symbol">:</a> <a id="21946" class="Symbol">∀</a> <a id="21948" class="Symbol">{</a><a id="21949" href="../Connectives/#21949" class="Bound">A</a> <a id="21951" href="../Connectives/#21951" class="Bound">B</a> <a id="21953" href="../Connectives/#21953" class="Bound">C</a> <a id="21955" class="Symbol">:</a> <a id="21957" class="PrimitiveType">Set</a><a id="21960" class="Symbol">}</a> <a id="21962" class="Symbol">→</a> <a id="21964" class="Symbol">(</a><a id="21965" href="../Connectives/#21949" class="Bound">A</a> <a id="21967" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="21969" href="../Connectives/#21951" class="Bound">B</a><a id="21970" class="Symbol">)</a> <a id="21972" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="21974" href="../Connectives/#21953" class="Bound">C</a> <a id="21976" href="../Isomorphism/#4333" class="Record Operator">≃</a> <a id="21978" class="Symbol">(</a><a id="21979" href="../Connectives/#21949" class="Bound">A</a> <a id="21981" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="21983" href="../Connectives/#21953" class="Bound">C</a><a id="21984" class="Symbol">)</a> <a id="21986" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="21988" class="Symbol">(</a><a id="21989" href="../Connectives/#21951" class="Bound">B</a> <a id="21991" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="21993" href="../Connectives/#21953" class="Bound">C</a><a id="21994" class="Symbol">)</a>
<a id="21996" href="../Connectives/#21932" class="Function">×-distrib-⊎</a> <a id="22008" class="Symbol">=</a>
  <a id="22012" class="Keyword">record</a>
    <a id="22023" class="Symbol">{</a> <a id="22025" href="../Isomorphism/#4373" class="Field">to</a>      <a id="22033" class="Symbol">=</a> <a id="22035" class="Symbol">λ{</a> <a id="22038" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22040" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="22045" href="../Connectives/#22045" class="Bound">x</a> <a id="22047" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22049" href="../Connectives/#22049" class="Bound">z</a> <a id="22051" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="22053" class="Symbol">→</a> <a id="22055" class="Symbol">(</a><a id="22056" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="22061" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22063" href="../Connectives/#22045" class="Bound">x</a> <a id="22065" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22067" href="../Connectives/#22049" class="Bound">z</a> <a id="22069" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a><a id="22070" class="Symbol">)</a>
                 <a id="22089" class="Symbol">;</a> <a id="22091" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22093" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="22098" href="../Connectives/#22098" class="Bound">y</a> <a id="22100" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22102" href="../Connectives/#22102" class="Bound">z</a> <a id="22104" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="22106" class="Symbol">→</a> <a id="22108" class="Symbol">(</a><a id="22109" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="22114" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22116" href="../Connectives/#22098" class="Bound">y</a> <a id="22118" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22120" href="../Connectives/#22102" class="Bound">z</a> <a id="22122" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a><a id="22123" class="Symbol">)</a>
                 <a id="22142" class="Symbol">}</a>
    <a id="22148" class="Symbol">;</a> <a id="22150" href="../Isomorphism/#4390" class="Field">from</a>    <a id="22158" class="Symbol">=</a> <a id="22160" class="Symbol">λ{</a> <a id="22163" class="Symbol">(</a><a id="22164" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="22169" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22171" href="../Connectives/#22171" class="Bound">x</a> <a id="22173" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22175" href="../Connectives/#22175" class="Bound">z</a> <a id="22177" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a><a id="22178" class="Symbol">)</a> <a id="22180" class="Symbol">→</a> <a id="22182" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22184" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="22189" href="../Connectives/#22171" class="Bound">x</a> <a id="22191" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22193" href="../Connectives/#22175" class="Bound">z</a> <a id="22195" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>
                 <a id="22214" class="Symbol">;</a> <a id="22216" class="Symbol">(</a><a id="22217" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="22222" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22224" href="../Connectives/#22224" class="Bound">y</a> <a id="22226" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22228" href="../Connectives/#22228" class="Bound">z</a> <a id="22230" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a><a id="22231" class="Symbol">)</a> <a id="22233" class="Symbol">→</a> <a id="22235" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22237" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="22242" href="../Connectives/#22224" class="Bound">y</a> <a id="22244" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22246" href="../Connectives/#22228" class="Bound">z</a> <a id="22248" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>
                 <a id="22267" class="Symbol">}</a>
    <a id="22273" class="Symbol">;</a> <a id="22275" href="../Isomorphism/#4407" class="Field">from∘to</a> <a id="22283" class="Symbol">=</a> <a id="22285" class="Symbol">λ{</a> <a id="22288" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22290" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="22295" href="../Connectives/#22295" class="Bound">x</a> <a id="22297" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22299" href="../Connectives/#22299" class="Bound">z</a> <a id="22301" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="22303" class="Symbol">→</a> <a id="22305" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
                 <a id="22327" class="Symbol">;</a> <a id="22329" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22331" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="22336" href="../Connectives/#22336" class="Bound">y</a> <a id="22338" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22340" href="../Connectives/#22340" class="Bound">z</a> <a id="22342" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="22344" class="Symbol">→</a> <a id="22346" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
                 <a id="22368" class="Symbol">}</a>
    <a id="22374" class="Symbol">;</a> <a id="22376" href="../Isomorphism/#4449" class="Field">to∘from</a> <a id="22384" class="Symbol">=</a> <a id="22386" class="Symbol">λ{</a> <a id="22389" class="Symbol">(</a><a id="22390" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="22395" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22397" href="../Connectives/#22397" class="Bound">x</a> <a id="22399" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22401" href="../Connectives/#22401" class="Bound">z</a> <a id="22403" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a><a id="22404" class="Symbol">)</a> <a id="22406" class="Symbol">→</a> <a id="22408" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
                 <a id="22430" class="Symbol">;</a> <a id="22432" class="Symbol">(</a><a id="22433" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="22438" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22440" href="../Connectives/#22440" class="Bound">y</a> <a id="22442" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22444" href="../Connectives/#22444" class="Bound">z</a> <a id="22446" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a><a id="22447" class="Symbol">)</a> <a id="22449" class="Symbol">→</a> <a id="22451" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
                 <a id="22473" class="Symbol">}</a>
    <a id="22479" class="Symbol">}</a>
</pre>
Sums do not distribute over products up to isomorphism, but it is an embedding:
<pre class="Agda"><a id="⊎-distrib-×"></a><a id="22570" href="../Connectives/#22570" class="Function">⊎-distrib-×</a> <a id="22582" class="Symbol">:</a> <a id="22584" class="Symbol">∀</a> <a id="22586" class="Symbol">{</a><a id="22587" href="../Connectives/#22587" class="Bound">A</a> <a id="22589" href="../Connectives/#22589" class="Bound">B</a> <a id="22591" href="../Connectives/#22591" class="Bound">C</a> <a id="22593" class="Symbol">:</a> <a id="22595" class="PrimitiveType">Set</a><a id="22598" class="Symbol">}</a> <a id="22600" class="Symbol">→</a> <a id="22602" class="Symbol">(</a><a id="22603" href="../Connectives/#22587" class="Bound">A</a> <a id="22605" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="22607" href="../Connectives/#22589" class="Bound">B</a><a id="22608" class="Symbol">)</a> <a id="22610" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="22612" href="../Connectives/#22591" class="Bound">C</a> <a id="22614" href="../Isomorphism/#9231" class="Record Operator">≲</a> <a id="22616" class="Symbol">(</a><a id="22617" href="../Connectives/#22587" class="Bound">A</a> <a id="22619" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="22621" href="../Connectives/#22591" class="Bound">C</a><a id="22622" class="Symbol">)</a> <a id="22624" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="22626" class="Symbol">(</a><a id="22627" href="../Connectives/#22589" class="Bound">B</a> <a id="22629" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="22631" href="../Connectives/#22591" class="Bound">C</a><a id="22632" class="Symbol">)</a>
<a id="22634" href="../Connectives/#22570" class="Function">⊎-distrib-×</a> <a id="22646" class="Symbol">=</a>
  <a id="22650" class="Keyword">record</a>
    <a id="22661" class="Symbol">{</a> <a id="22663" href="../Isomorphism/#9271" class="Field">to</a>      <a id="22671" class="Symbol">=</a> <a id="22673" class="Symbol">λ{</a> <a id="22676" class="Symbol">(</a><a id="22677" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="22682" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22684" href="../Connectives/#22684" class="Bound">x</a> <a id="22686" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22688" href="../Connectives/#22688" class="Bound">y</a> <a id="22690" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a><a id="22691" class="Symbol">)</a> <a id="22693" class="Symbol">→</a> <a id="22695" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22697" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="22702" href="../Connectives/#22684" class="Bound">x</a> <a id="22704" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22706" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="22711" href="../Connectives/#22688" class="Bound">y</a> <a id="22713" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>
                 <a id="22732" class="Symbol">;</a> <a id="22734" class="Symbol">(</a><a id="22735" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="22740" href="../Connectives/#22740" class="Bound">z</a><a id="22741" class="Symbol">)</a>         <a id="22751" class="Symbol">→</a> <a id="22753" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22755" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="22760" href="../Connectives/#22740" class="Bound">z</a> <a id="22762" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22764" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="22769" href="../Connectives/#22740" class="Bound">z</a> <a id="22771" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>
                 <a id="22790" class="Symbol">}</a>
    <a id="22796" class="Symbol">;</a> <a id="22798" href="../Isomorphism/#9291" class="Field">from</a>    <a id="22806" class="Symbol">=</a> <a id="22808" class="Symbol">λ{</a> <a id="22811" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22813" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="22818" href="../Connectives/#22818" class="Bound">x</a> <a id="22820" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22822" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="22827" href="../Connectives/#22827" class="Bound">y</a> <a id="22829" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="22831" class="Symbol">→</a> <a id="22833" class="Symbol">(</a><a id="22834" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="22839" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22841" href="../Connectives/#22818" class="Bound">x</a> <a id="22843" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22845" href="../Connectives/#22827" class="Bound">y</a> <a id="22847" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a><a id="22848" class="Symbol">)</a>
                 <a id="22867" class="Symbol">;</a> <a id="22869" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22871" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="22876" href="../Connectives/#22876" class="Bound">x</a> <a id="22878" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22880" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="22885" href="../Connectives/#22885" class="Bound">z</a> <a id="22887" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="22889" class="Symbol">→</a> <a id="22891" class="Symbol">(</a><a id="22892" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="22897" href="../Connectives/#22885" class="Bound">z</a><a id="22898" class="Symbol">)</a>
                 <a id="22917" class="Symbol">;</a> <a id="22919" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22921" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="22926" href="../Connectives/#22926" class="Bound">z</a> <a id="22928" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22930" class="Symbol">_</a>      <a id="22937" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="22939" class="Symbol">→</a> <a id="22941" class="Symbol">(</a><a id="22942" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="22947" href="../Connectives/#22926" class="Bound">z</a><a id="22948" class="Symbol">)</a>
                 <a id="22967" class="Symbol">}</a>
    <a id="22973" class="Symbol">;</a> <a id="22975" href="../Isomorphism/#9311" class="Field">from∘to</a> <a id="22983" class="Symbol">=</a> <a id="22985" class="Symbol">λ{</a> <a id="22988" class="Symbol">(</a><a id="22989" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="22994" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22996" href="../Connectives/#22996" class="Bound">x</a> <a id="22998" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="23000" href="../Connectives/#23000" class="Bound">y</a> <a id="23002" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a><a id="23003" class="Symbol">)</a> <a id="23005" class="Symbol">→</a> <a id="23007" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
                 <a id="23029" class="Symbol">;</a> <a id="23031" class="Symbol">(</a><a id="23032" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="23037" href="../Connectives/#23037" class="Bound">z</a><a id="23038" class="Symbol">)</a>         <a id="23048" class="Symbol">→</a> <a id="23050" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
                 <a id="23072" class="Symbol">}</a>
    <a id="23078" class="Symbol">}</a>
</pre>
<p>Note that there is a choice in how we write the <code>from</code> function. As given, it takes <code>⟨ inj₂ z , inj₂ z′ ⟩</code> to <code>inj₂ z</code>, but it is easy to write a variant that instead returns <code>inj₂ z′</code>. We have an embedding rather than an isomorphism because the <code>from</code> function must discard either <code>z</code> or <code>z′</code> in this case.</p>
<p>In the usual approach to logic, both of the distribution laws are given as equivalences, where each side implies the other:</p>
<pre><code>A × (B ⊎ C) ⇔ (A × B) ⊎ (A × C)
A ⊎ (B × C) ⇔ (A ⊎ B) × (A ⊎ C)</code></pre>
<p>But when we consider the functions that provide evidence for these implications, then the first corresponds to an isomorphism while the second only corresponds to an embedding, revealing a sense in which one of these laws is “more true” than the other.</p>
<h4 id="exercise--weak--recommended">Exercise <code>⊎-weak-×</code> (recommended)</h4>
Show that the following property holds:
<pre class="Agda"><a id="23931" class="Keyword">postulate</a>
  <a id="⊎-weak-×"></a><a id="23943" href="../Connectives/#23943" class="Postulate">⊎-weak-×</a> <a id="23952" class="Symbol">:</a> <a id="23954" class="Symbol">∀</a> <a id="23956" class="Symbol">{</a><a id="23957" href="../Connectives/#23957" class="Bound">A</a> <a id="23959" href="../Connectives/#23959" class="Bound">B</a> <a id="23961" href="../Connectives/#23961" class="Bound">C</a> <a id="23963" class="Symbol">:</a> <a id="23965" class="PrimitiveType">Set</a><a id="23968" class="Symbol">}</a> <a id="23970" class="Symbol">→</a> <a id="23972" class="Symbol">(</a><a id="23973" href="../Connectives/#23957" class="Bound">A</a> <a id="23975" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="23977" href="../Connectives/#23959" class="Bound">B</a><a id="23978" class="Symbol">)</a> <a id="23980" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="23982" href="../Connectives/#23961" class="Bound">C</a> <a id="23984" class="Symbol">→</a> <a id="23986" href="../Connectives/#23957" class="Bound">A</a> <a id="23988" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="23990" class="Symbol">(</a><a id="23991" href="../Connectives/#23959" class="Bound">B</a> <a id="23993" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="23995" href="../Connectives/#23961" class="Bound">C</a><a id="23996" class="Symbol">)</a>
</pre>
<p>This is called a <em>weak distributive law</em>. Give the corresponding distributive law, and explain how it relates to the weak version.</p>
<pre class="Agda"><a id="24138" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise--implies--practice">Exercise <code>⊎×-implies-×⊎</code> (practice)</h4>
Show that a disjunct of conjuncts implies a conjunct of disjuncts:
<pre class="Agda"><a id="24280" class="Keyword">postulate</a>
  <a id="⊎×-implies-×⊎"></a><a id="24292" href="../Connectives/#24292" class="Postulate">⊎×-implies-×⊎</a> <a id="24306" class="Symbol">:</a> <a id="24308" class="Symbol">∀</a> <a id="24310" class="Symbol">{</a><a id="24311" href="../Connectives/#24311" class="Bound">A</a> <a id="24313" href="../Connectives/#24313" class="Bound">B</a> <a id="24315" href="../Connectives/#24315" class="Bound">C</a> <a id="24317" href="../Connectives/#24317" class="Bound">D</a> <a id="24319" class="Symbol">:</a> <a id="24321" class="PrimitiveType">Set</a><a id="24324" class="Symbol">}</a> <a id="24326" class="Symbol">→</a> <a id="24328" class="Symbol">(</a><a id="24329" href="../Connectives/#24311" class="Bound">A</a> <a id="24331" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="24333" href="../Connectives/#24313" class="Bound">B</a><a id="24334" class="Symbol">)</a> <a id="24336" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="24338" class="Symbol">(</a><a id="24339" href="../Connectives/#24315" class="Bound">C</a> <a id="24341" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="24343" href="../Connectives/#24317" class="Bound">D</a><a id="24344" class="Symbol">)</a> <a id="24346" class="Symbol">→</a> <a id="24348" class="Symbol">(</a><a id="24349" href="../Connectives/#24311" class="Bound">A</a> <a id="24351" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="24353" href="../Connectives/#24315" class="Bound">C</a><a id="24354" class="Symbol">)</a> <a id="24356" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="24358" class="Symbol">(</a><a id="24359" href="../Connectives/#24313" class="Bound">B</a> <a id="24361" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="24363" href="../Connectives/#24317" class="Bound">D</a><a id="24364" class="Symbol">)</a>
</pre>
<p>Does the converse hold? If so, prove; if not, give a counterexample.</p>
<pre class="Agda"><a id="24444" class="Comment">-- Your code goes here</a>
</pre>
<h2 id="standard-library">Standard library</h2>
Definitions similar to those in this chapter can be found in the standard library:
<pre class="Agda"><a id="24581" class="Keyword">import</a> <a id="24588" href="https://agda.github.io/agda-stdlib/v1.6/Data.Product.html" class="Module">Data.Product</a> <a id="24601" class="Keyword">using</a> <a id="24607" class="Symbol">(</a><a id="24608" href="https://agda.github.io/agda-stdlib/v1.6/Data.Product.html#1167" class="Function Operator">_×_</a><a id="24611" class="Symbol">;</a> <a id="24613" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="24618" class="Symbol">;</a> <a id="24620" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Sigma.html#264" class="Field">proj₂</a><a id="24625" class="Symbol">)</a> <a id="24627" class="Keyword">renaming</a> <a id="24636" class="Symbol">(</a><a id="24637" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a> <a id="24641" class="Symbol">to</a> <a id="_,_"></a><a id="24644" href="../Connectives/#24644" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="24649" class="Symbol">)</a>
<a id="24651" class="Keyword">import</a> <a id="24658" href="https://agda.github.io/agda-stdlib/v1.6/Data.Unit.html" class="Module">Data.Unit</a> <a id="24668" class="Keyword">using</a> <a id="24674" class="Symbol">(</a><a id="24675" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Unit.html#164" class="Record">⊤</a><a id="24676" class="Symbol">;</a> <a id="24678" href="https://agda.github.io/agda-stdlib/v1.6/Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a><a id="24680" class="Symbol">)</a>
<a id="24682" class="Keyword">import</a> <a id="24689" href="https://agda.github.io/agda-stdlib/v1.6/Data.Sum.html" class="Module">Data.Sum</a> <a id="24698" class="Keyword">using</a> <a id="24704" class="Symbol">(</a><a id="24705" href="https://agda.github.io/agda-stdlib/v1.6/Data.Sum.Base.html#734" class="Datatype Operator">_⊎_</a><a id="24708" class="Symbol">;</a> <a id="24710" href="https://agda.github.io/agda-stdlib/v1.6/Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a><a id="24714" class="Symbol">;</a> <a id="24716" href="https://agda.github.io/agda-stdlib/v1.6/Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a><a id="24720" class="Symbol">)</a> <a id="24722" class="Keyword">renaming</a> <a id="24731" class="Symbol">(</a><a id="24732" href="https://agda.github.io/agda-stdlib/v1.6/Data.Sum.Base.html#920" class="Function Operator">[_,_]</a> <a id="24738" class="Symbol">to</a> <a id="[_,_]"></a><a id="24741" href="../Connectives/#24741" class="Function Operator">case-⊎</a><a id="24747" class="Symbol">)</a>
<a id="24749" class="Keyword">import</a> <a id="24756" href="https://agda.github.io/agda-stdlib/v1.6/Data.Empty.html" class="Module">Data.Empty</a> <a id="24767" class="Keyword">using</a> <a id="24773" class="Symbol">(</a><a id="24774" href="https://agda.github.io/agda-stdlib/v1.6/Data.Empty.html#526" class="Datatype">⊥</a><a id="24775" class="Symbol">;</a> <a id="24777" href="https://agda.github.io/agda-stdlib/v1.6/Data.Empty.html#628" class="Function">⊥-elim</a><a id="24783" class="Symbol">)</a>
<a id="24785" class="Keyword">import</a> <a id="24792" href="https://agda.github.io/agda-stdlib/v1.6/Function.Equivalence.html" class="Module">Function.Equivalence</a> <a id="24813" class="Keyword">using</a> <a id="24819" class="Symbol">(</a><a id="24820" href="https://agda.github.io/agda-stdlib/v1.6/Function.Equivalence.html#1204" class="Function Operator">_⇔_</a><a id="24823" class="Symbol">)</a>
</pre>
<p>The standard library constructs pairs with <code>_,_</code> whereas we use <code>⟨_,_⟩</code>. The former makes it convenient to build triples or larger tuples from pairs, permitting <code>a , b , c</code> to stand for <code>(a , (b , c))</code>. But it conflicts with other useful notations, such as <code>[_,_]</code> to construct a list of two elements in Chapter <a href="../Lists/">Lists</a> and <code>Γ , A</code> to extend environments in Chapter <a href="../DeBruijn/">DeBruijn</a>. The standard library <code>_⇔_</code> is similar to ours, but the one in the standard library is less convenient, since it is parameterised with respect to an arbitrary notion of equivalence.</p>
<h2 id="unicode">Unicode</h2>
<p>This chapter uses the following unicode:</p>
<pre><code>×  U+00D7  MULTIPLICATION SIGN (\x)
⊎  U+228E  MULTISET UNION (\u+)
⊤  U+22A4  DOWN TACK (\top)
⊥  U+22A5  UP TACK (\bot)
η  U+03B7  GREEK SMALL LETTER ETA (\eta)
₁  U+2081  SUBSCRIPT ONE (\_1)
₂  U+2082  SUBSCRIPT TWO (\_2)
⇔  U+21D4  LEFT RIGHT DOUBLE ARROW (\&lt;=&gt;)</code></pre>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>This paragraph was adopted from “Propositions as Types”, Philip Wadler, <em>Communications of the ACM</em>, December 2015.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
    </div>
    <nav class="pager">
    <ul class="pagination">
        
        <li><a class="pagelink" href="../Isomorphism/">Prev</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Connectives.lagda.md">Source</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="../Negation/">Next</a></li>
        <li class="separator">&bullet;</li>
        
    </ul>
</nav>

</article>

            </div>
        </main>
        <footer class="site-footer h-card">
    <data class="u-url" href="../"></data>
    <div class="wrapper">
        <h2 class="footer-heading">Programming Language Foundations in Agda</h2>
        
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Philip Wadler</li>
                    <li>
                        
                        <a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/wadler" title="wadler"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;wadler</a></li>
    
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Wen Kokke</li>
                    <li>
                        
                        <a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;wenkokke</a></li>
    
    
    <li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#twitter"></use></svg>&nbsp;wenkokke</a></li>
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Jeremy G. Siek</li>
                    <li>
                        
                        <a class="u-email" href="mailto:jsiek@indiana.edu">jsiek@indiana.edu</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/jsiek" title="jsiek"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;jsiek</a></li>
    
    
    <li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#twitter"></use></svg>&nbsp;jeremysiek</a></li>
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        
        This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
    </div>
</footer>

    </body>
</html>
