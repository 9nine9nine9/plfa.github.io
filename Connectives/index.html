<!DOCTYPE html>
<html lang="en">
    <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../public/css/style.css">
  
  <title>Programming Language Foundations in Agda – Connectives</title>
  
  
  
</head>

    <body>
        <header class="site-header">
    <div class="wrapper">
        <a class="site-title" href="../">Programming Language Foundations in Agda</a>
        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="../">The Book</a>
                <a class="page-link" href="../Announcements/">Announcements</a>
                <a class="page-link" href="../GettingStarted/">Getting Started</a>
                <a class="page-link" href="../Citing/">Citing</a>
                <a class="page-link" href="https://agda-zh.github.io/PLFA-zh/">中文</a>
            </div>
        </nav>
    </div>
</header>

        <main class="page-content" aria-label="Content">
            <div class="wrapper">
                <article class="post">
    <nav class="pager">
    <ul class="pagination">
        
        <li><a class="pagelink" href="../Isomorphism/">Prev</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Connectives.lagda.md">Source</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="../Negation/">Next</a></li>
        <li class="separator">&bullet;</li>
        
    </ul>
</nav>

    <header class="post-header">
        <h1 class="post-title" id="connectives">Connectives: Conjunction, disjunction, and implication</h1>
    </header>
    <div class="post-content">
        <pre class="Agda"><a id="175" class="Keyword">module</a> <a id="182" href="../Connectives/" class="Module">plfa.part1.Connectives</a> <a id="205" class="Keyword">where</a>
</pre>
<!-- The ⊥ ⊎ A ≅ A exercise requires a (inj₁ ()) pattern,
     which the reader will not have seen. Restore this
     exercise, and possibly also associativity? Take the
     exercises from the final sections on distributivity
     and exponentials? -->
<p>This chapter introduces the basic logical connectives, by observing a correspondence between connectives of logic and data types, a principle known as <em>Propositions as Types</em>:</p>
<ul>
<li><em>conjunction</em> is <em>product</em>,</li>
<li><em>disjunction</em> is <em>sum</em>,</li>
<li><em>true</em> is <em>unit type</em>,</li>
<li><em>false</em> is <em>empty type</em>,</li>
<li><em>implication</em> is <em>function space</em>.</li>
</ul>
<h2 id="imports">Imports</h2>
<pre class="Agda"><a id="821" class="Keyword">import</a> <a id="828" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="866" class="Symbol">as</a> <a id="869" class="Module">Eq</a>
<a id="872" class="Keyword">open</a> <a id="877" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="880" class="Keyword">using</a> <a id="886" class="Symbol">(</a><a id="887" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="890" class="Symbol">;</a> <a id="892" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="896" class="Symbol">)</a>
<a id="898" class="Keyword">open</a> <a id="903" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2419" class="Module">Eq.≡-Reasoning</a>
<a id="918" class="Keyword">open</a> <a id="923" class="Keyword">import</a> <a id="930" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.html" class="Module">Data.Nat</a> <a id="939" class="Keyword">using</a> <a id="945" class="Symbol">(</a><a id="946" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="947" class="Symbol">)</a>
<a id="949" class="Keyword">open</a> <a id="954" class="Keyword">import</a> <a id="961" href="https://agda.github.io/agda-stdlib/v1.3/Function.html" class="Module">Function</a> <a id="970" class="Keyword">using</a> <a id="976" class="Symbol">(</a><a id="977" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">_∘_</a><a id="980" class="Symbol">)</a>
<a id="982" class="Keyword">open</a> <a id="987" class="Keyword">import</a> <a id="994" href="../Isomorphism/" class="Module">plfa.part1.Isomorphism</a> <a id="1017" class="Keyword">using</a> <a id="1023" class="Symbol">(</a><a id="1024" href="../Isomorphism/#4329" class="Record Operator">_≃_</a><a id="1027" class="Symbol">;</a> <a id="1029" href="../Isomorphism/#9227" class="Record Operator">_≲_</a><a id="1032" class="Symbol">;</a> <a id="1034" href="../Isomorphism/#2666" class="Postulate">extensionality</a><a id="1048" class="Symbol">)</a>
<a id="1050" class="Keyword">open</a> <a id="1055" href="../Isomorphism/#8462" class="Module">plfa.part1.Isomorphism.≃-Reasoning</a>
</pre>
<h2 id="conjunction-is-product">Conjunction is product</h2>
Given two propositions <code>A</code> and <code>B</code>, the conjunction <code>A × B</code> holds if both <code>A</code> holds and <code>B</code> holds. We formalise this idea by declaring a suitable record type:
<pre class="Agda"><a id="1287" class="Keyword">data</a> <a id="_×_"></a><a id="1292" href="../Connectives/#1292" class="Datatype Operator">_×_</a> <a id="1296" class="Symbol">(</a><a id="1297" href="../Connectives/#1297" class="Bound">A</a> <a id="1299" href="../Connectives/#1299" class="Bound">B</a> <a id="1301" class="Symbol">:</a> <a id="1303" class="PrimitiveType">Set</a><a id="1306" class="Symbol">)</a> <a id="1308" class="Symbol">:</a> <a id="1310" class="PrimitiveType">Set</a> <a id="1314" class="Keyword">where</a>

  <a id="_×_.⟨_,_⟩"></a><a id="1323" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨_,_⟩</a> <a id="1329" class="Symbol">:</a>
      <a id="1337" href="../Connectives/#1297" class="Bound">A</a>
    <a id="1343" class="Symbol">→</a> <a id="1345" href="../Connectives/#1299" class="Bound">B</a>
      <a id="1353" class="Comment">-----</a>
    <a id="1363" class="Symbol">→</a> <a id="1365" href="../Connectives/#1297" class="Bound">A</a> <a id="1367" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="1369" href="../Connectives/#1299" class="Bound">B</a>
</pre>
<p>Evidence that <code>A × B</code> holds is of the form <code>⟨ M , N ⟩</code>, where <code>M</code> provides evidence that <code>A</code> holds and <code>N</code> provides evidence that <code>B</code> holds.</p>
Given evidence that <code>A × B</code> holds, we can conclude that both <code>A</code> holds and <code>B</code> holds:
<pre class="Agda"><a id="proj₁"></a><a id="1607" href="../Connectives/#1607" class="Function">proj₁</a> <a id="1613" class="Symbol">:</a> <a id="1615" class="Symbol">∀</a> <a id="1617" class="Symbol">{</a><a id="1618" href="../Connectives/#1618" class="Bound">A</a> <a id="1620" href="../Connectives/#1620" class="Bound">B</a> <a id="1622" class="Symbol">:</a> <a id="1624" class="PrimitiveType">Set</a><a id="1627" class="Symbol">}</a>
  <a id="1631" class="Symbol">→</a> <a id="1633" href="../Connectives/#1618" class="Bound">A</a> <a id="1635" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="1637" href="../Connectives/#1620" class="Bound">B</a>
    <a id="1643" class="Comment">-----</a>
  <a id="1651" class="Symbol">→</a> <a id="1653" href="../Connectives/#1618" class="Bound">A</a>
<a id="1655" href="../Connectives/#1607" class="Function">proj₁</a> <a id="1661" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="1663" href="../Connectives/#1663" class="Bound">x</a> <a id="1665" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="1667" href="../Connectives/#1667" class="Bound">y</a> <a id="1669" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="1671" class="Symbol">=</a> <a id="1673" href="../Connectives/#1663" class="Bound">x</a>

<a id="proj₂"></a><a id="1676" href="../Connectives/#1676" class="Function">proj₂</a> <a id="1682" class="Symbol">:</a> <a id="1684" class="Symbol">∀</a> <a id="1686" class="Symbol">{</a><a id="1687" href="../Connectives/#1687" class="Bound">A</a> <a id="1689" href="../Connectives/#1689" class="Bound">B</a> <a id="1691" class="Symbol">:</a> <a id="1693" class="PrimitiveType">Set</a><a id="1696" class="Symbol">}</a>
  <a id="1700" class="Symbol">→</a> <a id="1702" href="../Connectives/#1687" class="Bound">A</a> <a id="1704" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="1706" href="../Connectives/#1689" class="Bound">B</a>
    <a id="1712" class="Comment">-----</a>
  <a id="1720" class="Symbol">→</a> <a id="1722" href="../Connectives/#1689" class="Bound">B</a>
<a id="1724" href="../Connectives/#1676" class="Function">proj₂</a> <a id="1730" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="1732" href="../Connectives/#1732" class="Bound">x</a> <a id="1734" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="1736" href="../Connectives/#1736" class="Bound">y</a> <a id="1738" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="1740" class="Symbol">=</a> <a id="1742" href="../Connectives/#1736" class="Bound">y</a>
</pre>
<p>If <code>L</code> provides evidence that <code>A × B</code> holds, then <code>proj₁ L</code> provides evidence that <code>A</code> holds, and <code>proj₂ L</code> provides evidence that <code>B</code> holds.</p>
<p>When <code>⟨_,_⟩</code> appears in a term on the right-hand side of an equation we refer to it as a <em>constructor</em>, and when it appears in a pattern on the left-hand side of an equation we refer to it as a <em>destructor</em>. We may also refer to <code>proj₁</code> and <code>proj₂</code> as destructors, since they play a similar role.</p>
<p>Other terminology refers to <code>⟨_,_⟩</code> as <em>introducing</em> a conjunction, and to <code>proj₁</code> and <code>proj₂</code> as <em>eliminating</em> a conjunction; indeed, the former is sometimes given the name <code>×-I</code> and the latter two the names <code>×-E₁</code> and <code>×-E₂</code>. As we read the rules from top to bottom, introduction and elimination do what they say on the tin: the first <em>introduces</em> a formula for the connective, which appears in the conclusion but not in the hypotheses; the second <em>eliminates</em> a formula for the connective, which appears in a hypothesis but not in the conclusion. An introduction rule describes under what conditions we say the connective holds—how to <em>define</em> the connective. An elimination rule describes what we may conclude when the connective holds—how to <em>use</em> the connective.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
In this case, applying each destructor and reassembling the results with the constructor is the identity over products:
<pre class="Agda"><a id="η-×"></a><a id="3107" href="../Connectives/#3107" class="Function">η-×</a> <a id="3111" class="Symbol">:</a> <a id="3113" class="Symbol">∀</a> <a id="3115" class="Symbol">{</a><a id="3116" href="../Connectives/#3116" class="Bound">A</a> <a id="3118" href="../Connectives/#3118" class="Bound">B</a> <a id="3120" class="Symbol">:</a> <a id="3122" class="PrimitiveType">Set</a><a id="3125" class="Symbol">}</a> <a id="3127" class="Symbol">(</a><a id="3128" href="../Connectives/#3128" class="Bound">w</a> <a id="3130" class="Symbol">:</a> <a id="3132" href="../Connectives/#3116" class="Bound">A</a> <a id="3134" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="3136" href="../Connectives/#3118" class="Bound">B</a><a id="3137" class="Symbol">)</a> <a id="3139" class="Symbol">→</a> <a id="3141" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="3143" href="../Connectives/#1607" class="Function">proj₁</a> <a id="3149" href="../Connectives/#3128" class="Bound">w</a> <a id="3151" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="3153" href="../Connectives/#1676" class="Function">proj₂</a> <a id="3159" href="../Connectives/#3128" class="Bound">w</a> <a id="3161" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="3163" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="3165" href="../Connectives/#3128" class="Bound">w</a>
<a id="3167" href="../Connectives/#3107" class="Function">η-×</a> <a id="3171" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="3173" href="../Connectives/#3173" class="Bound">x</a> <a id="3175" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="3177" href="../Connectives/#3177" class="Bound">y</a> <a id="3179" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="3181" class="Symbol">=</a> <a id="3183" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>The pattern matching on the left-hand side is essential, since replacing <code>w</code> by <code>⟨ x , y ⟩</code> allows both sides of the propositional equality to simplify to the same term.</p>
We set the precedence of conjunction so that it binds less tightly than anything save disjunction:
<pre class="Agda"><a id="3466" class="Keyword">infixr</a> <a id="3473" class="Number">2</a> <a id="3475" href="../Connectives/#1292" class="Datatype Operator">_×_</a>
</pre>
<p>Thus, <code>m ≤ n × n ≤ p</code> parses as <code>(m ≤ n) × (n ≤ p)</code>.</p>
Alternatively, we can declare conjunction as a record type:
<pre class="Agda"><a id="3601" class="Keyword">record</a> <a id="_×′_"></a><a id="3608" href="../Connectives/#3608" class="Record Operator">_×′_</a> <a id="3613" class="Symbol">(</a><a id="3614" href="../Connectives/#3614" class="Bound">A</a> <a id="3616" href="../Connectives/#3616" class="Bound">B</a> <a id="3618" class="Symbol">:</a> <a id="3620" class="PrimitiveType">Set</a><a id="3623" class="Symbol">)</a> <a id="3625" class="Symbol">:</a> <a id="3627" class="PrimitiveType">Set</a> <a id="3631" class="Keyword">where</a>
  <a id="3639" class="Keyword">constructor</a> <a id="⟨_,_⟩′"></a><a id="3651" href="../Connectives/#3651" class="InductiveConstructor Operator">⟨_,_⟩′</a>
  <a id="3660" class="Keyword">field</a>
    <a id="_×′_.proj₁′"></a><a id="3670" href="../Connectives/#3670" class="Field">proj₁′</a> <a id="3677" class="Symbol">:</a> <a id="3679" href="../Connectives/#3614" class="Bound">A</a>
    <a id="_×′_.proj₂′"></a><a id="3685" href="../Connectives/#3685" class="Field">proj₂′</a> <a id="3692" class="Symbol">:</a> <a id="3694" href="../Connectives/#3616" class="Bound">B</a>
<a id="3696" class="Keyword">open</a> <a id="3701" href="../Connectives/#3608" class="Module Operator">_×′_</a>
</pre>
<p>The record construction <code>record { proj₁′ = M ; proj₂′ = N }</code> corresponds to the term <code>⟨ M , N ⟩</code> where <code>M</code> is a term of type <code>A</code> and <code>N</code> is a term of type <code>B</code>. The constructor declaration allows us to write <code>⟨ M , N ⟩′</code> in place of the record construction.</p>
The data type <code>_x_</code> and the record type <code>_×′_</code> behave similarly. One difference is that for data types we have to prove η-equality, but for record types, η-equality holds <em>by definition</em>. While proving <code>η-×′</code>, we do not have to pattern match on <code>w</code> to know that η-equality holds:
<pre class="Agda"><a id="η-×′"></a><a id="4252" href="../Connectives/#4252" class="Function">η-×′</a> <a id="4257" class="Symbol">:</a> <a id="4259" class="Symbol">∀</a> <a id="4261" class="Symbol">{</a><a id="4262" href="../Connectives/#4262" class="Bound">A</a> <a id="4264" href="../Connectives/#4264" class="Bound">B</a> <a id="4266" class="Symbol">:</a> <a id="4268" class="PrimitiveType">Set</a><a id="4271" class="Symbol">}</a> <a id="4273" class="Symbol">(</a><a id="4274" href="../Connectives/#4274" class="Bound">w</a> <a id="4276" class="Symbol">:</a> <a id="4278" href="../Connectives/#4262" class="Bound">A</a> <a id="4280" href="../Connectives/#3608" class="Record Operator">×′</a> <a id="4283" href="../Connectives/#4264" class="Bound">B</a><a id="4284" class="Symbol">)</a> <a id="4286" class="Symbol">→</a> <a id="4288" href="../Connectives/#3651" class="InductiveConstructor Operator">⟨</a> <a id="4290" href="../Connectives/#3670" class="Field">proj₁′</a> <a id="4297" href="../Connectives/#4274" class="Bound">w</a> <a id="4299" href="../Connectives/#3651" class="InductiveConstructor Operator">,</a> <a id="4301" href="../Connectives/#3685" class="Field">proj₂′</a> <a id="4308" href="../Connectives/#4274" class="Bound">w</a> <a id="4310" href="../Connectives/#3651" class="InductiveConstructor Operator">⟩′</a> <a id="4313" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="4315" href="../Connectives/#4274" class="Bound">w</a>
<a id="4317" href="../Connectives/#4252" class="Function">η-×′</a> <a id="4322" href="../Connectives/#4322" class="Bound">w</a> <a id="4324" class="Symbol">=</a> <a id="4326" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>It can be very convenient to have η-equality <em>definitionally</em>, and so the standard library defines <code>_×_</code> as a record type. We use the definition from the standard library in later chapters.</p>
Given two types <code>A</code> and <code>B</code>, we refer to <code>A × B</code> as the <em>product</em> of <code>A</code> and <code>B</code>. In set theory, it is also sometimes called the <em>Cartesian product</em>, and in computing it corresponds to a <em>record</em> type. Among other reasons for calling it the product, note that if type <code>A</code> has <code>m</code> distinct members, and type <code>B</code> has <code>n</code> distinct members, then the type <code>A × B</code> has <code>m * n</code> distinct members. For instance, consider a type <code>Bool</code> with two members, and a type <code>Tri</code> with three members:
<pre class="Agda"><a id="5013" class="Keyword">data</a> <a id="Bool"></a><a id="5018" href="../Connectives/#5018" class="Datatype">Bool</a> <a id="5023" class="Symbol">:</a> <a id="5025" class="PrimitiveType">Set</a> <a id="5029" class="Keyword">where</a>
  <a id="Bool.true"></a><a id="5037" href="../Connectives/#5037" class="InductiveConstructor">true</a>  <a id="5043" class="Symbol">:</a> <a id="5045" href="../Connectives/#5018" class="Datatype">Bool</a>
  <a id="Bool.false"></a><a id="5052" href="../Connectives/#5052" class="InductiveConstructor">false</a> <a id="5058" class="Symbol">:</a> <a id="5060" href="../Connectives/#5018" class="Datatype">Bool</a>

<a id="5066" class="Keyword">data</a> <a id="Tri"></a><a id="5071" href="../Connectives/#5071" class="Datatype">Tri</a> <a id="5075" class="Symbol">:</a> <a id="5077" class="PrimitiveType">Set</a> <a id="5081" class="Keyword">where</a>
  <a id="Tri.aa"></a><a id="5089" href="../Connectives/#5089" class="InductiveConstructor">aa</a> <a id="5092" class="Symbol">:</a> <a id="5094" href="../Connectives/#5071" class="Datatype">Tri</a>
  <a id="Tri.bb"></a><a id="5100" href="../Connectives/#5100" class="InductiveConstructor">bb</a> <a id="5103" class="Symbol">:</a> <a id="5105" href="../Connectives/#5071" class="Datatype">Tri</a>
  <a id="Tri.cc"></a><a id="5111" href="../Connectives/#5111" class="InductiveConstructor">cc</a> <a id="5114" class="Symbol">:</a> <a id="5116" href="../Connectives/#5071" class="Datatype">Tri</a>
</pre>
<p>Then the type <code>Bool × Tri</code> has six members:</p>
<pre><code>⟨ true  , aa ⟩    ⟨ true  , bb ⟩    ⟨ true ,  cc ⟩
⟨ false , aa ⟩    ⟨ false , bb ⟩    ⟨ false , cc ⟩</code></pre>
For example, the following function enumerates all possible arguments of type <code>Bool × Tri</code>:
<pre class="Agda"><a id="×-count"></a><a id="5376" href="../Connectives/#5376" class="Function">×-count</a> <a id="5384" class="Symbol">:</a> <a id="5386" href="../Connectives/#5018" class="Datatype">Bool</a> <a id="5391" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="5393" href="../Connectives/#5071" class="Datatype">Tri</a> <a id="5397" class="Symbol">→</a> <a id="5399" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="5401" href="../Connectives/#5376" class="Function">×-count</a> <a id="5409" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="5411" href="../Connectives/#5037" class="InductiveConstructor">true</a>  <a id="5417" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="5419" href="../Connectives/#5089" class="InductiveConstructor">aa</a> <a id="5422" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>  <a id="5425" class="Symbol">=</a>  <a id="5428" class="Number">1</a>
<a id="5430" href="../Connectives/#5376" class="Function">×-count</a> <a id="5438" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="5440" href="../Connectives/#5037" class="InductiveConstructor">true</a>  <a id="5446" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="5448" href="../Connectives/#5100" class="InductiveConstructor">bb</a> <a id="5451" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>  <a id="5454" class="Symbol">=</a>  <a id="5457" class="Number">2</a>
<a id="5459" href="../Connectives/#5376" class="Function">×-count</a> <a id="5467" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="5469" href="../Connectives/#5037" class="InductiveConstructor">true</a>  <a id="5475" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="5477" href="../Connectives/#5111" class="InductiveConstructor">cc</a> <a id="5480" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>  <a id="5483" class="Symbol">=</a>  <a id="5486" class="Number">3</a>
<a id="5488" href="../Connectives/#5376" class="Function">×-count</a> <a id="5496" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="5498" href="../Connectives/#5052" class="InductiveConstructor">false</a> <a id="5504" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="5506" href="../Connectives/#5089" class="InductiveConstructor">aa</a> <a id="5509" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>  <a id="5512" class="Symbol">=</a>  <a id="5515" class="Number">4</a>
<a id="5517" href="../Connectives/#5376" class="Function">×-count</a> <a id="5525" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="5527" href="../Connectives/#5052" class="InductiveConstructor">false</a> <a id="5533" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="5535" href="../Connectives/#5100" class="InductiveConstructor">bb</a> <a id="5538" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>  <a id="5541" class="Symbol">=</a>  <a id="5544" class="Number">5</a>
<a id="5546" href="../Connectives/#5376" class="Function">×-count</a> <a id="5554" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="5556" href="../Connectives/#5052" class="InductiveConstructor">false</a> <a id="5562" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="5564" href="../Connectives/#5111" class="InductiveConstructor">cc</a> <a id="5567" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>  <a id="5570" class="Symbol">=</a>  <a id="5573" class="Number">6</a>
</pre>
<p>Product on types also shares a property with product on numbers in that there is a sense in which it is commutative and associative. In particular, product is commutative and associative <em>up to isomorphism</em>.</p>
For commutativity, the <code>to</code> function swaps a pair, taking <code>⟨ x , y ⟩</code> to <code>⟨ y , x ⟩</code>, and the <code>from</code> function does the same (up to renaming). Instantiating the patterns correctly in <code>from∘to</code> and <code>to∘from</code> is essential. Replacing the definition of <code>from∘to</code> by <code>λ w → refl</code> will not work; and similarly for <code>to∘from</code>:
<pre class="Agda"><a id="×-comm"></a><a id="6112" href="../Connectives/#6112" class="Function">×-comm</a> <a id="6119" class="Symbol">:</a> <a id="6121" class="Symbol">∀</a> <a id="6123" class="Symbol">{</a><a id="6124" href="../Connectives/#6124" class="Bound">A</a> <a id="6126" href="../Connectives/#6126" class="Bound">B</a> <a id="6128" class="Symbol">:</a> <a id="6130" class="PrimitiveType">Set</a><a id="6133" class="Symbol">}</a> <a id="6135" class="Symbol">→</a> <a id="6137" href="../Connectives/#6124" class="Bound">A</a> <a id="6139" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="6141" href="../Connectives/#6126" class="Bound">B</a> <a id="6143" href="../Isomorphism/#4329" class="Record Operator">≃</a> <a id="6145" href="../Connectives/#6126" class="Bound">B</a> <a id="6147" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="6149" href="../Connectives/#6124" class="Bound">A</a>
<a id="6151" href="../Connectives/#6112" class="Function">×-comm</a> <a id="6158" class="Symbol">=</a>
  <a id="6162" class="Keyword">record</a>
    <a id="6173" class="Symbol">{</a> <a id="6175" href="../Isomorphism/#4369" class="Field">to</a>       <a id="6184" class="Symbol">=</a>  <a id="6187" class="Symbol">λ{</a> <a id="6190" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="6192" href="../Connectives/#6192" class="Bound">x</a> <a id="6194" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="6196" href="../Connectives/#6196" class="Bound">y</a> <a id="6198" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="6200" class="Symbol">→</a> <a id="6202" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="6204" href="../Connectives/#6196" class="Bound">y</a> <a id="6206" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="6208" href="../Connectives/#6192" class="Bound">x</a> <a id="6210" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="6212" class="Symbol">}</a>
    <a id="6218" class="Symbol">;</a> <a id="6220" href="../Isomorphism/#4386" class="Field">from</a>     <a id="6229" class="Symbol">=</a>  <a id="6232" class="Symbol">λ{</a> <a id="6235" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="6237" href="../Connectives/#6237" class="Bound">y</a> <a id="6239" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="6241" href="../Connectives/#6241" class="Bound">x</a> <a id="6243" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="6245" class="Symbol">→</a> <a id="6247" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="6249" href="../Connectives/#6241" class="Bound">x</a> <a id="6251" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="6253" href="../Connectives/#6237" class="Bound">y</a> <a id="6255" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="6257" class="Symbol">}</a>
    <a id="6263" class="Symbol">;</a> <a id="6265" href="../Isomorphism/#4403" class="Field">from∘to</a>  <a id="6274" class="Symbol">=</a>  <a id="6277" class="Symbol">λ{</a> <a id="6280" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="6282" href="../Connectives/#6282" class="Bound">x</a> <a id="6284" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="6286" href="../Connectives/#6286" class="Bound">y</a> <a id="6288" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="6290" class="Symbol">→</a> <a id="6292" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="6297" class="Symbol">}</a>
    <a id="6303" class="Symbol">;</a> <a id="6305" href="../Isomorphism/#4445" class="Field">to∘from</a>  <a id="6314" class="Symbol">=</a>  <a id="6317" class="Symbol">λ{</a> <a id="6320" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="6322" href="../Connectives/#6322" class="Bound">y</a> <a id="6324" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="6326" href="../Connectives/#6326" class="Bound">x</a> <a id="6328" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="6330" class="Symbol">→</a> <a id="6332" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="6337" class="Symbol">}</a>
    <a id="6343" class="Symbol">}</a>
</pre>
<p>Being <em>commutative</em> is different from being <em>commutative up to isomorphism</em>. Compare the two statements:</p>
<pre><code>m * n ≡ n * m
A × B ≃ B × A</code></pre>
<p>In the first case, we might have that <code>m</code> is <code>2</code> and <code>n</code> is <code>3</code>, and both <code>m * n</code> and <code>n * m</code> are equal to <code>6</code>. In the second case, we might have that <code>A</code> is <code>Bool</code> and <code>B</code> is <code>Tri</code>, and <code>Bool × Tri</code> is <em>not</em> the same as <code>Tri × Bool</code>. But there is an isomorphism between the two types. For instance, <code>⟨ true , aa ⟩</code>, which is a member of the former, corresponds to <code>⟨ aa , true ⟩</code>, which is a member of the latter.</p>
For associativity, the <code>to</code> function reassociates two uses of pairing, taking <code>⟨ ⟨ x , y ⟩ , z ⟩</code> to <code>⟨ x , ⟨ y , z ⟩ ⟩</code>, and the <code>from</code> function does the inverse. Again, the evidence of left and right inverse requires matching against a suitable pattern to enable simplification:
<pre class="Agda"><a id="×-assoc"></a><a id="7199" href="../Connectives/#7199" class="Function">×-assoc</a> <a id="7207" class="Symbol">:</a> <a id="7209" class="Symbol">∀</a> <a id="7211" class="Symbol">{</a><a id="7212" href="../Connectives/#7212" class="Bound">A</a> <a id="7214" href="../Connectives/#7214" class="Bound">B</a> <a id="7216" href="../Connectives/#7216" class="Bound">C</a> <a id="7218" class="Symbol">:</a> <a id="7220" class="PrimitiveType">Set</a><a id="7223" class="Symbol">}</a> <a id="7225" class="Symbol">→</a> <a id="7227" class="Symbol">(</a><a id="7228" href="../Connectives/#7212" class="Bound">A</a> <a id="7230" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="7232" href="../Connectives/#7214" class="Bound">B</a><a id="7233" class="Symbol">)</a> <a id="7235" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="7237" href="../Connectives/#7216" class="Bound">C</a> <a id="7239" href="../Isomorphism/#4329" class="Record Operator">≃</a> <a id="7241" href="../Connectives/#7212" class="Bound">A</a> <a id="7243" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="7245" class="Symbol">(</a><a id="7246" href="../Connectives/#7214" class="Bound">B</a> <a id="7248" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="7250" href="../Connectives/#7216" class="Bound">C</a><a id="7251" class="Symbol">)</a>
<a id="7253" href="../Connectives/#7199" class="Function">×-assoc</a> <a id="7261" class="Symbol">=</a>
  <a id="7265" class="Keyword">record</a>
    <a id="7276" class="Symbol">{</a> <a id="7278" href="../Isomorphism/#4369" class="Field">to</a>      <a id="7286" class="Symbol">=</a> <a id="7288" class="Symbol">λ{</a> <a id="7291" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7293" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7295" href="../Connectives/#7295" class="Bound">x</a> <a id="7297" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7299" href="../Connectives/#7299" class="Bound">y</a> <a id="7301" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7303" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7305" href="../Connectives/#7305" class="Bound">z</a> <a id="7307" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7309" class="Symbol">→</a> <a id="7311" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7313" href="../Connectives/#7295" class="Bound">x</a> <a id="7315" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7317" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7319" href="../Connectives/#7299" class="Bound">y</a> <a id="7321" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7323" href="../Connectives/#7305" class="Bound">z</a> <a id="7325" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7327" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7329" class="Symbol">}</a>
    <a id="7335" class="Symbol">;</a> <a id="7337" href="../Isomorphism/#4386" class="Field">from</a>    <a id="7345" class="Symbol">=</a> <a id="7347" class="Symbol">λ{</a> <a id="7350" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7352" href="../Connectives/#7352" class="Bound">x</a> <a id="7354" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7356" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7358" href="../Connectives/#7358" class="Bound">y</a> <a id="7360" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7362" href="../Connectives/#7362" class="Bound">z</a> <a id="7364" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7366" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7368" class="Symbol">→</a> <a id="7370" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7372" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7374" href="../Connectives/#7352" class="Bound">x</a> <a id="7376" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7378" href="../Connectives/#7358" class="Bound">y</a> <a id="7380" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7382" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7384" href="../Connectives/#7362" class="Bound">z</a> <a id="7386" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7388" class="Symbol">}</a>
    <a id="7394" class="Symbol">;</a> <a id="7396" href="../Isomorphism/#4403" class="Field">from∘to</a> <a id="7404" class="Symbol">=</a> <a id="7406" class="Symbol">λ{</a> <a id="7409" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7411" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7413" href="../Connectives/#7413" class="Bound">x</a> <a id="7415" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7417" href="../Connectives/#7417" class="Bound">y</a> <a id="7419" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7421" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7423" href="../Connectives/#7423" class="Bound">z</a> <a id="7425" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7427" class="Symbol">→</a> <a id="7429" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="7434" class="Symbol">}</a>
    <a id="7440" class="Symbol">;</a> <a id="7442" href="../Isomorphism/#4445" class="Field">to∘from</a> <a id="7450" class="Symbol">=</a> <a id="7452" class="Symbol">λ{</a> <a id="7455" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7457" href="../Connectives/#7457" class="Bound">x</a> <a id="7459" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7461" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="7463" href="../Connectives/#7463" class="Bound">y</a> <a id="7465" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="7467" href="../Connectives/#7467" class="Bound">z</a> <a id="7469" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7471" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="7473" class="Symbol">→</a> <a id="7475" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="7480" class="Symbol">}</a>
    <a id="7486" class="Symbol">}</a>
</pre>
<p>Being <em>associative</em> is not the same as being <em>associative up to isomorphism</em>. Compare the two statements:</p>
<pre><code>(m * n) * p ≡ m * (n * p)
(A × B) × C ≃ A × (B × C)</code></pre>
<p>For example, the type <code>(ℕ × Bool) × Tri</code> is <em>not</em> the same as <code>ℕ × (Bool × Tri)</code>. But there is an isomorphism between the two types. For instance <code>⟨ ⟨ 1 , true ⟩ , aa ⟩</code>, which is a member of the former, corresponds to <code>⟨ 1 , ⟨ true , aa ⟩ ⟩</code>, which is a member of the latter.</p>
<h4 id="exercise-recommended">Exercise <code>⇔≃×</code> (recommended)</h4>
<p>Show that <code>A ⇔ B</code> as defined <a href="../Isomorphism/#iff">earlier</a> is isomorphic to <code>(A → B) × (B → A)</code>.</p>
<pre class="Agda"><a id="8076" class="Comment">-- Your code goes here</a>
</pre>
<h2 id="truth-is-unit">Truth is unit</h2>
Truth <code>⊤</code> always holds. We formalise this idea by declaring a suitable record type:
<pre class="Agda"><a id="8211" class="Keyword">data</a> <a id="⊤"></a><a id="8216" href="../Connectives/#8216" class="Datatype">⊤</a> <a id="8218" class="Symbol">:</a> <a id="8220" class="PrimitiveType">Set</a> <a id="8224" class="Keyword">where</a>

  <a id="⊤.tt"></a><a id="8233" href="../Connectives/#8233" class="InductiveConstructor">tt</a> <a id="8236" class="Symbol">:</a>
    <a id="8242" class="Comment">--</a>
    <a id="8249" href="../Connectives/#8216" class="Datatype">⊤</a>
</pre>
<p>Evidence that <code>⊤</code> holds is of the form <code>tt</code>.</p>
<p>There is an introduction rule, but no elimination rule. Given evidence that <code>⊤</code> holds, there is nothing more of interest we can conclude. Since truth always holds, knowing that it holds tells us nothing new.</p>
The nullary case of <code>η-×</code> is <code>η-⊤</code>, which asserts that any value of type <code>⊤</code> must be equal to <code>tt</code>:
<pre class="Agda"><a id="η-⊤"></a><a id="8615" href="../Connectives/#8615" class="Function">η-⊤</a> <a id="8619" class="Symbol">:</a> <a id="8621" class="Symbol">∀</a> <a id="8623" class="Symbol">(</a><a id="8624" href="../Connectives/#8624" class="Bound">w</a> <a id="8626" class="Symbol">:</a> <a id="8628" href="../Connectives/#8216" class="Datatype">⊤</a><a id="8629" class="Symbol">)</a> <a id="8631" class="Symbol">→</a> <a id="8633" href="../Connectives/#8233" class="InductiveConstructor">tt</a> <a id="8636" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="8638" href="../Connectives/#8624" class="Bound">w</a>
<a id="8640" href="../Connectives/#8615" class="Function">η-⊤</a> <a id="8644" href="../Connectives/#8233" class="InductiveConstructor">tt</a> <a id="8647" class="Symbol">=</a> <a id="8649" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>The pattern matching on the left-hand side is essential. Replacing <code>w</code> by <code>tt</code> allows both sides of the propositional equality to simplify to the same term.</p>
Alternatively, we can declare truth as an empty record:
<pre class="Agda"><a id="8876" class="Keyword">record</a> <a id="⊤′"></a><a id="8883" href="../Connectives/#8883" class="Record">⊤′</a> <a id="8886" class="Symbol">:</a> <a id="8888" class="PrimitiveType">Set</a> <a id="8892" class="Keyword">where</a>
  <a id="8900" class="Keyword">constructor</a> <a id="tt′"></a><a id="8912" href="../Connectives/#8912" class="InductiveConstructor">tt′</a>
</pre>
<p>The record construction <code>record {}</code> corresponds to the term <code>tt</code>. The constructor declaration allows us to write <code>tt′</code>.</p>
As with the product, the data type <code>⊤</code> and the record type <code>⊤′</code> behave similarly, but η-equality holds <em>by definition</em> for the record type. While proving <code>η-⊤′</code>, we do not have to pattern match on <code>w</code>—Agda <em>knows</em> it is equal to <code>tt′</code>:
<pre class="Agda"><a id="η-⊤′"></a><a id="9283" href="../Connectives/#9283" class="Function">η-⊤′</a> <a id="9288" class="Symbol">:</a> <a id="9290" class="Symbol">∀</a> <a id="9292" class="Symbol">(</a><a id="9293" href="../Connectives/#9293" class="Bound">w</a> <a id="9295" class="Symbol">:</a> <a id="9297" href="../Connectives/#8883" class="Record">⊤′</a><a id="9299" class="Symbol">)</a> <a id="9301" class="Symbol">→</a> <a id="9303" href="../Connectives/#8912" class="InductiveConstructor">tt′</a> <a id="9307" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="9309" href="../Connectives/#9293" class="Bound">w</a>
<a id="9311" href="../Connectives/#9283" class="Function">η-⊤′</a> <a id="9316" href="../Connectives/#9316" class="Bound">w</a> <a id="9318" class="Symbol">=</a> <a id="9320" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
Agda knows that <em>any</em> value of type <code>⊤′</code> must be <code>tt′</code>, so any time we need a value of type <code>⊤′</code>, we can tell Agda to figure it out:
<pre class="Agda"><a id="truth′"></a><a id="9466" href="../Connectives/#9466" class="Function">truth′</a> <a id="9473" class="Symbol">:</a> <a id="9475" href="../Connectives/#8883" class="Record">⊤′</a>
<a id="9478" href="../Connectives/#9466" class="Function">truth′</a> <a id="9485" class="Symbol">=</a> <a id="9487" class="Symbol">_</a>
</pre>
We refer to <code>⊤</code> as the <em>unit</em> type. And, indeed, type <code>⊤</code> has exactly one member, <code>tt</code>. For example, the following function enumerates all possible arguments of type <code>⊤</code>:
<pre class="Agda"><a id="⊤-count"></a><a id="9670" href="../Connectives/#9670" class="Function">⊤-count</a> <a id="9678" class="Symbol">:</a> <a id="9680" href="../Connectives/#8216" class="Datatype">⊤</a> <a id="9682" class="Symbol">→</a> <a id="9684" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="9686" href="../Connectives/#9670" class="Function">⊤-count</a> <a id="9694" href="../Connectives/#8233" class="InductiveConstructor">tt</a> <a id="9697" class="Symbol">=</a> <a id="9699" class="Number">1</a>
</pre>
For numbers, one is the identity of multiplication. Correspondingly, unit is the identity of product <em>up to isomorphism</em>. For left identity, the <code>to</code> function takes <code>⟨ tt , x ⟩</code> to <code>x</code>, and the <code>from</code> function does the inverse. The evidence of left inverse requires matching against a suitable pattern to enable simplification:
<pre class="Agda"><a id="⊤-identityˡ"></a><a id="10040" href="../Connectives/#10040" class="Function">⊤-identityˡ</a> <a id="10052" class="Symbol">:</a> <a id="10054" class="Symbol">∀</a> <a id="10056" class="Symbol">{</a><a id="10057" href="../Connectives/#10057" class="Bound">A</a> <a id="10059" class="Symbol">:</a> <a id="10061" class="PrimitiveType">Set</a><a id="10064" class="Symbol">}</a> <a id="10066" class="Symbol">→</a> <a id="10068" href="../Connectives/#8216" class="Datatype">⊤</a> <a id="10070" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="10072" href="../Connectives/#10057" class="Bound">A</a> <a id="10074" href="../Isomorphism/#4329" class="Record Operator">≃</a> <a id="10076" href="../Connectives/#10057" class="Bound">A</a>
<a id="10078" href="../Connectives/#10040" class="Function">⊤-identityˡ</a> <a id="10090" class="Symbol">=</a>
  <a id="10094" class="Keyword">record</a>
    <a id="10105" class="Symbol">{</a> <a id="10107" href="../Isomorphism/#4369" class="Field">to</a>      <a id="10115" class="Symbol">=</a> <a id="10117" class="Symbol">λ{</a> <a id="10120" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="10122" href="../Connectives/#8233" class="InductiveConstructor">tt</a> <a id="10125" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="10127" href="../Connectives/#10127" class="Bound">x</a> <a id="10129" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="10131" class="Symbol">→</a> <a id="10133" href="../Connectives/#10127" class="Bound">x</a> <a id="10135" class="Symbol">}</a>
    <a id="10141" class="Symbol">;</a> <a id="10143" href="../Isomorphism/#4386" class="Field">from</a>    <a id="10151" class="Symbol">=</a> <a id="10153" class="Symbol">λ{</a> <a id="10156" href="../Connectives/#10156" class="Bound">x</a> <a id="10158" class="Symbol">→</a> <a id="10160" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="10162" href="../Connectives/#8233" class="InductiveConstructor">tt</a> <a id="10165" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="10167" href="../Connectives/#10156" class="Bound">x</a> <a id="10169" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="10171" class="Symbol">}</a>
    <a id="10177" class="Symbol">;</a> <a id="10179" href="../Isomorphism/#4403" class="Field">from∘to</a> <a id="10187" class="Symbol">=</a> <a id="10189" class="Symbol">λ{</a> <a id="10192" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="10194" href="../Connectives/#8233" class="InductiveConstructor">tt</a> <a id="10197" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="10199" href="../Connectives/#10199" class="Bound">x</a> <a id="10201" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="10203" class="Symbol">→</a> <a id="10205" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="10210" class="Symbol">}</a>
    <a id="10216" class="Symbol">;</a> <a id="10218" href="../Isomorphism/#4445" class="Field">to∘from</a> <a id="10226" class="Symbol">=</a> <a id="10228" class="Symbol">λ{</a> <a id="10231" href="../Connectives/#10231" class="Bound">x</a> <a id="10233" class="Symbol">→</a> <a id="10235" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="10240" class="Symbol">}</a>
    <a id="10246" class="Symbol">}</a>
</pre>
<p>Having an <em>identity</em> is different from having an identity <em>up to isomorphism</em>. Compare the two statements:</p>
<pre><code>1 * m ≡ m
⊤ × A ≃ A</code></pre>
<p>In the first case, we might have that <code>m</code> is <code>2</code>, and both <code>1 * m</code> and <code>m</code> are equal to <code>2</code>. In the second case, we might have that <code>A</code> is <code>Bool</code>, and <code>⊤ × Bool</code> is <em>not</em> the same as <code>Bool</code>. But there is an isomorphism between the two types. For instance, <code>⟨ tt , true ⟩</code>, which is a member of the former, corresponds to <code>true</code>, which is a member of the latter.</p>
Right identity follows from commutativity of product and left identity:
<pre class="Agda"><a id="⊤-identityʳ"></a><a id="10832" href="../Connectives/#10832" class="Function">⊤-identityʳ</a> <a id="10844" class="Symbol">:</a> <a id="10846" class="Symbol">∀</a> <a id="10848" class="Symbol">{</a><a id="10849" href="../Connectives/#10849" class="Bound">A</a> <a id="10851" class="Symbol">:</a> <a id="10853" class="PrimitiveType">Set</a><a id="10856" class="Symbol">}</a> <a id="10858" class="Symbol">→</a> <a id="10860" class="Symbol">(</a><a id="10861" href="../Connectives/#10849" class="Bound">A</a> <a id="10863" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="10865" href="../Connectives/#8216" class="Datatype">⊤</a><a id="10866" class="Symbol">)</a> <a id="10868" href="../Isomorphism/#4329" class="Record Operator">≃</a> <a id="10870" href="../Connectives/#10849" class="Bound">A</a>
<a id="10872" href="../Connectives/#10832" class="Function">⊤-identityʳ</a> <a id="10884" class="Symbol">{</a><a id="10885" href="../Connectives/#10885" class="Bound">A</a><a id="10886" class="Symbol">}</a> <a id="10888" class="Symbol">=</a>
  <a id="10892" href="../Isomorphism/#8538" class="Function Operator">≃-begin</a>
    <a id="10904" class="Symbol">(</a><a id="10905" href="../Connectives/#10885" class="Bound">A</a> <a id="10907" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="10909" href="../Connectives/#8216" class="Datatype">⊤</a><a id="10910" class="Symbol">)</a>
  <a id="10914" href="../Isomorphism/#8622" class="Function Operator">≃⟨</a> <a id="10917" href="../Connectives/#6112" class="Function">×-comm</a> <a id="10924" href="../Isomorphism/#8622" class="Function Operator">⟩</a>
    <a id="10930" class="Symbol">(</a><a id="10931" href="../Connectives/#8216" class="Datatype">⊤</a> <a id="10933" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="10935" href="../Connectives/#10885" class="Bound">A</a><a id="10936" class="Symbol">)</a>
  <a id="10940" href="../Isomorphism/#8622" class="Function Operator">≃⟨</a> <a id="10943" href="../Connectives/#10040" class="Function">⊤-identityˡ</a> <a id="10955" href="../Isomorphism/#8622" class="Function Operator">⟩</a>
    <a id="10961" href="../Connectives/#10885" class="Bound">A</a>
  <a id="10965" href="../Isomorphism/#8741" class="Function Operator">≃-∎</a>
</pre>
<p>Here we have used a chain of isomorphisms, analogous to that used for equality.</p>
<h2 id="disjunction-is-sum">Disjunction is sum</h2>
Given two propositions <code>A</code> and <code>B</code>, the disjunction <code>A ⊎ B</code> holds if either <code>A</code> holds or <code>B</code> holds. We formalise this idea by declaring a suitable inductive type:
<pre class="Agda"><a id="11246" class="Keyword">data</a> <a id="_⊎_"></a><a id="11251" href="../Connectives/#11251" class="Datatype Operator">_⊎_</a> <a id="11255" class="Symbol">(</a><a id="11256" href="../Connectives/#11256" class="Bound">A</a> <a id="11258" href="../Connectives/#11258" class="Bound">B</a> <a id="11260" class="Symbol">:</a> <a id="11262" class="PrimitiveType">Set</a><a id="11265" class="Symbol">)</a> <a id="11267" class="Symbol">:</a> <a id="11269" class="PrimitiveType">Set</a> <a id="11273" class="Keyword">where</a>

  <a id="_⊎_.inj₁"></a><a id="11282" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="11287" class="Symbol">:</a>
      <a id="11295" href="../Connectives/#11256" class="Bound">A</a>
      <a id="11303" class="Comment">-----</a>
    <a id="11313" class="Symbol">→</a> <a id="11315" href="../Connectives/#11256" class="Bound">A</a> <a id="11317" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="11319" href="../Connectives/#11258" class="Bound">B</a>

  <a id="_⊎_.inj₂"></a><a id="11324" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="11329" class="Symbol">:</a>
      <a id="11337" href="../Connectives/#11258" class="Bound">B</a>
      <a id="11345" class="Comment">-----</a>
    <a id="11355" class="Symbol">→</a> <a id="11357" href="../Connectives/#11256" class="Bound">A</a> <a id="11359" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="11361" href="../Connectives/#11258" class="Bound">B</a>
</pre>
<p>Evidence that <code>A ⊎ B</code> holds is either of the form <code>inj₁ M</code>, where <code>M</code> provides evidence that <code>A</code> holds, or <code>inj₂ N</code>, where <code>N</code> provides evidence that <code>B</code> holds.</p>
Given evidence that <code>A → C</code> and <code>B → C</code> both hold, then given evidence that <code>A ⊎ B</code> holds we can conclude that <code>C</code> holds:
<pre class="Agda"><a id="case-⊎"></a><a id="11655" href="../Connectives/#11655" class="Function">case-⊎</a> <a id="11662" class="Symbol">:</a> <a id="11664" class="Symbol">∀</a> <a id="11666" class="Symbol">{</a><a id="11667" href="../Connectives/#11667" class="Bound">A</a> <a id="11669" href="../Connectives/#11669" class="Bound">B</a> <a id="11671" href="../Connectives/#11671" class="Bound">C</a> <a id="11673" class="Symbol">:</a> <a id="11675" class="PrimitiveType">Set</a><a id="11678" class="Symbol">}</a>
  <a id="11682" class="Symbol">→</a> <a id="11684" class="Symbol">(</a><a id="11685" href="../Connectives/#11667" class="Bound">A</a> <a id="11687" class="Symbol">→</a> <a id="11689" href="../Connectives/#11671" class="Bound">C</a><a id="11690" class="Symbol">)</a>
  <a id="11694" class="Symbol">→</a> <a id="11696" class="Symbol">(</a><a id="11697" href="../Connectives/#11669" class="Bound">B</a> <a id="11699" class="Symbol">→</a> <a id="11701" href="../Connectives/#11671" class="Bound">C</a><a id="11702" class="Symbol">)</a>
  <a id="11706" class="Symbol">→</a> <a id="11708" href="../Connectives/#11667" class="Bound">A</a> <a id="11710" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="11712" href="../Connectives/#11669" class="Bound">B</a>
    <a id="11718" class="Comment">-----------</a>
  <a id="11732" class="Symbol">→</a> <a id="11734" href="../Connectives/#11671" class="Bound">C</a>
<a id="11736" href="../Connectives/#11655" class="Function">case-⊎</a> <a id="11743" href="../Connectives/#11743" class="Bound">f</a> <a id="11745" href="../Connectives/#11745" class="Bound">g</a> <a id="11747" class="Symbol">(</a><a id="11748" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="11753" href="../Connectives/#11753" class="Bound">x</a><a id="11754" class="Symbol">)</a> <a id="11756" class="Symbol">=</a> <a id="11758" href="../Connectives/#11743" class="Bound">f</a> <a id="11760" href="../Connectives/#11753" class="Bound">x</a>
<a id="11762" href="../Connectives/#11655" class="Function">case-⊎</a> <a id="11769" href="../Connectives/#11769" class="Bound">f</a> <a id="11771" href="../Connectives/#11771" class="Bound">g</a> <a id="11773" class="Symbol">(</a><a id="11774" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="11779" href="../Connectives/#11779" class="Bound">y</a><a id="11780" class="Symbol">)</a> <a id="11782" class="Symbol">=</a> <a id="11784" href="../Connectives/#11771" class="Bound">g</a> <a id="11786" href="../Connectives/#11779" class="Bound">y</a>
</pre>
<p>Pattern matching against <code>inj₁</code> and <code>inj₂</code> is typical of how we exploit evidence that a disjunction holds.</p>
<p>When <code>inj₁</code> and <code>inj₂</code> appear on the right-hand side of an equation we refer to them as <em>constructors</em>, and when they appear on the left-hand side we refer to them as <em>destructors</em>. We also refer to <code>case-⊎</code> as a destructor, since it plays a similar role. Other terminology refers to <code>inj₁</code> and <code>inj₂</code> as <em>introducing</em> a disjunction, and to <code>case-⊎</code> as <em>eliminating</em> a disjunction; indeed the former are sometimes given the names <code>⊎-I₁</code> and <code>⊎-I₂</code> and the latter the name <code>⊎-E</code>.</p>
Applying the destructor to each of the constructors is the identity:
<pre class="Agda"><a id="η-⊎"></a><a id="12455" href="../Connectives/#12455" class="Function">η-⊎</a> <a id="12459" class="Symbol">:</a> <a id="12461" class="Symbol">∀</a> <a id="12463" class="Symbol">{</a><a id="12464" href="../Connectives/#12464" class="Bound">A</a> <a id="12466" href="../Connectives/#12466" class="Bound">B</a> <a id="12468" class="Symbol">:</a> <a id="12470" class="PrimitiveType">Set</a><a id="12473" class="Symbol">}</a> <a id="12475" class="Symbol">(</a><a id="12476" href="../Connectives/#12476" class="Bound">w</a> <a id="12478" class="Symbol">:</a> <a id="12480" href="../Connectives/#12464" class="Bound">A</a> <a id="12482" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="12484" href="../Connectives/#12466" class="Bound">B</a><a id="12485" class="Symbol">)</a> <a id="12487" class="Symbol">→</a> <a id="12489" href="../Connectives/#11655" class="Function">case-⊎</a> <a id="12496" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="12501" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="12506" href="../Connectives/#12476" class="Bound">w</a> <a id="12508" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="12510" href="../Connectives/#12476" class="Bound">w</a>
<a id="12512" href="../Connectives/#12455" class="Function">η-⊎</a> <a id="12516" class="Symbol">(</a><a id="12517" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="12522" href="../Connectives/#12522" class="Bound">x</a><a id="12523" class="Symbol">)</a> <a id="12525" class="Symbol">=</a> <a id="12527" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="12532" href="../Connectives/#12455" class="Function">η-⊎</a> <a id="12536" class="Symbol">(</a><a id="12537" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="12542" href="../Connectives/#12542" class="Bound">y</a><a id="12543" class="Symbol">)</a> <a id="12545" class="Symbol">=</a> <a id="12547" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
More generally, we can also throw in an arbitrary function from a disjunction:
<pre class="Agda"><a id="uniq-⊎"></a><a id="12639" href="../Connectives/#12639" class="Function">uniq-⊎</a> <a id="12646" class="Symbol">:</a> <a id="12648" class="Symbol">∀</a> <a id="12650" class="Symbol">{</a><a id="12651" href="../Connectives/#12651" class="Bound">A</a> <a id="12653" href="../Connectives/#12653" class="Bound">B</a> <a id="12655" href="../Connectives/#12655" class="Bound">C</a> <a id="12657" class="Symbol">:</a> <a id="12659" class="PrimitiveType">Set</a><a id="12662" class="Symbol">}</a> <a id="12664" class="Symbol">(</a><a id="12665" href="../Connectives/#12665" class="Bound">h</a> <a id="12667" class="Symbol">:</a> <a id="12669" href="../Connectives/#12651" class="Bound">A</a> <a id="12671" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="12673" href="../Connectives/#12653" class="Bound">B</a> <a id="12675" class="Symbol">→</a> <a id="12677" href="../Connectives/#12655" class="Bound">C</a><a id="12678" class="Symbol">)</a> <a id="12680" class="Symbol">(</a><a id="12681" href="../Connectives/#12681" class="Bound">w</a> <a id="12683" class="Symbol">:</a> <a id="12685" href="../Connectives/#12651" class="Bound">A</a> <a id="12687" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="12689" href="../Connectives/#12653" class="Bound">B</a><a id="12690" class="Symbol">)</a> <a id="12692" class="Symbol">→</a>
  <a id="12696" href="../Connectives/#11655" class="Function">case-⊎</a> <a id="12703" class="Symbol">(</a><a id="12704" href="../Connectives/#12665" class="Bound">h</a> <a id="12706" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">∘</a> <a id="12708" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a><a id="12712" class="Symbol">)</a> <a id="12714" class="Symbol">(</a><a id="12715" href="../Connectives/#12665" class="Bound">h</a> <a id="12717" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">∘</a> <a id="12719" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a><a id="12723" class="Symbol">)</a> <a id="12725" href="../Connectives/#12681" class="Bound">w</a> <a id="12727" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="12729" href="../Connectives/#12665" class="Bound">h</a> <a id="12731" href="../Connectives/#12681" class="Bound">w</a>
<a id="12733" href="../Connectives/#12639" class="Function">uniq-⊎</a> <a id="12740" href="../Connectives/#12740" class="Bound">h</a> <a id="12742" class="Symbol">(</a><a id="12743" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="12748" href="../Connectives/#12748" class="Bound">x</a><a id="12749" class="Symbol">)</a> <a id="12751" class="Symbol">=</a> <a id="12753" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="12758" href="../Connectives/#12639" class="Function">uniq-⊎</a> <a id="12765" href="../Connectives/#12765" class="Bound">h</a> <a id="12767" class="Symbol">(</a><a id="12768" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="12773" href="../Connectives/#12773" class="Bound">y</a><a id="12774" class="Symbol">)</a> <a id="12776" class="Symbol">=</a> <a id="12778" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>The pattern matching on the left-hand side is essential. Replacing <code>w</code> by <code>inj₁ x</code> allows both sides of the propositional equality to simplify to the same term, and similarly for <code>inj₂ y</code>.</p>
We set the precedence of disjunction so that it binds less tightly than any other declared operator:
<pre class="Agda"><a id="13083" class="Keyword">infixr</a> <a id="13090" class="Number">1</a> <a id="13092" href="../Connectives/#11251" class="Datatype Operator">_⊎_</a>
</pre>
<p>Thus, <code>A × C ⊎ B × C</code> parses as <code>(A × C) ⊎ (B × C)</code>.</p>
<p>Given two types <code>A</code> and <code>B</code>, we refer to <code>A ⊎ B</code> as the <em>sum</em> of <code>A</code> and <code>B</code>. In set theory, it is also sometimes called the <em>disjoint union</em>, and in computing it corresponds to a <em>variant record</em> type. Among other reasons for calling it the sum, note that if type <code>A</code> has <code>m</code> distinct members, and type <code>B</code> has <code>n</code> distinct members, then the type <code>A ⊎ B</code> has <code>m + n</code> distinct members. For instance, consider a type <code>Bool</code> with two members, and a type <code>Tri</code> with three members, as defined earlier. Then the type <code>Bool ⊎ Tri</code> has five members:</p>
<pre><code>inj₁ true     inj₂ aa
inj₁ false    inj₂ bb
              inj₂ cc</code></pre>
For example, the following function enumerates all possible arguments of type <code>Bool ⊎ Tri</code>:
<pre class="Agda"><a id="⊎-count"></a><a id="13874" href="../Connectives/#13874" class="Function">⊎-count</a> <a id="13882" class="Symbol">:</a> <a id="13884" href="../Connectives/#5018" class="Datatype">Bool</a> <a id="13889" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="13891" href="../Connectives/#5071" class="Datatype">Tri</a> <a id="13895" class="Symbol">→</a> <a id="13897" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="13899" href="../Connectives/#13874" class="Function">⊎-count</a> <a id="13907" class="Symbol">(</a><a id="13908" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="13913" href="../Connectives/#5037" class="InductiveConstructor">true</a><a id="13917" class="Symbol">)</a>   <a id="13921" class="Symbol">=</a>  <a id="13924" class="Number">1</a>
<a id="13926" href="../Connectives/#13874" class="Function">⊎-count</a> <a id="13934" class="Symbol">(</a><a id="13935" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="13940" href="../Connectives/#5052" class="InductiveConstructor">false</a><a id="13945" class="Symbol">)</a>  <a id="13948" class="Symbol">=</a>  <a id="13951" class="Number">2</a>
<a id="13953" href="../Connectives/#13874" class="Function">⊎-count</a> <a id="13961" class="Symbol">(</a><a id="13962" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="13967" href="../Connectives/#5089" class="InductiveConstructor">aa</a><a id="13969" class="Symbol">)</a>     <a id="13975" class="Symbol">=</a>  <a id="13978" class="Number">3</a>
<a id="13980" href="../Connectives/#13874" class="Function">⊎-count</a> <a id="13988" class="Symbol">(</a><a id="13989" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="13994" href="../Connectives/#5100" class="InductiveConstructor">bb</a><a id="13996" class="Symbol">)</a>     <a id="14002" class="Symbol">=</a>  <a id="14005" class="Number">4</a>
<a id="14007" href="../Connectives/#13874" class="Function">⊎-count</a> <a id="14015" class="Symbol">(</a><a id="14016" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="14021" href="../Connectives/#5111" class="InductiveConstructor">cc</a><a id="14023" class="Symbol">)</a>     <a id="14029" class="Symbol">=</a>  <a id="14032" class="Number">5</a>
</pre>
<p>Sum on types also shares a property with sum on numbers in that it is commutative and associative <em>up to isomorphism</em>.</p>
<h4 id="exercise--comm-recommended">Exercise <code>⊎-comm</code> (recommended)</h4>
<p>Show sum is commutative up to isomorphism.</p>
<pre class="Agda"><a id="14245" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise--assoc-practice">Exercise <code>⊎-assoc</code> (practice)</h4>
<p>Show sum is associative up to isomorphism.</p>
<pre class="Agda"><a id="14357" class="Comment">-- Your code goes here</a>
</pre>
<h2 id="false-is-empty">False is empty</h2>
False <code>⊥</code> never holds. We formalise this idea by declaring a suitable inductive type:
<pre class="Agda"><a id="14495" class="Keyword">data</a> <a id="⊥"></a><a id="14500" href="../Connectives/#14500" class="Datatype">⊥</a> <a id="14502" class="Symbol">:</a> <a id="14504" class="PrimitiveType">Set</a> <a id="14508" class="Keyword">where</a>
  <a id="14516" class="Comment">-- no clauses!</a>
</pre>
<p>There is no possible evidence that <code>⊥</code> holds.</p>
Dual to <code>⊤</code>, for <code>⊥</code> there is no introduction rule but an elimination rule. Since false never holds, knowing that it holds tells us we are in a paradoxical situation. Given evidence that <code>⊥</code> holds, we might conclude anything! This is a basic principle of logic, known in medieval times by the Latin phrase <em>ex falso</em>, and known to children through phrases such as “if pigs had wings, then I’d be the Queen of Sheba”. We formalise it as follows:
<pre class="Agda"><a id="⊥-elim"></a><a id="15034" href="../Connectives/#15034" class="Function">⊥-elim</a> <a id="15041" class="Symbol">:</a> <a id="15043" class="Symbol">∀</a> <a id="15045" class="Symbol">{</a><a id="15046" href="../Connectives/#15046" class="Bound">A</a> <a id="15048" class="Symbol">:</a> <a id="15050" class="PrimitiveType">Set</a><a id="15053" class="Symbol">}</a>
  <a id="15057" class="Symbol">→</a> <a id="15059" href="../Connectives/#14500" class="Datatype">⊥</a>
    <a id="15065" class="Comment">--</a>
  <a id="15070" class="Symbol">→</a> <a id="15072" href="../Connectives/#15046" class="Bound">A</a>
<a id="15074" href="../Connectives/#15034" class="Function">⊥-elim</a> <a id="15081" class="Symbol">()</a>
</pre>
<p>This is our first use of the <em>absurd pattern</em> <code>()</code>. Here since <code>⊥</code> is a type with no members, we indicate that it is <em>never</em> possible to match against a value of this type by using the pattern <code>()</code>.</p>
<p>The nullary case of <code>case-⊎</code> is <code>⊥-elim</code>. By analogy, we might have called it <code>case-⊥</code>, but chose to stick with the name in the standard library.</p>
The nullary case of <code>uniq-⊎</code> is <code>uniq-⊥</code>, which asserts that <code>⊥-elim</code> is equal to any arbitrary function from <code>⊥</code>:
<pre class="Agda"><a id="uniq-⊥"></a><a id="15555" href="../Connectives/#15555" class="Function">uniq-⊥</a> <a id="15562" class="Symbol">:</a> <a id="15564" class="Symbol">∀</a> <a id="15566" class="Symbol">{</a><a id="15567" href="../Connectives/#15567" class="Bound">C</a> <a id="15569" class="Symbol">:</a> <a id="15571" class="PrimitiveType">Set</a><a id="15574" class="Symbol">}</a> <a id="15576" class="Symbol">(</a><a id="15577" href="../Connectives/#15577" class="Bound">h</a> <a id="15579" class="Symbol">:</a> <a id="15581" href="../Connectives/#14500" class="Datatype">⊥</a> <a id="15583" class="Symbol">→</a> <a id="15585" href="../Connectives/#15567" class="Bound">C</a><a id="15586" class="Symbol">)</a> <a id="15588" class="Symbol">(</a><a id="15589" href="../Connectives/#15589" class="Bound">w</a> <a id="15591" class="Symbol">:</a> <a id="15593" href="../Connectives/#14500" class="Datatype">⊥</a><a id="15594" class="Symbol">)</a> <a id="15596" class="Symbol">→</a> <a id="15598" href="../Connectives/#15034" class="Function">⊥-elim</a> <a id="15605" href="../Connectives/#15589" class="Bound">w</a> <a id="15607" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="15609" href="../Connectives/#15577" class="Bound">h</a> <a id="15611" href="../Connectives/#15589" class="Bound">w</a>
<a id="15613" href="../Connectives/#15555" class="Function">uniq-⊥</a> <a id="15620" href="../Connectives/#15620" class="Bound">h</a> <a id="15622" class="Symbol">()</a>
</pre>
<p>Using the absurd pattern asserts there are no possible values for <code>w</code>, so the equation holds trivially.</p>
We refer to <code>⊥</code> as the <em>empty</em> type. And, indeed, type <code>⊥</code> has no members. For example, the following function enumerates all possible arguments of type <code>⊥</code>:
<pre class="Agda"><a id="⊥-count"></a><a id="15896" href="../Connectives/#15896" class="Function">⊥-count</a> <a id="15904" class="Symbol">:</a> <a id="15906" href="../Connectives/#14500" class="Datatype">⊥</a> <a id="15908" class="Symbol">→</a> <a id="15910" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="15912" href="../Connectives/#15896" class="Function">⊥-count</a> <a id="15920" class="Symbol">()</a>
</pre>
<p>Here again the absurd pattern <code>()</code> indicates that no value can match type <code>⊥</code>.</p>
<p>For numbers, zero is the identity of addition. Correspondingly, empty is the identity of sums <em>up to isomorphism</em>.</p>
<h4 id="exercise--identityˡ-recommended">Exercise <code>⊥-identityˡ</code> (recommended)</h4>
<p>Show empty is the left identity of sums up to isomorphism.</p>
<pre class="Agda"><a id="16230" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise--identityʳ-practice">Exercise <code>⊥-identityʳ</code> (practice)</h4>
<p>Show empty is the right identity of sums up to isomorphism.</p>
<pre class="Agda"><a id="16363" class="Comment">-- Your code goes here</a>
</pre>
<h2 id="implication">Implication is function</h2>
<p>Given two propositions <code>A</code> and <code>B</code>, the implication <code>A → B</code> holds if whenever <code>A</code> holds then <code>B</code> must also hold. We formalise implication using the function type, which has appeared throughout this book.</p>
<p>Evidence that <code>A → B</code> holds is of the form</p>
<pre><code>λ (x : A) → N</code></pre>
<p>where <code>N</code> is a term of type <code>B</code> containing as a free variable <code>x</code> of type <code>A</code>. Given a term <code>L</code> providing evidence that <code>A → B</code> holds, and a term <code>M</code> providing evidence that <code>A</code> holds, the term <code>L M</code> provides evidence that <code>B</code> holds. In other words, evidence that <code>A → B</code> holds is a function that converts evidence that <code>A</code> holds into evidence that <code>B</code> holds.</p>
Put another way, if we know that <code>A → B</code> and <code>A</code> both hold, then we may conclude that <code>B</code> holds:
<pre class="Agda"><a id="→-elim"></a><a id="17166" href="../Connectives/#17166" class="Function">→-elim</a> <a id="17173" class="Symbol">:</a> <a id="17175" class="Symbol">∀</a> <a id="17177" class="Symbol">{</a><a id="17178" href="../Connectives/#17178" class="Bound">A</a> <a id="17180" href="../Connectives/#17180" class="Bound">B</a> <a id="17182" class="Symbol">:</a> <a id="17184" class="PrimitiveType">Set</a><a id="17187" class="Symbol">}</a>
  <a id="17191" class="Symbol">→</a> <a id="17193" class="Symbol">(</a><a id="17194" href="../Connectives/#17178" class="Bound">A</a> <a id="17196" class="Symbol">→</a> <a id="17198" href="../Connectives/#17180" class="Bound">B</a><a id="17199" class="Symbol">)</a>
  <a id="17203" class="Symbol">→</a> <a id="17205" href="../Connectives/#17178" class="Bound">A</a>
    <a id="17211" class="Comment">-------</a>
  <a id="17221" class="Symbol">→</a> <a id="17223" href="../Connectives/#17180" class="Bound">B</a>
<a id="17225" href="../Connectives/#17166" class="Function">→-elim</a> <a id="17232" href="../Connectives/#17232" class="Bound">L</a> <a id="17234" href="../Connectives/#17234" class="Bound">M</a> <a id="17236" class="Symbol">=</a> <a id="17238" href="../Connectives/#17232" class="Bound">L</a> <a id="17240" href="../Connectives/#17234" class="Bound">M</a>
</pre>
<p>In medieval times, this rule was known by the name <em>modus ponens</em>. It corresponds to function application.</p>
<p>Defining a function, with a named definition or a lambda abstraction, is referred to as <em>introducing</em> a function, while applying a function is referred to as <em>eliminating</em> the function.</p>
Elimination followed by introduction is the identity:
<pre class="Agda"><a id="η-→"></a><a id="17599" href="../Connectives/#17599" class="Function">η-→</a> <a id="17603" class="Symbol">:</a> <a id="17605" class="Symbol">∀</a> <a id="17607" class="Symbol">{</a><a id="17608" href="../Connectives/#17608" class="Bound">A</a> <a id="17610" href="../Connectives/#17610" class="Bound">B</a> <a id="17612" class="Symbol">:</a> <a id="17614" class="PrimitiveType">Set</a><a id="17617" class="Symbol">}</a> <a id="17619" class="Symbol">(</a><a id="17620" href="../Connectives/#17620" class="Bound">f</a> <a id="17622" class="Symbol">:</a> <a id="17624" href="../Connectives/#17608" class="Bound">A</a> <a id="17626" class="Symbol">→</a> <a id="17628" href="../Connectives/#17610" class="Bound">B</a><a id="17629" class="Symbol">)</a> <a id="17631" class="Symbol">→</a> <a id="17633" class="Symbol">(λ</a> <a id="17636" class="Symbol">(</a><a id="17637" href="../Connectives/#17637" class="Bound">x</a> <a id="17639" class="Symbol">:</a> <a id="17641" href="../Connectives/#17608" class="Bound">A</a><a id="17642" class="Symbol">)</a> <a id="17644" class="Symbol">→</a> <a id="17646" href="../Connectives/#17620" class="Bound">f</a> <a id="17648" href="../Connectives/#17637" class="Bound">x</a><a id="17649" class="Symbol">)</a> <a id="17651" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="17653" href="../Connectives/#17620" class="Bound">f</a>
<a id="17655" href="../Connectives/#17599" class="Function">η-→</a> <a id="17659" href="../Connectives/#17659" class="Bound">f</a> <a id="17661" class="Symbol">=</a> <a id="17663" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>Implication binds less tightly than any other operator. Thus, <code>A ⊎ B → B ⊎ A</code> parses as <code>(A ⊎ B) → (B ⊎ A)</code>.</p>
<p>Given two types <code>A</code> and <code>B</code>, we refer to <code>A → B</code> as the <em>function</em> space from <code>A</code> to <code>B</code>. It is also sometimes called the <em>exponential</em>, with <code>B</code> raised to the <code>A</code> power. Among other reasons for calling it the exponential, note that if type <code>A</code> has <code>m</code> distinct members, and type <code>B</code> has <code>n</code> distinct members, then the type <code>A → B</code> has <code>nᵐ</code> distinct members. For instance, consider a type <code>Bool</code> with two members and a type <code>Tri</code> with three members, as defined earlier. Then the type <code>Bool → Tri</code> has nine (that is, three squared) members:</p>
<pre><code>λ{true → aa; false → aa}  λ{true → aa; false → bb}  λ{true → aa; false → cc}
λ{true → bb; false → aa}  λ{true → bb; false → bb}  λ{true → bb; false → cc}
λ{true → cc; false → aa}  λ{true → cc; false → bb}  λ{true → cc; false → cc}</code></pre>
For example, the following function enumerates all possible arguments of the type <code>Bool → Tri</code>:
<pre class="Agda"><a id="→-count"></a><a id="18671" href="../Connectives/#18671" class="Function">→-count</a> <a id="18679" class="Symbol">:</a> <a id="18681" class="Symbol">(</a><a id="18682" href="../Connectives/#5018" class="Datatype">Bool</a> <a id="18687" class="Symbol">→</a> <a id="18689" href="../Connectives/#5071" class="Datatype">Tri</a><a id="18692" class="Symbol">)</a> <a id="18694" class="Symbol">→</a> <a id="18696" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="18698" href="../Connectives/#18671" class="Function">→-count</a> <a id="18706" href="../Connectives/#18706" class="Bound">f</a> <a id="18708" class="Keyword">with</a> <a id="18713" href="../Connectives/#18706" class="Bound">f</a> <a id="18715" href="../Connectives/#5037" class="InductiveConstructor">true</a> <a id="18720" class="Symbol">|</a> <a id="18722" href="../Connectives/#18706" class="Bound">f</a> <a id="18724" href="../Connectives/#5052" class="InductiveConstructor">false</a>
<a id="18730" class="Symbol">...</a>          <a id="18743" class="Symbol">|</a> <a id="18745" href="../Connectives/#5089" class="InductiveConstructor">aa</a>     <a id="18752" class="Symbol">|</a> <a id="18754" href="../Connectives/#5089" class="InductiveConstructor">aa</a>      <a id="18762" class="Symbol">=</a>   <a id="18766" class="Number">1</a>
<a id="18768" class="Symbol">...</a>          <a id="18781" class="Symbol">|</a> <a id="18783" href="../Connectives/#5089" class="InductiveConstructor">aa</a>     <a id="18790" class="Symbol">|</a> <a id="18792" href="../Connectives/#5100" class="InductiveConstructor">bb</a>      <a id="18800" class="Symbol">=</a>   <a id="18804" class="Number">2</a>
<a id="18806" class="Symbol">...</a>          <a id="18819" class="Symbol">|</a> <a id="18821" href="../Connectives/#5089" class="InductiveConstructor">aa</a>     <a id="18828" class="Symbol">|</a> <a id="18830" href="../Connectives/#5111" class="InductiveConstructor">cc</a>      <a id="18838" class="Symbol">=</a>   <a id="18842" class="Number">3</a>
<a id="18844" class="Symbol">...</a>          <a id="18857" class="Symbol">|</a> <a id="18859" href="../Connectives/#5100" class="InductiveConstructor">bb</a>     <a id="18866" class="Symbol">|</a> <a id="18868" href="../Connectives/#5089" class="InductiveConstructor">aa</a>      <a id="18876" class="Symbol">=</a>   <a id="18880" class="Number">4</a>
<a id="18882" class="Symbol">...</a>          <a id="18895" class="Symbol">|</a> <a id="18897" href="../Connectives/#5100" class="InductiveConstructor">bb</a>     <a id="18904" class="Symbol">|</a> <a id="18906" href="../Connectives/#5100" class="InductiveConstructor">bb</a>      <a id="18914" class="Symbol">=</a>   <a id="18918" class="Number">5</a>
<a id="18920" class="Symbol">...</a>          <a id="18933" class="Symbol">|</a> <a id="18935" href="../Connectives/#5100" class="InductiveConstructor">bb</a>     <a id="18942" class="Symbol">|</a> <a id="18944" href="../Connectives/#5111" class="InductiveConstructor">cc</a>      <a id="18952" class="Symbol">=</a>   <a id="18956" class="Number">6</a>
<a id="18958" class="Symbol">...</a>          <a id="18971" class="Symbol">|</a> <a id="18973" href="../Connectives/#5111" class="InductiveConstructor">cc</a>     <a id="18980" class="Symbol">|</a> <a id="18982" href="../Connectives/#5089" class="InductiveConstructor">aa</a>      <a id="18990" class="Symbol">=</a>   <a id="18994" class="Number">7</a>
<a id="18996" class="Symbol">...</a>          <a id="19009" class="Symbol">|</a> <a id="19011" href="../Connectives/#5111" class="InductiveConstructor">cc</a>     <a id="19018" class="Symbol">|</a> <a id="19020" href="../Connectives/#5100" class="InductiveConstructor">bb</a>      <a id="19028" class="Symbol">=</a>   <a id="19032" class="Number">8</a>
<a id="19034" class="Symbol">...</a>          <a id="19047" class="Symbol">|</a> <a id="19049" href="../Connectives/#5111" class="InductiveConstructor">cc</a>     <a id="19056" class="Symbol">|</a> <a id="19058" href="../Connectives/#5111" class="InductiveConstructor">cc</a>      <a id="19066" class="Symbol">=</a>   <a id="19070" class="Number">9</a>
</pre>
<p>Exponential on types also share a property with exponential on numbers in that many of the standard identities for numbers carry over to the types.</p>
<p>Corresponding to the law</p>
<pre><code>(p ^ n) ^ m  ≡  p ^ (n * m)</code></pre>
<p>we have the isomorphism</p>
<pre><code>A → (B → C)  ≃  (A × B) → C</code></pre>
Both types can be viewed as functions that given evidence that <code>A</code> holds and evidence that <code>B</code> holds can return evidence that <code>C</code> holds. This isomorphism sometimes goes by the name <em>currying</em>. The proof of the right inverse requires extensionality:
<pre class="Agda"><a id="currying"></a><a id="19596" href="../Connectives/#19596" class="Function">currying</a> <a id="19605" class="Symbol">:</a> <a id="19607" class="Symbol">∀</a> <a id="19609" class="Symbol">{</a><a id="19610" href="../Connectives/#19610" class="Bound">A</a> <a id="19612" href="../Connectives/#19612" class="Bound">B</a> <a id="19614" href="../Connectives/#19614" class="Bound">C</a> <a id="19616" class="Symbol">:</a> <a id="19618" class="PrimitiveType">Set</a><a id="19621" class="Symbol">}</a> <a id="19623" class="Symbol">→</a> <a id="19625" class="Symbol">(</a><a id="19626" href="../Connectives/#19610" class="Bound">A</a> <a id="19628" class="Symbol">→</a> <a id="19630" href="../Connectives/#19612" class="Bound">B</a> <a id="19632" class="Symbol">→</a> <a id="19634" href="../Connectives/#19614" class="Bound">C</a><a id="19635" class="Symbol">)</a> <a id="19637" href="../Isomorphism/#4329" class="Record Operator">≃</a> <a id="19639" class="Symbol">(</a><a id="19640" href="../Connectives/#19610" class="Bound">A</a> <a id="19642" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="19644" href="../Connectives/#19612" class="Bound">B</a> <a id="19646" class="Symbol">→</a> <a id="19648" href="../Connectives/#19614" class="Bound">C</a><a id="19649" class="Symbol">)</a>
<a id="19651" href="../Connectives/#19596" class="Function">currying</a> <a id="19660" class="Symbol">=</a>
  <a id="19664" class="Keyword">record</a>
    <a id="19675" class="Symbol">{</a> <a id="19677" href="../Isomorphism/#4369" class="Field">to</a>      <a id="19685" class="Symbol">=</a>  <a id="19688" class="Symbol">λ{</a> <a id="19691" href="../Connectives/#19691" class="Bound">f</a> <a id="19693" class="Symbol">→</a> <a id="19695" class="Symbol">λ{</a> <a id="19698" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="19700" href="../Connectives/#19700" class="Bound">x</a> <a id="19702" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="19704" href="../Connectives/#19704" class="Bound">y</a> <a id="19706" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="19708" class="Symbol">→</a> <a id="19710" href="../Connectives/#19691" class="Bound">f</a> <a id="19712" href="../Connectives/#19700" class="Bound">x</a> <a id="19714" href="../Connectives/#19704" class="Bound">y</a> <a id="19716" class="Symbol">}}</a>
    <a id="19723" class="Symbol">;</a> <a id="19725" href="../Isomorphism/#4386" class="Field">from</a>    <a id="19733" class="Symbol">=</a>  <a id="19736" class="Symbol">λ{</a> <a id="19739" href="../Connectives/#19739" class="Bound">g</a> <a id="19741" class="Symbol">→</a> <a id="19743" class="Symbol">λ{</a> <a id="19746" href="../Connectives/#19746" class="Bound">x</a> <a id="19748" class="Symbol">→</a> <a id="19750" class="Symbol">λ{</a> <a id="19753" href="../Connectives/#19753" class="Bound">y</a> <a id="19755" class="Symbol">→</a> <a id="19757" href="../Connectives/#19739" class="Bound">g</a> <a id="19759" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="19761" href="../Connectives/#19746" class="Bound">x</a> <a id="19763" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="19765" href="../Connectives/#19753" class="Bound">y</a> <a id="19767" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="19769" class="Symbol">}}}</a>
    <a id="19777" class="Symbol">;</a> <a id="19779" href="../Isomorphism/#4403" class="Field">from∘to</a> <a id="19787" class="Symbol">=</a>  <a id="19790" class="Symbol">λ{</a> <a id="19793" href="../Connectives/#19793" class="Bound">f</a> <a id="19795" class="Symbol">→</a> <a id="19797" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="19802" class="Symbol">}</a>
    <a id="19808" class="Symbol">;</a> <a id="19810" href="../Isomorphism/#4445" class="Field">to∘from</a> <a id="19818" class="Symbol">=</a>  <a id="19821" class="Symbol">λ{</a> <a id="19824" href="../Connectives/#19824" class="Bound">g</a> <a id="19826" class="Symbol">→</a> <a id="19828" href="../Isomorphism/#2666" class="Postulate">extensionality</a> <a id="19843" class="Symbol">λ{</a> <a id="19846" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="19848" href="../Connectives/#19848" class="Bound">x</a> <a id="19850" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="19852" href="../Connectives/#19852" class="Bound">y</a> <a id="19854" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="19856" class="Symbol">→</a> <a id="19858" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="19863" class="Symbol">}}</a>
    <a id="19870" class="Symbol">}</a>
</pre>
<p>Currying tells us that instead of a function that takes a pair of arguments, we can have a function that takes the first argument and returns a function that expects the second argument. Thus, for instance, our way of writing addition</p>
<pre><code>_+_ : ℕ → ℕ → ℕ</code></pre>
<p>is isomorphic to a function that accepts a pair of arguments:</p>
<pre><code>_+′_ : (ℕ × ℕ) → ℕ</code></pre>
<p>Agda is optimised for currying, so <code>2 + 3</code> abbreviates <code>_+_ 2 3</code>. In a language optimised for pairing, we would instead take <code>2 +′ 3</code> as an abbreviation for <code>_+′_ ⟨ 2 , 3 ⟩</code>.</p>
<p>Corresponding to the law</p>
<pre><code>p ^ (n + m) = (p ^ n) * (p ^ m)</code></pre>
<p>we have the isomorphism:</p>
<pre><code>(A ⊎ B) → C  ≃  (A → C) × (B → C)</code></pre>
That is, the assertion that if either <code>A</code> holds or <code>B</code> holds then <code>C</code> holds is the same as the assertion that if <code>A</code> holds then <code>C</code> holds and if <code>B</code> holds then <code>C</code> holds. The proof of the left inverse requires extensionality:
<pre class="Agda"><a id="→-distrib-⊎"></a><a id="20757" href="../Connectives/#20757" class="Function">→-distrib-⊎</a> <a id="20769" class="Symbol">:</a> <a id="20771" class="Symbol">∀</a> <a id="20773" class="Symbol">{</a><a id="20774" href="../Connectives/#20774" class="Bound">A</a> <a id="20776" href="../Connectives/#20776" class="Bound">B</a> <a id="20778" href="../Connectives/#20778" class="Bound">C</a> <a id="20780" class="Symbol">:</a> <a id="20782" class="PrimitiveType">Set</a><a id="20785" class="Symbol">}</a> <a id="20787" class="Symbol">→</a> <a id="20789" class="Symbol">(</a><a id="20790" href="../Connectives/#20774" class="Bound">A</a> <a id="20792" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="20794" href="../Connectives/#20776" class="Bound">B</a> <a id="20796" class="Symbol">→</a> <a id="20798" href="../Connectives/#20778" class="Bound">C</a><a id="20799" class="Symbol">)</a> <a id="20801" href="../Isomorphism/#4329" class="Record Operator">≃</a> <a id="20803" class="Symbol">((</a><a id="20805" href="../Connectives/#20774" class="Bound">A</a> <a id="20807" class="Symbol">→</a> <a id="20809" href="../Connectives/#20778" class="Bound">C</a><a id="20810" class="Symbol">)</a> <a id="20812" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="20814" class="Symbol">(</a><a id="20815" href="../Connectives/#20776" class="Bound">B</a> <a id="20817" class="Symbol">→</a> <a id="20819" href="../Connectives/#20778" class="Bound">C</a><a id="20820" class="Symbol">))</a>
<a id="20823" href="../Connectives/#20757" class="Function">→-distrib-⊎</a> <a id="20835" class="Symbol">=</a>
  <a id="20839" class="Keyword">record</a>
    <a id="20850" class="Symbol">{</a> <a id="20852" href="../Isomorphism/#4369" class="Field">to</a>      <a id="20860" class="Symbol">=</a> <a id="20862" class="Symbol">λ{</a> <a id="20865" href="../Connectives/#20865" class="Bound">f</a> <a id="20867" class="Symbol">→</a> <a id="20869" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="20871" href="../Connectives/#20865" class="Bound">f</a> <a id="20873" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">∘</a> <a id="20875" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="20880" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="20882" href="../Connectives/#20865" class="Bound">f</a> <a id="20884" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">∘</a> <a id="20886" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="20891" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="20893" class="Symbol">}</a>
    <a id="20899" class="Symbol">;</a> <a id="20901" href="../Isomorphism/#4386" class="Field">from</a>    <a id="20909" class="Symbol">=</a> <a id="20911" class="Symbol">λ{</a> <a id="20914" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="20916" href="../Connectives/#20916" class="Bound">g</a> <a id="20918" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="20920" href="../Connectives/#20920" class="Bound">h</a> <a id="20922" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="20924" class="Symbol">→</a> <a id="20926" class="Symbol">λ{</a> <a id="20929" class="Symbol">(</a><a id="20930" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="20935" href="../Connectives/#20935" class="Bound">x</a><a id="20936" class="Symbol">)</a> <a id="20938" class="Symbol">→</a> <a id="20940" href="../Connectives/#20916" class="Bound">g</a> <a id="20942" href="../Connectives/#20935" class="Bound">x</a> <a id="20944" class="Symbol">;</a> <a id="20946" class="Symbol">(</a><a id="20947" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="20952" href="../Connectives/#20952" class="Bound">y</a><a id="20953" class="Symbol">)</a> <a id="20955" class="Symbol">→</a> <a id="20957" href="../Connectives/#20920" class="Bound">h</a> <a id="20959" href="../Connectives/#20952" class="Bound">y</a> <a id="20961" class="Symbol">}</a> <a id="20963" class="Symbol">}</a>
    <a id="20969" class="Symbol">;</a> <a id="20971" href="../Isomorphism/#4403" class="Field">from∘to</a> <a id="20979" class="Symbol">=</a> <a id="20981" class="Symbol">λ{</a> <a id="20984" href="../Connectives/#20984" class="Bound">f</a> <a id="20986" class="Symbol">→</a> <a id="20988" href="../Isomorphism/#2666" class="Postulate">extensionality</a> <a id="21003" class="Symbol">λ{</a> <a id="21006" class="Symbol">(</a><a id="21007" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="21012" href="../Connectives/#21012" class="Bound">x</a><a id="21013" class="Symbol">)</a> <a id="21015" class="Symbol">→</a> <a id="21017" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="21022" class="Symbol">;</a> <a id="21024" class="Symbol">(</a><a id="21025" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="21030" href="../Connectives/#21030" class="Bound">y</a><a id="21031" class="Symbol">)</a> <a id="21033" class="Symbol">→</a> <a id="21035" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="21040" class="Symbol">}</a> <a id="21042" class="Symbol">}</a>
    <a id="21048" class="Symbol">;</a> <a id="21050" href="../Isomorphism/#4445" class="Field">to∘from</a> <a id="21058" class="Symbol">=</a> <a id="21060" class="Symbol">λ{</a> <a id="21063" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="21065" href="../Connectives/#21065" class="Bound">g</a> <a id="21067" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="21069" href="../Connectives/#21069" class="Bound">h</a> <a id="21071" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="21073" class="Symbol">→</a> <a id="21075" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="21080" class="Symbol">}</a>
    <a id="21086" class="Symbol">}</a>
</pre>
<p>Corresponding to the law</p>
<pre><code>(p * n) ^ m = (p ^ m) * (n ^ m)</code></pre>
<p>we have the isomorphism:</p>
<pre><code>A → B × C  ≃  (A → B) × (A → C)</code></pre>
That is, the assertion that if <code>A</code> holds then <code>B</code> holds and <code>C</code> holds is the same as the assertion that if <code>A</code> holds then <code>B</code> holds and if <code>A</code> holds then <code>C</code> holds. The proof of left inverse requires both extensionality and the rule <code>η-×</code> for products:
<pre class="Agda"><a id="→-distrib-×"></a><a id="21477" href="../Connectives/#21477" class="Function">→-distrib-×</a> <a id="21489" class="Symbol">:</a> <a id="21491" class="Symbol">∀</a> <a id="21493" class="Symbol">{</a><a id="21494" href="../Connectives/#21494" class="Bound">A</a> <a id="21496" href="../Connectives/#21496" class="Bound">B</a> <a id="21498" href="../Connectives/#21498" class="Bound">C</a> <a id="21500" class="Symbol">:</a> <a id="21502" class="PrimitiveType">Set</a><a id="21505" class="Symbol">}</a> <a id="21507" class="Symbol">→</a> <a id="21509" class="Symbol">(</a><a id="21510" href="../Connectives/#21494" class="Bound">A</a> <a id="21512" class="Symbol">→</a> <a id="21514" href="../Connectives/#21496" class="Bound">B</a> <a id="21516" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="21518" href="../Connectives/#21498" class="Bound">C</a><a id="21519" class="Symbol">)</a> <a id="21521" href="../Isomorphism/#4329" class="Record Operator">≃</a> <a id="21523" class="Symbol">(</a><a id="21524" href="../Connectives/#21494" class="Bound">A</a> <a id="21526" class="Symbol">→</a> <a id="21528" href="../Connectives/#21496" class="Bound">B</a><a id="21529" class="Symbol">)</a> <a id="21531" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="21533" class="Symbol">(</a><a id="21534" href="../Connectives/#21494" class="Bound">A</a> <a id="21536" class="Symbol">→</a> <a id="21538" href="../Connectives/#21498" class="Bound">C</a><a id="21539" class="Symbol">)</a>
<a id="21541" href="../Connectives/#21477" class="Function">→-distrib-×</a> <a id="21553" class="Symbol">=</a>
  <a id="21557" class="Keyword">record</a>
    <a id="21568" class="Symbol">{</a> <a id="21570" href="../Isomorphism/#4369" class="Field">to</a>      <a id="21578" class="Symbol">=</a> <a id="21580" class="Symbol">λ{</a> <a id="21583" href="../Connectives/#21583" class="Bound">f</a> <a id="21585" class="Symbol">→</a> <a id="21587" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="21589" href="../Connectives/#1607" class="Function">proj₁</a> <a id="21595" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">∘</a> <a id="21597" href="../Connectives/#21583" class="Bound">f</a> <a id="21599" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="21601" href="../Connectives/#1676" class="Function">proj₂</a> <a id="21607" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">∘</a> <a id="21609" href="../Connectives/#21583" class="Bound">f</a> <a id="21611" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="21613" class="Symbol">}</a>
    <a id="21619" class="Symbol">;</a> <a id="21621" href="../Isomorphism/#4386" class="Field">from</a>    <a id="21629" class="Symbol">=</a> <a id="21631" class="Symbol">λ{</a> <a id="21634" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="21636" href="../Connectives/#21636" class="Bound">g</a> <a id="21638" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="21640" href="../Connectives/#21640" class="Bound">h</a> <a id="21642" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="21644" class="Symbol">→</a> <a id="21646" class="Symbol">λ</a> <a id="21648" href="../Connectives/#21648" class="Bound">x</a> <a id="21650" class="Symbol">→</a> <a id="21652" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="21654" href="../Connectives/#21636" class="Bound">g</a> <a id="21656" href="../Connectives/#21648" class="Bound">x</a> <a id="21658" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="21660" href="../Connectives/#21640" class="Bound">h</a> <a id="21662" href="../Connectives/#21648" class="Bound">x</a> <a id="21664" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="21666" class="Symbol">}</a>
    <a id="21672" class="Symbol">;</a> <a id="21674" href="../Isomorphism/#4403" class="Field">from∘to</a> <a id="21682" class="Symbol">=</a> <a id="21684" class="Symbol">λ{</a> <a id="21687" href="../Connectives/#21687" class="Bound">f</a> <a id="21689" class="Symbol">→</a> <a id="21691" href="../Isomorphism/#2666" class="Postulate">extensionality</a> <a id="21706" class="Symbol">λ{</a> <a id="21709" href="../Connectives/#21709" class="Bound">x</a> <a id="21711" class="Symbol">→</a> <a id="21713" href="../Connectives/#3107" class="Function">η-×</a> <a id="21717" class="Symbol">(</a><a id="21718" href="../Connectives/#21687" class="Bound">f</a> <a id="21720" href="../Connectives/#21709" class="Bound">x</a><a id="21721" class="Symbol">)</a> <a id="21723" class="Symbol">}</a> <a id="21725" class="Symbol">}</a>
    <a id="21731" class="Symbol">;</a> <a id="21733" href="../Isomorphism/#4445" class="Field">to∘from</a> <a id="21741" class="Symbol">=</a> <a id="21743" class="Symbol">λ{</a> <a id="21746" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="21748" href="../Connectives/#21748" class="Bound">g</a> <a id="21750" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="21752" href="../Connectives/#21752" class="Bound">h</a> <a id="21754" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="21756" class="Symbol">→</a> <a id="21758" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="21763" class="Symbol">}</a>
    <a id="21769" class="Symbol">}</a>
</pre>
<h2 id="distribution">Distribution</h2>
Products distribute over sum, up to isomorphism. The code to validate this fact is similar in structure to our previous results:
<pre class="Agda"><a id="×-distrib-⊎"></a><a id="21928" href="../Connectives/#21928" class="Function">×-distrib-⊎</a> <a id="21940" class="Symbol">:</a> <a id="21942" class="Symbol">∀</a> <a id="21944" class="Symbol">{</a><a id="21945" href="../Connectives/#21945" class="Bound">A</a> <a id="21947" href="../Connectives/#21947" class="Bound">B</a> <a id="21949" href="../Connectives/#21949" class="Bound">C</a> <a id="21951" class="Symbol">:</a> <a id="21953" class="PrimitiveType">Set</a><a id="21956" class="Symbol">}</a> <a id="21958" class="Symbol">→</a> <a id="21960" class="Symbol">(</a><a id="21961" href="../Connectives/#21945" class="Bound">A</a> <a id="21963" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="21965" href="../Connectives/#21947" class="Bound">B</a><a id="21966" class="Symbol">)</a> <a id="21968" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="21970" href="../Connectives/#21949" class="Bound">C</a> <a id="21972" href="../Isomorphism/#4329" class="Record Operator">≃</a> <a id="21974" class="Symbol">(</a><a id="21975" href="../Connectives/#21945" class="Bound">A</a> <a id="21977" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="21979" href="../Connectives/#21949" class="Bound">C</a><a id="21980" class="Symbol">)</a> <a id="21982" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="21984" class="Symbol">(</a><a id="21985" href="../Connectives/#21947" class="Bound">B</a> <a id="21987" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="21989" href="../Connectives/#21949" class="Bound">C</a><a id="21990" class="Symbol">)</a>
<a id="21992" href="../Connectives/#21928" class="Function">×-distrib-⊎</a> <a id="22004" class="Symbol">=</a>
  <a id="22008" class="Keyword">record</a>
    <a id="22019" class="Symbol">{</a> <a id="22021" href="../Isomorphism/#4369" class="Field">to</a>      <a id="22029" class="Symbol">=</a> <a id="22031" class="Symbol">λ{</a> <a id="22034" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22036" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="22041" href="../Connectives/#22041" class="Bound">x</a> <a id="22043" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22045" href="../Connectives/#22045" class="Bound">z</a> <a id="22047" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="22049" class="Symbol">→</a> <a id="22051" class="Symbol">(</a><a id="22052" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="22057" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22059" href="../Connectives/#22041" class="Bound">x</a> <a id="22061" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22063" href="../Connectives/#22045" class="Bound">z</a> <a id="22065" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a><a id="22066" class="Symbol">)</a>
                 <a id="22085" class="Symbol">;</a> <a id="22087" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22089" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="22094" href="../Connectives/#22094" class="Bound">y</a> <a id="22096" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22098" href="../Connectives/#22098" class="Bound">z</a> <a id="22100" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="22102" class="Symbol">→</a> <a id="22104" class="Symbol">(</a><a id="22105" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="22110" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22112" href="../Connectives/#22094" class="Bound">y</a> <a id="22114" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22116" href="../Connectives/#22098" class="Bound">z</a> <a id="22118" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a><a id="22119" class="Symbol">)</a>
                 <a id="22138" class="Symbol">}</a>
    <a id="22144" class="Symbol">;</a> <a id="22146" href="../Isomorphism/#4386" class="Field">from</a>    <a id="22154" class="Symbol">=</a> <a id="22156" class="Symbol">λ{</a> <a id="22159" class="Symbol">(</a><a id="22160" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="22165" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22167" href="../Connectives/#22167" class="Bound">x</a> <a id="22169" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22171" href="../Connectives/#22171" class="Bound">z</a> <a id="22173" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a><a id="22174" class="Symbol">)</a> <a id="22176" class="Symbol">→</a> <a id="22178" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22180" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="22185" href="../Connectives/#22167" class="Bound">x</a> <a id="22187" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22189" href="../Connectives/#22171" class="Bound">z</a> <a id="22191" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>
                 <a id="22210" class="Symbol">;</a> <a id="22212" class="Symbol">(</a><a id="22213" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="22218" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22220" href="../Connectives/#22220" class="Bound">y</a> <a id="22222" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22224" href="../Connectives/#22224" class="Bound">z</a> <a id="22226" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a><a id="22227" class="Symbol">)</a> <a id="22229" class="Symbol">→</a> <a id="22231" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22233" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="22238" href="../Connectives/#22220" class="Bound">y</a> <a id="22240" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22242" href="../Connectives/#22224" class="Bound">z</a> <a id="22244" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>
                 <a id="22263" class="Symbol">}</a>
    <a id="22269" class="Symbol">;</a> <a id="22271" href="../Isomorphism/#4403" class="Field">from∘to</a> <a id="22279" class="Symbol">=</a> <a id="22281" class="Symbol">λ{</a> <a id="22284" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22286" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="22291" href="../Connectives/#22291" class="Bound">x</a> <a id="22293" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22295" href="../Connectives/#22295" class="Bound">z</a> <a id="22297" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="22299" class="Symbol">→</a> <a id="22301" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
                 <a id="22323" class="Symbol">;</a> <a id="22325" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22327" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="22332" href="../Connectives/#22332" class="Bound">y</a> <a id="22334" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22336" href="../Connectives/#22336" class="Bound">z</a> <a id="22338" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="22340" class="Symbol">→</a> <a id="22342" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
                 <a id="22364" class="Symbol">}</a>
    <a id="22370" class="Symbol">;</a> <a id="22372" href="../Isomorphism/#4445" class="Field">to∘from</a> <a id="22380" class="Symbol">=</a> <a id="22382" class="Symbol">λ{</a> <a id="22385" class="Symbol">(</a><a id="22386" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="22391" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22393" href="../Connectives/#22393" class="Bound">x</a> <a id="22395" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22397" href="../Connectives/#22397" class="Bound">z</a> <a id="22399" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a><a id="22400" class="Symbol">)</a> <a id="22402" class="Symbol">→</a> <a id="22404" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
                 <a id="22426" class="Symbol">;</a> <a id="22428" class="Symbol">(</a><a id="22429" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="22434" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22436" href="../Connectives/#22436" class="Bound">y</a> <a id="22438" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22440" href="../Connectives/#22440" class="Bound">z</a> <a id="22442" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a><a id="22443" class="Symbol">)</a> <a id="22445" class="Symbol">→</a> <a id="22447" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
                 <a id="22469" class="Symbol">}</a>
    <a id="22475" class="Symbol">}</a>
</pre>
Sums do not distribute over products up to isomorphism, but it is an embedding:
<pre class="Agda"><a id="⊎-distrib-×"></a><a id="22566" href="../Connectives/#22566" class="Function">⊎-distrib-×</a> <a id="22578" class="Symbol">:</a> <a id="22580" class="Symbol">∀</a> <a id="22582" class="Symbol">{</a><a id="22583" href="../Connectives/#22583" class="Bound">A</a> <a id="22585" href="../Connectives/#22585" class="Bound">B</a> <a id="22587" href="../Connectives/#22587" class="Bound">C</a> <a id="22589" class="Symbol">:</a> <a id="22591" class="PrimitiveType">Set</a><a id="22594" class="Symbol">}</a> <a id="22596" class="Symbol">→</a> <a id="22598" class="Symbol">(</a><a id="22599" href="../Connectives/#22583" class="Bound">A</a> <a id="22601" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="22603" href="../Connectives/#22585" class="Bound">B</a><a id="22604" class="Symbol">)</a> <a id="22606" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="22608" href="../Connectives/#22587" class="Bound">C</a> <a id="22610" href="../Isomorphism/#9227" class="Record Operator">≲</a> <a id="22612" class="Symbol">(</a><a id="22613" href="../Connectives/#22583" class="Bound">A</a> <a id="22615" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="22617" href="../Connectives/#22587" class="Bound">C</a><a id="22618" class="Symbol">)</a> <a id="22620" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="22622" class="Symbol">(</a><a id="22623" href="../Connectives/#22585" class="Bound">B</a> <a id="22625" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="22627" href="../Connectives/#22587" class="Bound">C</a><a id="22628" class="Symbol">)</a>
<a id="22630" href="../Connectives/#22566" class="Function">⊎-distrib-×</a> <a id="22642" class="Symbol">=</a>
  <a id="22646" class="Keyword">record</a>
    <a id="22657" class="Symbol">{</a> <a id="22659" href="../Isomorphism/#9267" class="Field">to</a>      <a id="22667" class="Symbol">=</a> <a id="22669" class="Symbol">λ{</a> <a id="22672" class="Symbol">(</a><a id="22673" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="22678" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22680" href="../Connectives/#22680" class="Bound">x</a> <a id="22682" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22684" href="../Connectives/#22684" class="Bound">y</a> <a id="22686" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a><a id="22687" class="Symbol">)</a> <a id="22689" class="Symbol">→</a> <a id="22691" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22693" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="22698" href="../Connectives/#22680" class="Bound">x</a> <a id="22700" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22702" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="22707" href="../Connectives/#22684" class="Bound">y</a> <a id="22709" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>
                 <a id="22728" class="Symbol">;</a> <a id="22730" class="Symbol">(</a><a id="22731" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="22736" href="../Connectives/#22736" class="Bound">z</a><a id="22737" class="Symbol">)</a>         <a id="22747" class="Symbol">→</a> <a id="22749" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22751" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="22756" href="../Connectives/#22736" class="Bound">z</a> <a id="22758" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22760" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="22765" href="../Connectives/#22736" class="Bound">z</a> <a id="22767" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a>
                 <a id="22786" class="Symbol">}</a>
    <a id="22792" class="Symbol">;</a> <a id="22794" href="../Isomorphism/#9287" class="Field">from</a>    <a id="22802" class="Symbol">=</a> <a id="22804" class="Symbol">λ{</a> <a id="22807" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22809" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="22814" href="../Connectives/#22814" class="Bound">x</a> <a id="22816" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22818" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="22823" href="../Connectives/#22823" class="Bound">y</a> <a id="22825" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="22827" class="Symbol">→</a> <a id="22829" class="Symbol">(</a><a id="22830" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="22835" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22837" href="../Connectives/#22814" class="Bound">x</a> <a id="22839" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22841" href="../Connectives/#22823" class="Bound">y</a> <a id="22843" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a><a id="22844" class="Symbol">)</a>
                 <a id="22863" class="Symbol">;</a> <a id="22865" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22867" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="22872" href="../Connectives/#22872" class="Bound">x</a> <a id="22874" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22876" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="22881" href="../Connectives/#22881" class="Bound">z</a> <a id="22883" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="22885" class="Symbol">→</a> <a id="22887" class="Symbol">(</a><a id="22888" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="22893" href="../Connectives/#22881" class="Bound">z</a><a id="22894" class="Symbol">)</a>
                 <a id="22913" class="Symbol">;</a> <a id="22915" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22917" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="22922" href="../Connectives/#22922" class="Bound">z</a> <a id="22924" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22926" class="Symbol">_</a>      <a id="22933" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a> <a id="22935" class="Symbol">→</a> <a id="22937" class="Symbol">(</a><a id="22938" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="22943" href="../Connectives/#22922" class="Bound">z</a><a id="22944" class="Symbol">)</a>
                 <a id="22963" class="Symbol">}</a>
    <a id="22969" class="Symbol">;</a> <a id="22971" href="../Isomorphism/#9307" class="Field">from∘to</a> <a id="22979" class="Symbol">=</a> <a id="22981" class="Symbol">λ{</a> <a id="22984" class="Symbol">(</a><a id="22985" href="../Connectives/#11282" class="InductiveConstructor">inj₁</a> <a id="22990" href="../Connectives/#1323" class="InductiveConstructor Operator">⟨</a> <a id="22992" href="../Connectives/#22992" class="Bound">x</a> <a id="22994" href="../Connectives/#1323" class="InductiveConstructor Operator">,</a> <a id="22996" href="../Connectives/#22996" class="Bound">y</a> <a id="22998" href="../Connectives/#1323" class="InductiveConstructor Operator">⟩</a><a id="22999" class="Symbol">)</a> <a id="23001" class="Symbol">→</a> <a id="23003" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
                 <a id="23025" class="Symbol">;</a> <a id="23027" class="Symbol">(</a><a id="23028" href="../Connectives/#11324" class="InductiveConstructor">inj₂</a> <a id="23033" href="../Connectives/#23033" class="Bound">z</a><a id="23034" class="Symbol">)</a>         <a id="23044" class="Symbol">→</a> <a id="23046" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
                 <a id="23068" class="Symbol">}</a>
    <a id="23074" class="Symbol">}</a>
</pre>
<p>Note that there is a choice in how we write the <code>from</code> function. As given, it takes <code>⟨ inj₂ z , inj₂ z′ ⟩</code> to <code>inj₂ z</code>, but it is easy to write a variant that instead returns <code>inj₂ z′</code>. We have an embedding rather than an isomorphism because the <code>from</code> function must discard either <code>z</code> or <code>z′</code> in this case.</p>
<p>In the usual approach to logic, both of the distribution laws are given as equivalences, where each side implies the other:</p>
<pre><code>A × (B ⊎ C) ⇔ (A × B) ⊎ (A × C)
A ⊎ (B × C) ⇔ (A ⊎ B) × (A ⊎ C)</code></pre>
<p>But when we consider the functions that provide evidence for these implications, then the first corresponds to an isomorphism while the second only corresponds to an embedding, revealing a sense in which one of these laws is “more true” than the other.</p>
<h4 id="exercise--weak--recommended">Exercise <code>⊎-weak-×</code> (recommended)</h4>
Show that the following property holds:
<pre class="Agda"><a id="23927" class="Keyword">postulate</a>
  <a id="⊎-weak-×"></a><a id="23939" href="../Connectives/#23939" class="Postulate">⊎-weak-×</a> <a id="23948" class="Symbol">:</a> <a id="23950" class="Symbol">∀</a> <a id="23952" class="Symbol">{</a><a id="23953" href="../Connectives/#23953" class="Bound">A</a> <a id="23955" href="../Connectives/#23955" class="Bound">B</a> <a id="23957" href="../Connectives/#23957" class="Bound">C</a> <a id="23959" class="Symbol">:</a> <a id="23961" class="PrimitiveType">Set</a><a id="23964" class="Symbol">}</a> <a id="23966" class="Symbol">→</a> <a id="23968" class="Symbol">(</a><a id="23969" href="../Connectives/#23953" class="Bound">A</a> <a id="23971" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="23973" href="../Connectives/#23955" class="Bound">B</a><a id="23974" class="Symbol">)</a> <a id="23976" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="23978" href="../Connectives/#23957" class="Bound">C</a> <a id="23980" class="Symbol">→</a> <a id="23982" href="../Connectives/#23953" class="Bound">A</a> <a id="23984" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="23986" class="Symbol">(</a><a id="23987" href="../Connectives/#23955" class="Bound">B</a> <a id="23989" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="23991" href="../Connectives/#23957" class="Bound">C</a><a id="23992" class="Symbol">)</a>
</pre>
<p>This is called a <em>weak distributive law</em>. Give the corresponding distributive law, and explain how it relates to the weak version.</p>
<pre class="Agda"><a id="24134" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise--implies--practice">Exercise <code>⊎×-implies-×⊎</code> (practice)</h4>
Show that a disjunct of conjuncts implies a conjunct of disjuncts:
<pre class="Agda"><a id="24276" class="Keyword">postulate</a>
  <a id="⊎×-implies-×⊎"></a><a id="24288" href="../Connectives/#24288" class="Postulate">⊎×-implies-×⊎</a> <a id="24302" class="Symbol">:</a> <a id="24304" class="Symbol">∀</a> <a id="24306" class="Symbol">{</a><a id="24307" href="../Connectives/#24307" class="Bound">A</a> <a id="24309" href="../Connectives/#24309" class="Bound">B</a> <a id="24311" href="../Connectives/#24311" class="Bound">C</a> <a id="24313" href="../Connectives/#24313" class="Bound">D</a> <a id="24315" class="Symbol">:</a> <a id="24317" class="PrimitiveType">Set</a><a id="24320" class="Symbol">}</a> <a id="24322" class="Symbol">→</a> <a id="24324" class="Symbol">(</a><a id="24325" href="../Connectives/#24307" class="Bound">A</a> <a id="24327" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="24329" href="../Connectives/#24309" class="Bound">B</a><a id="24330" class="Symbol">)</a> <a id="24332" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="24334" class="Symbol">(</a><a id="24335" href="../Connectives/#24311" class="Bound">C</a> <a id="24337" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="24339" href="../Connectives/#24313" class="Bound">D</a><a id="24340" class="Symbol">)</a> <a id="24342" class="Symbol">→</a> <a id="24344" class="Symbol">(</a><a id="24345" href="../Connectives/#24307" class="Bound">A</a> <a id="24347" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="24349" href="../Connectives/#24311" class="Bound">C</a><a id="24350" class="Symbol">)</a> <a id="24352" href="../Connectives/#1292" class="Datatype Operator">×</a> <a id="24354" class="Symbol">(</a><a id="24355" href="../Connectives/#24309" class="Bound">B</a> <a id="24357" href="../Connectives/#11251" class="Datatype Operator">⊎</a> <a id="24359" href="../Connectives/#24313" class="Bound">D</a><a id="24360" class="Symbol">)</a>
</pre>
<p>Does the converse hold? If so, prove; if not, give a counterexample.</p>
<pre class="Agda"><a id="24440" class="Comment">-- Your code goes here</a>
</pre>
<h2 id="standard-library">Standard library</h2>
Definitions similar to those in this chapter can be found in the standard library:
<pre class="Agda"><a id="24577" class="Keyword">import</a> <a id="24584" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html" class="Module">Data.Product</a> <a id="24597" class="Keyword">using</a> <a id="24603" class="Symbol">(</a><a id="24604" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1167" class="Function Operator">_×_</a><a id="24607" class="Symbol">;</a> <a id="24609" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="24614" class="Symbol">;</a> <a id="24616" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Sigma.html#264" class="Field">proj₂</a><a id="24621" class="Symbol">)</a> <a id="24623" class="Keyword">renaming</a> <a id="24632" class="Symbol">(</a><a id="24633" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a> <a id="24637" class="Symbol">to</a> <a id="_,_"></a><a id="24640" href="../Connectives/#24640" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="24645" class="Symbol">)</a>
<a id="24647" class="Keyword">import</a> <a id="24654" href="https://agda.github.io/agda-stdlib/v1.3/Data.Unit.html" class="Module">Data.Unit</a> <a id="24664" class="Keyword">using</a> <a id="24670" class="Symbol">(</a><a id="24671" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Unit.html#164" class="Record">⊤</a><a id="24672" class="Symbol">;</a> <a id="24674" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a><a id="24676" class="Symbol">)</a>
<a id="24678" class="Keyword">import</a> <a id="24685" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.html" class="Module">Data.Sum</a> <a id="24694" class="Keyword">using</a> <a id="24700" class="Symbol">(</a><a id="24701" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#728" class="Datatype Operator">_⊎_</a><a id="24704" class="Symbol">;</a> <a id="24706" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#778" class="InductiveConstructor">inj₁</a><a id="24710" class="Symbol">;</a> <a id="24712" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#803" class="InductiveConstructor">inj₂</a><a id="24716" class="Symbol">)</a> <a id="24718" class="Keyword">renaming</a> <a id="24727" class="Symbol">(</a><a id="24728" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#914" class="Function Operator">[_,_]</a> <a id="24734" class="Symbol">to</a> <a id="[_,_]"></a><a id="24737" href="../Connectives/#24737" class="Function Operator">case-⊎</a><a id="24743" class="Symbol">)</a>
<a id="24745" class="Keyword">import</a> <a id="24752" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html" class="Module">Data.Empty</a> <a id="24763" class="Keyword">using</a> <a id="24769" class="Symbol">(</a><a id="24770" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html#526" class="Datatype">⊥</a><a id="24771" class="Symbol">;</a> <a id="24773" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html#628" class="Function">⊥-elim</a><a id="24779" class="Symbol">)</a>
<a id="24781" class="Keyword">import</a> <a id="24788" href="https://agda.github.io/agda-stdlib/v1.3/Function.Equivalence.html" class="Module">Function.Equivalence</a> <a id="24809" class="Keyword">using</a> <a id="24815" class="Symbol">(</a><a id="24816" href="https://agda.github.io/agda-stdlib/v1.3/Function.Equivalence.html#971" class="Function Operator">_⇔_</a><a id="24819" class="Symbol">)</a>
</pre>
<p>The standard library constructs pairs with <code>_,_</code> whereas we use <code>⟨_,_⟩</code>. The former makes it convenient to build triples or larger tuples from pairs, permitting <code>a , b , c</code> to stand for <code>(a , (b , c))</code>. But it conflicts with other useful notations, such as <code>[_,_]</code> to construct a list of two elements in Chapter <a href="../Lists/">Lists</a> and <code>Γ , A</code> to extend environments in Chapter <a href="../DeBruijn/">DeBruijn</a>. The standard library <code>_⇔_</code> is similar to ours, but the one in the standard library is less convenient, since it is parameterised with respect to an arbitrary notion of equivalence.</p>
<h2 id="unicode">Unicode</h2>
<p>This chapter uses the following unicode:</p>
<pre><code>×  U+00D7  MULTIPLICATION SIGN (\x)
⊎  U+228E  MULTISET UNION (\u+)
⊤  U+22A4  DOWN TACK (\top)
⊥  U+22A5  UP TACK (\bot)
η  U+03B7  GREEK SMALL LETTER ETA (\eta)
₁  U+2081  SUBSCRIPT ONE (\_1)
₂  U+2082  SUBSCRIPT TWO (\_2)
⇔  U+21D4  LEFT RIGHT DOUBLE ARROW (\&lt;=&gt;)</code></pre>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>This paragraph was adopted from “Propositions as Types”, Philip Wadler, <em>Communications of the ACM</em>, December 2015.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
    </div>
    <nav class="pager">
    <ul class="pagination">
        
        <li><a class="pagelink" href="../Isomorphism/">Prev</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Connectives.lagda.md">Source</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="../Negation/">Next</a></li>
        <li class="separator">&bullet;</li>
        
    </ul>
</nav>

</article>

            </div>
        </main>
        <footer class="site-footer h-card">
    <data class="u-url" href="../"></data>
    <div class="wrapper">
        <h2 class="footer-heading">Programming Language Foundations in Agda</h2>
        
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Philip Wadler</li>
                    <li>
                        
                        <a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/wadler" title="wadler"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;wadler</a></li>
    
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Wen Kokke</li>
                    <li>
                        
                        <a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;wenkokke</a></li>
    
    
    <li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#twitter"></use></svg>&nbsp;wenkokke</a></li>
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Jeremy G. Siek</li>
                    <li>
                        
                        <a class="u-email" href="mailto:jsiek@indiana.edu">jsiek@indiana.edu</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/jsiek" title="jsiek"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;jsiek</a></li>
    
    
    <li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#twitter"></use></svg>&nbsp;jeremysiek</a></li>
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        
        This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
    </div>
</footer>

    </body>
</html>
