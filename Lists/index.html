<!DOCTYPE html>
<html lang="en">
    <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../public/css/style.css">
  
  <title>Programming Language Foundations in Agda – Lists</title>
  
  
  
</head>

    <body>
        <header class="site-header">
    <div class="wrapper">
        <a class="site-title" href="../">Programming Language Foundations in Agda</a>
        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="../">The Book</a>
                <a class="page-link" href="../Announcements/">Announcements</a>
                <a class="page-link" href="../GettingStarted/">Getting Started</a>
                <a class="page-link" href="../Citing/">Citing</a>
                <a class="page-link" href="https://agda-zh.github.io/PLFA-zh/">中文</a>
            </div>
        </nav>
    </div>
</header>

        <main class="page-content" aria-label="Content">
            <div class="wrapper">
                <article class="post">
    <nav class="pager">
    <ul class="pagination">
        
        <li><a class="pagelink" href="../Decidable/">Prev</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Lists.lagda.md">Source</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="../Lambda/">Next</a></li>
        <li class="separator">&bullet;</li>
        
    </ul>
</nav>

    <header class="post-header">
        <h1 class="post-title" id="lists">Lists: Lists and higher-order functions</h1>
    </header>
    <div class="post-content">
        <pre class="Agda"><a id="150" class="Keyword">module</a> <a id="157" href="../Lists/" class="Module">plfa.part1.Lists</a> <a id="174" class="Keyword">where</a>
</pre>
<p>This chapter discusses the list data type. It gives further examples of many of the techniques we have developed so far, and provides examples of polymorphic types and higher-order functions.</p>
<h2 id="imports">Imports</h2>
<pre class="Agda"><a id="395" class="Keyword">import</a> <a id="402" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="440" class="Symbol">as</a> <a id="443" class="Module">Eq</a>
<a id="446" class="Keyword">open</a> <a id="451" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="454" class="Keyword">using</a> <a id="460" class="Symbol">(</a><a id="461" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="464" class="Symbol">;</a> <a id="466" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="470" class="Symbol">;</a> <a id="472" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#980" class="Function">sym</a><a id="475" class="Symbol">;</a> <a id="477" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#1025" class="Function">trans</a><a id="482" class="Symbol">;</a> <a id="484" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#1131" class="Function">cong</a><a id="488" class="Symbol">)</a>
<a id="490" class="Keyword">open</a> <a id="495" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2419" class="Module">Eq.≡-Reasoning</a>
<a id="510" class="Keyword">open</a> <a id="515" class="Keyword">import</a> <a id="522" href="https://agda.github.io/agda-stdlib/v1.3/Data.Bool.html" class="Module">Data.Bool</a> <a id="532" class="Keyword">using</a> <a id="538" class="Symbol">(</a><a id="539" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="543" class="Symbol">;</a> <a id="545" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="549" class="Symbol">;</a> <a id="551" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a><a id="556" class="Symbol">;</a> <a id="558" href="https://agda.github.io/agda-stdlib/v1.3/Data.Bool.Base.html#1451" class="Function">T</a><a id="559" class="Symbol">;</a> <a id="561" href="https://agda.github.io/agda-stdlib/v1.3/Data.Bool.Base.html#986" class="Function Operator">_∧_</a><a id="564" class="Symbol">;</a> <a id="566" href="https://agda.github.io/agda-stdlib/v1.3/Data.Bool.Base.html#1044" class="Function Operator">_∨_</a><a id="569" class="Symbol">;</a> <a id="571" href="https://agda.github.io/agda-stdlib/v1.3/Data.Bool.Base.html#932" class="Function">not</a><a id="574" class="Symbol">)</a>
<a id="576" class="Keyword">open</a> <a id="581" class="Keyword">import</a> <a id="588" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.html" class="Module">Data.Nat</a> <a id="597" class="Keyword">using</a> <a id="603" class="Symbol">(</a><a id="604" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="605" class="Symbol">;</a> <a id="607" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="611" class="Symbol">;</a> <a id="613" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="616" class="Symbol">;</a> <a id="618" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a><a id="621" class="Symbol">;</a> <a id="623" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#528" class="Primitive Operator">_*_</a><a id="626" class="Symbol">;</a> <a id="628" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Base.html#1429" class="Primitive Operator">_∸_</a><a id="631" class="Symbol">;</a> <a id="633" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Base.html#937" class="Datatype Operator">_≤_</a><a id="636" class="Symbol">;</a> <a id="638" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Base.html#1002" class="InductiveConstructor">s≤s</a><a id="641" class="Symbol">;</a> <a id="643" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Base.html#960" class="InductiveConstructor">z≤n</a><a id="646" class="Symbol">)</a>
<a id="648" class="Keyword">open</a> <a id="653" class="Keyword">import</a> <a id="660" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="680" class="Keyword">using</a>
  <a id="688" class="Symbol">(</a><a id="689" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html#12490" class="Function">+-assoc</a><a id="696" class="Symbol">;</a> <a id="698" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html#12591" class="Function">+-identityˡ</a><a id="709" class="Symbol">;</a> <a id="711" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html#12646" class="Function">+-identityʳ</a><a id="722" class="Symbol">;</a> <a id="724" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html#20430" class="Function">*-assoc</a><a id="731" class="Symbol">;</a> <a id="733" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html#19330" class="Function">*-identityˡ</a><a id="744" class="Symbol">;</a> <a id="746" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html#19394" class="Function">*-identityʳ</a><a id="757" class="Symbol">)</a>
<a id="759" class="Keyword">open</a> <a id="764" class="Keyword">import</a> <a id="771" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="788" class="Keyword">using</a> <a id="794" class="Symbol">(</a><a id="795" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#653" class="Function Operator">¬_</a><a id="797" class="Symbol">;</a> <a id="799" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1508" class="Record">Dec</a><a id="802" class="Symbol">;</a> <a id="804" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1645" class="InductiveConstructor">yes</a><a id="807" class="Symbol">;</a> <a id="809" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1682" class="InductiveConstructor">no</a><a id="811" class="Symbol">)</a>
<a id="813" class="Keyword">open</a> <a id="818" class="Keyword">import</a> <a id="825" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html" class="Module">Data.Product</a> <a id="838" class="Keyword">using</a> <a id="844" class="Symbol">(</a><a id="845" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1167" class="Function Operator">_×_</a><a id="848" class="Symbol">;</a> <a id="850" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1369" class="Function">∃</a><a id="851" class="Symbol">;</a> <a id="853" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1788" class="Function">∃-syntax</a><a id="861" class="Symbol">)</a> <a id="863" class="Keyword">renaming</a> <a id="872" class="Symbol">(</a><a id="873" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a> <a id="877" class="Symbol">to</a> <a id="_,_"></a><a id="880" href="../Lists/#880" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="885" class="Symbol">)</a>
<a id="887" class="Keyword">open</a> <a id="892" class="Keyword">import</a> <a id="899" href="https://agda.github.io/agda-stdlib/v1.3/Function.html" class="Module">Function</a> <a id="908" class="Keyword">using</a> <a id="914" class="Symbol">(</a><a id="915" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">_∘_</a><a id="918" class="Symbol">)</a>
<a id="920" class="Keyword">open</a> <a id="925" class="Keyword">import</a> <a id="932" href="https://agda.github.io/agda-stdlib/v1.3/Level.html" class="Module">Level</a> <a id="938" class="Keyword">using</a> <a id="944" class="Symbol">(</a><a id="945" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Primitive.html#423" class="Postulate">Level</a><a id="950" class="Symbol">)</a>
<a id="952" class="Keyword">open</a> <a id="957" class="Keyword">import</a> <a id="964" href="../Isomorphism/" class="Module">plfa.part1.Isomorphism</a> <a id="987" class="Keyword">using</a> <a id="993" class="Symbol">(</a><a id="994" href="../Isomorphism/#4329" class="Record Operator">_≃_</a><a id="997" class="Symbol">;</a> <a id="999" href="../Isomorphism/#11988" class="Record Operator">_⇔_</a><a id="1002" class="Symbol">)</a>
</pre>
<h2 id="lists">Lists</h2>
Lists are defined in Agda as follows:
<pre class="Agda"><a id="1062" class="Keyword">data</a> <a id="List"></a><a id="1067" href="../Lists/#1067" class="Datatype">List</a> <a id="1072" class="Symbol">(</a><a id="1073" href="../Lists/#1073" class="Bound">A</a> <a id="1075" class="Symbol">:</a> <a id="1077" class="PrimitiveType">Set</a><a id="1080" class="Symbol">)</a> <a id="1082" class="Symbol">:</a> <a id="1084" class="PrimitiveType">Set</a> <a id="1088" class="Keyword">where</a>
  <a id="List.[]"></a><a id="1096" href="../Lists/#1096" class="InductiveConstructor">[]</a>  <a id="1100" class="Symbol">:</a> <a id="1102" href="../Lists/#1067" class="Datatype">List</a> <a id="1107" href="../Lists/#1073" class="Bound">A</a>
  <a id="List._∷_"></a><a id="1111" href="../Lists/#1111" class="InductiveConstructor Operator">_∷_</a> <a id="1115" class="Symbol">:</a> <a id="1117" href="../Lists/#1073" class="Bound">A</a> <a id="1119" class="Symbol">→</a> <a id="1121" href="../Lists/#1067" class="Datatype">List</a> <a id="1126" href="../Lists/#1073" class="Bound">A</a> <a id="1128" class="Symbol">→</a> <a id="1130" href="../Lists/#1067" class="Datatype">List</a> <a id="1135" href="../Lists/#1073" class="Bound">A</a>

<a id="1138" class="Keyword">infixr</a> <a id="1145" class="Number">5</a> <a id="1147" href="../Lists/#1111" class="InductiveConstructor Operator">_∷_</a>
</pre>
<p>Let’s unpack this definition. If <code>A</code> is a set, then <code>List A</code> is a set. The next two lines tell us that <code>[]</code> (pronounced <em>nil</em>) is a list of type <code>A</code> (often called the <em>empty</em> list), and that <code>_∷_</code> (pronounced <em>cons</em>, short for <em>constructor</em>) takes a value of type <code>A</code> and a value of type <code>List A</code> and returns a value of type <code>List A</code>. Operator <code>_∷_</code> has precedence level 5 and associates to the right.</p>
For example,
<pre class="Agda"><a id="1576" href="../Lists/#1576" class="Function">_</a> <a id="1578" class="Symbol">:</a> <a id="1580" href="../Lists/#1067" class="Datatype">List</a> <a id="1585" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="1587" class="Symbol">_</a> <a id="1589" class="Symbol">=</a> <a id="1591" class="Number">0</a> <a id="1593" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="1595" class="Number">1</a> <a id="1597" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="1599" class="Number">2</a> <a id="1601" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="1603" href="../Lists/#1096" class="InductiveConstructor">[]</a>
</pre>
<p>denotes the list of the first three natural numbers. Since <code>_∷_</code> associates to the right, the term parses as <code>0 ∷ (1 ∷ (2 ∷ []))</code>. Here <code>0</code> is the first element of the list, called the <em>head</em>, and <code>1 ∷ (2 ∷ [])</code> is a list of the remaining elements, called the <em>tail</em>. A list is a strange beast: it has a head and a tail, nothing in between, and the tail is itself another list!</p>
As we’ve seen, parameterised types can be translated to indexed types. The definition above is equivalent to the following:
<pre class="Agda"><a id="2118" class="Keyword">data</a> <a id="List′"></a><a id="2123" href="../Lists/#2123" class="Datatype">List′</a> <a id="2129" class="Symbol">:</a> <a id="2131" class="PrimitiveType">Set</a> <a id="2135" class="Symbol">→</a> <a id="2137" class="PrimitiveType">Set</a> <a id="2141" class="Keyword">where</a>
  <a id="List′.[]′"></a><a id="2149" href="../Lists/#2149" class="InductiveConstructor">[]′</a>  <a id="2154" class="Symbol">:</a> <a id="2156" class="Symbol">∀</a> <a id="2158" class="Symbol">{</a><a id="2159" href="../Lists/#2159" class="Bound">A</a> <a id="2161" class="Symbol">:</a> <a id="2163" class="PrimitiveType">Set</a><a id="2166" class="Symbol">}</a> <a id="2168" class="Symbol">→</a> <a id="2170" href="../Lists/#2123" class="Datatype">List′</a> <a id="2176" href="../Lists/#2159" class="Bound">A</a>
  <a id="List′._∷′_"></a><a id="2180" href="../Lists/#2180" class="InductiveConstructor Operator">_∷′_</a> <a id="2185" class="Symbol">:</a> <a id="2187" class="Symbol">∀</a> <a id="2189" class="Symbol">{</a><a id="2190" href="../Lists/#2190" class="Bound">A</a> <a id="2192" class="Symbol">:</a> <a id="2194" class="PrimitiveType">Set</a><a id="2197" class="Symbol">}</a> <a id="2199" class="Symbol">→</a> <a id="2201" href="../Lists/#2190" class="Bound">A</a> <a id="2203" class="Symbol">→</a> <a id="2205" href="../Lists/#2123" class="Datatype">List′</a> <a id="2211" href="../Lists/#2190" class="Bound">A</a> <a id="2213" class="Symbol">→</a> <a id="2215" href="../Lists/#2123" class="Datatype">List′</a> <a id="2221" href="../Lists/#2190" class="Bound">A</a>
</pre>
Each constructor takes the parameter as an implicit argument. Thus, our example list could also be written:
<pre class="Agda"><a id="2339" href="../Lists/#2339" class="Function">_</a> <a id="2341" class="Symbol">:</a> <a id="2343" href="../Lists/#1067" class="Datatype">List</a> <a id="2348" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="2350" class="Symbol">_</a> <a id="2352" class="Symbol">=</a> <a id="2354" href="../Lists/#1111" class="InductiveConstructor Operator">_∷_</a> <a id="2358" class="Symbol">{</a><a id="2359" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="2360" class="Symbol">}</a> <a id="2362" class="Number">0</a> <a id="2364" class="Symbol">(</a><a id="2365" href="../Lists/#1111" class="InductiveConstructor Operator">_∷_</a> <a id="2369" class="Symbol">{</a><a id="2370" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="2371" class="Symbol">}</a> <a id="2373" class="Number">1</a> <a id="2375" class="Symbol">(</a><a id="2376" href="../Lists/#1111" class="InductiveConstructor Operator">_∷_</a> <a id="2380" class="Symbol">{</a><a id="2381" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="2382" class="Symbol">}</a> <a id="2384" class="Number">2</a> <a id="2386" class="Symbol">(</a><a id="2387" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="2390" class="Symbol">{</a><a id="2391" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="2392" class="Symbol">})))</a>
</pre>
<p>where here we have provided the implicit parameters explicitly.</p>
<p>Including the pragma:</p>
<pre><code>{-# BUILTIN LIST List #-}</code></pre>
<p>tells Agda that the type <code>List</code> corresponds to the Haskell type list, and the constructors <code>[]</code> and <code>_∷_</code> correspond to nil and cons respectively, allowing a more efficient representation of lists.</p>
<h2 id="list-syntax">List syntax</h2>
We can write lists more conveniently by introducing the following definitions:
<pre class="Agda"><a id="2819" class="Keyword">pattern</a> <a id="[_]"></a><a id="2827" href="../Lists/#2827" class="InductiveConstructor Operator">[_]</a> <a id="2831" href="../Lists/#2835" class="Bound">z</a> <a id="2833" class="Symbol">=</a> <a id="2835" href="../Lists/#2835" class="Bound">z</a> <a id="2837" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="2839" href="../Lists/#1096" class="InductiveConstructor">[]</a>
<a id="2842" class="Keyword">pattern</a> <a id="[_,_]"></a><a id="2850" href="../Lists/#2850" class="InductiveConstructor Operator">[_,_]</a> <a id="2856" href="../Lists/#2862" class="Bound">y</a> <a id="2858" href="../Lists/#2866" class="Bound">z</a> <a id="2860" class="Symbol">=</a> <a id="2862" href="../Lists/#2862" class="Bound">y</a> <a id="2864" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="2866" href="../Lists/#2866" class="Bound">z</a> <a id="2868" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="2870" href="../Lists/#1096" class="InductiveConstructor">[]</a>
<a id="2873" class="Keyword">pattern</a> <a id="[_,_,_]"></a><a id="2881" href="../Lists/#2881" class="InductiveConstructor Operator">[_,_,_]</a> <a id="2889" href="../Lists/#2897" class="Bound">x</a> <a id="2891" href="../Lists/#2901" class="Bound">y</a> <a id="2893" href="../Lists/#2905" class="Bound">z</a> <a id="2895" class="Symbol">=</a> <a id="2897" href="../Lists/#2897" class="Bound">x</a> <a id="2899" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="2901" href="../Lists/#2901" class="Bound">y</a> <a id="2903" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="2905" href="../Lists/#2905" class="Bound">z</a> <a id="2907" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="2909" href="../Lists/#1096" class="InductiveConstructor">[]</a>
<a id="2912" class="Keyword">pattern</a> <a id="[_,_,_,_]"></a><a id="2920" href="../Lists/#2920" class="InductiveConstructor Operator">[_,_,_,_]</a> <a id="2930" href="../Lists/#2940" class="Bound">w</a> <a id="2932" href="../Lists/#2944" class="Bound">x</a> <a id="2934" href="../Lists/#2948" class="Bound">y</a> <a id="2936" href="../Lists/#2952" class="Bound">z</a> <a id="2938" class="Symbol">=</a> <a id="2940" href="../Lists/#2940" class="Bound">w</a> <a id="2942" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="2944" href="../Lists/#2944" class="Bound">x</a> <a id="2946" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="2948" href="../Lists/#2948" class="Bound">y</a> <a id="2950" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="2952" href="../Lists/#2952" class="Bound">z</a> <a id="2954" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="2956" href="../Lists/#1096" class="InductiveConstructor">[]</a>
<a id="2959" class="Keyword">pattern</a> <a id="[_,_,_,_,_]"></a><a id="2967" href="../Lists/#2967" class="InductiveConstructor Operator">[_,_,_,_,_]</a> <a id="2979" href="../Lists/#2991" class="Bound">v</a> <a id="2981" href="../Lists/#2995" class="Bound">w</a> <a id="2983" href="../Lists/#2999" class="Bound">x</a> <a id="2985" href="../Lists/#3003" class="Bound">y</a> <a id="2987" href="../Lists/#3007" class="Bound">z</a> <a id="2989" class="Symbol">=</a> <a id="2991" href="../Lists/#2991" class="Bound">v</a> <a id="2993" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="2995" href="../Lists/#2995" class="Bound">w</a> <a id="2997" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="2999" href="../Lists/#2999" class="Bound">x</a> <a id="3001" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="3003" href="../Lists/#3003" class="Bound">y</a> <a id="3005" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="3007" href="../Lists/#3007" class="Bound">z</a> <a id="3009" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="3011" href="../Lists/#1096" class="InductiveConstructor">[]</a>
<a id="3014" class="Keyword">pattern</a> <a id="[_,_,_,_,_,_]"></a><a id="3022" href="../Lists/#3022" class="InductiveConstructor Operator">[_,_,_,_,_,_]</a> <a id="3036" href="../Lists/#3050" class="Bound">u</a> <a id="3038" href="../Lists/#3054" class="Bound">v</a> <a id="3040" href="../Lists/#3058" class="Bound">w</a> <a id="3042" href="../Lists/#3062" class="Bound">x</a> <a id="3044" href="../Lists/#3066" class="Bound">y</a> <a id="3046" href="../Lists/#3070" class="Bound">z</a> <a id="3048" class="Symbol">=</a> <a id="3050" href="../Lists/#3050" class="Bound">u</a> <a id="3052" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="3054" href="../Lists/#3054" class="Bound">v</a> <a id="3056" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="3058" href="../Lists/#3058" class="Bound">w</a> <a id="3060" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="3062" href="../Lists/#3062" class="Bound">x</a> <a id="3064" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="3066" href="../Lists/#3066" class="Bound">y</a> <a id="3068" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="3070" href="../Lists/#3070" class="Bound">z</a> <a id="3072" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="3074" href="../Lists/#1096" class="InductiveConstructor">[]</a>
</pre>
<p>This is our first use of pattern declarations. For instance, the third line tells us that <code>[ x , y , z ]</code> is equivalent to <code>x ∷ y ∷ z ∷ []</code>, and permits the former to appear either in a pattern on the left-hand side of an equation, or a term on the right-hand side of an equation.</p>
<h2 id="append">Append</h2>
<p>Our first function on lists is written <code>_++_</code> and pronounced <em>append</em>:</p>
<pre class="Agda"><a id="3452" class="Keyword">infixr</a> <a id="3459" class="Number">5</a> <a id="3461" href="../Lists/#3467" class="Function Operator">_++_</a>

<a id="_++_"></a><a id="3467" href="../Lists/#3467" class="Function Operator">_++_</a> <a id="3472" class="Symbol">:</a> <a id="3474" class="Symbol">∀</a> <a id="3476" class="Symbol">{</a><a id="3477" href="../Lists/#3477" class="Bound">A</a> <a id="3479" class="Symbol">:</a> <a id="3481" class="PrimitiveType">Set</a><a id="3484" class="Symbol">}</a> <a id="3486" class="Symbol">→</a> <a id="3488" href="../Lists/#1067" class="Datatype">List</a> <a id="3493" href="../Lists/#3477" class="Bound">A</a> <a id="3495" class="Symbol">→</a> <a id="3497" href="../Lists/#1067" class="Datatype">List</a> <a id="3502" href="../Lists/#3477" class="Bound">A</a> <a id="3504" class="Symbol">→</a> <a id="3506" href="../Lists/#1067" class="Datatype">List</a> <a id="3511" href="../Lists/#3477" class="Bound">A</a>
<a id="3513" href="../Lists/#1096" class="InductiveConstructor">[]</a>       <a id="3522" href="../Lists/#3467" class="Function Operator">++</a> <a id="3525" href="../Lists/#3525" class="Bound">ys</a>  <a id="3529" class="Symbol">=</a>  <a id="3532" href="../Lists/#3525" class="Bound">ys</a>
<a id="3535" class="Symbol">(</a><a id="3536" href="../Lists/#3536" class="Bound">x</a> <a id="3538" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="3540" href="../Lists/#3540" class="Bound">xs</a><a id="3542" class="Symbol">)</a> <a id="3544" href="../Lists/#3467" class="Function Operator">++</a> <a id="3547" href="../Lists/#3547" class="Bound">ys</a>  <a id="3551" class="Symbol">=</a>  <a id="3554" href="../Lists/#3536" class="Bound">x</a> <a id="3556" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="3558" class="Symbol">(</a><a id="3559" href="../Lists/#3540" class="Bound">xs</a> <a id="3562" href="../Lists/#3467" class="Function Operator">++</a> <a id="3565" href="../Lists/#3547" class="Bound">ys</a><a id="3567" class="Symbol">)</a>
</pre>
<p>The type <code>A</code> is an implicit argument to append, making it a <em>polymorphic</em> function (one that can be used at many types). A list appended to the empty list yields the list itself. A list appended to a non-empty list yields a list with the head the same as the head of the non-empty list, and a tail the same as the other list appended to tail of the non-empty list.</p>
Here is an example, showing how to compute the result of appending two lists:
<pre class="Agda"><a id="4021" href="../Lists/#4021" class="Function">_</a> <a id="4023" class="Symbol">:</a> <a id="4025" href="../Lists/#2881" class="InductiveConstructor Operator">[</a> <a id="4027" class="Number">0</a> <a id="4029" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="4031" class="Number">1</a> <a id="4033" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="4035" class="Number">2</a> <a id="4037" href="../Lists/#2881" class="InductiveConstructor Operator">]</a> <a id="4039" href="../Lists/#3467" class="Function Operator">++</a> <a id="4042" href="../Lists/#2850" class="InductiveConstructor Operator">[</a> <a id="4044" class="Number">3</a> <a id="4046" href="../Lists/#2850" class="InductiveConstructor Operator">,</a> <a id="4048" class="Number">4</a> <a id="4050" href="../Lists/#2850" class="InductiveConstructor Operator">]</a> <a id="4052" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="4054" href="../Lists/#2967" class="InductiveConstructor Operator">[</a> <a id="4056" class="Number">0</a> <a id="4058" href="../Lists/#2967" class="InductiveConstructor Operator">,</a> <a id="4060" class="Number">1</a> <a id="4062" href="../Lists/#2967" class="InductiveConstructor Operator">,</a> <a id="4064" class="Number">2</a> <a id="4066" href="../Lists/#2967" class="InductiveConstructor Operator">,</a> <a id="4068" class="Number">3</a> <a id="4070" href="../Lists/#2967" class="InductiveConstructor Operator">,</a> <a id="4072" class="Number">4</a> <a id="4074" href="../Lists/#2967" class="InductiveConstructor Operator">]</a>
<a id="4076" class="Symbol">_</a> <a id="4078" class="Symbol">=</a>
  <a id="4082" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="4092" class="Number">0</a> <a id="4094" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4096" class="Number">1</a> <a id="4098" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4100" class="Number">2</a> <a id="4102" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4104" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="4107" href="../Lists/#3467" class="Function Operator">++</a> <a id="4110" class="Number">3</a> <a id="4112" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4114" class="Number">4</a> <a id="4116" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4118" href="../Lists/#1096" class="InductiveConstructor">[]</a>
  <a id="4123" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="4131" class="Number">0</a> <a id="4133" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4135" class="Symbol">(</a><a id="4136" class="Number">1</a> <a id="4138" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4140" class="Number">2</a> <a id="4142" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4144" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="4147" href="../Lists/#3467" class="Function Operator">++</a> <a id="4150" class="Number">3</a> <a id="4152" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4154" class="Number">4</a> <a id="4156" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4158" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="4160" class="Symbol">)</a>
  <a id="4164" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="4172" class="Number">0</a> <a id="4174" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4176" class="Number">1</a> <a id="4178" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4180" class="Symbol">(</a><a id="4181" class="Number">2</a> <a id="4183" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4185" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="4188" href="../Lists/#3467" class="Function Operator">++</a> <a id="4191" class="Number">3</a> <a id="4193" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4195" class="Number">4</a> <a id="4197" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4199" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="4201" class="Symbol">)</a>
  <a id="4205" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="4213" class="Number">0</a> <a id="4215" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4217" class="Number">1</a> <a id="4219" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4221" class="Number">2</a> <a id="4223" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4225" class="Symbol">(</a><a id="4226" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="4229" href="../Lists/#3467" class="Function Operator">++</a> <a id="4232" class="Number">3</a> <a id="4234" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4236" class="Number">4</a> <a id="4238" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4240" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="4242" class="Symbol">)</a>
  <a id="4246" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="4254" class="Number">0</a> <a id="4256" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4258" class="Number">1</a> <a id="4260" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4262" class="Number">2</a> <a id="4264" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4266" class="Number">3</a> <a id="4268" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4270" class="Number">4</a> <a id="4272" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4274" href="../Lists/#1096" class="InductiveConstructor">[]</a>
  <a id="4279" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<p>Appending two lists requires time linear in the number of elements in the first list.</p>
<h2 id="reasoning-about-append">Reasoning about append</h2>
We can reason about lists in much the same way that we reason about numbers. Here is the proof that append is associative:
<pre class="Agda"><a id="++-assoc"></a><a id="4528" href="../Lists/#4528" class="Function">++-assoc</a> <a id="4537" class="Symbol">:</a> <a id="4539" class="Symbol">∀</a> <a id="4541" class="Symbol">{</a><a id="4542" href="../Lists/#4542" class="Bound">A</a> <a id="4544" class="Symbol">:</a> <a id="4546" class="PrimitiveType">Set</a><a id="4549" class="Symbol">}</a> <a id="4551" class="Symbol">(</a><a id="4552" href="../Lists/#4552" class="Bound">xs</a> <a id="4555" href="../Lists/#4555" class="Bound">ys</a> <a id="4558" href="../Lists/#4558" class="Bound">zs</a> <a id="4561" class="Symbol">:</a> <a id="4563" href="../Lists/#1067" class="Datatype">List</a> <a id="4568" href="../Lists/#4542" class="Bound">A</a><a id="4569" class="Symbol">)</a>
  <a id="4573" class="Symbol">→</a> <a id="4575" class="Symbol">(</a><a id="4576" href="../Lists/#4552" class="Bound">xs</a> <a id="4579" href="../Lists/#3467" class="Function Operator">++</a> <a id="4582" href="../Lists/#4555" class="Bound">ys</a><a id="4584" class="Symbol">)</a> <a id="4586" href="../Lists/#3467" class="Function Operator">++</a> <a id="4589" href="../Lists/#4558" class="Bound">zs</a> <a id="4592" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="4594" href="../Lists/#4552" class="Bound">xs</a> <a id="4597" href="../Lists/#3467" class="Function Operator">++</a> <a id="4600" class="Symbol">(</a><a id="4601" href="../Lists/#4555" class="Bound">ys</a> <a id="4604" href="../Lists/#3467" class="Function Operator">++</a> <a id="4607" href="../Lists/#4558" class="Bound">zs</a><a id="4609" class="Symbol">)</a>
<a id="4611" href="../Lists/#4528" class="Function">++-assoc</a> <a id="4620" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="4623" href="../Lists/#4623" class="Bound">ys</a> <a id="4626" href="../Lists/#4626" class="Bound">zs</a> <a id="4629" class="Symbol">=</a>
  <a id="4633" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="4643" class="Symbol">(</a><a id="4644" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="4647" href="../Lists/#3467" class="Function Operator">++</a> <a id="4650" href="../Lists/#4623" class="Bound">ys</a><a id="4652" class="Symbol">)</a> <a id="4654" href="../Lists/#3467" class="Function Operator">++</a> <a id="4657" href="../Lists/#4626" class="Bound">zs</a>
  <a id="4662" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="4670" href="../Lists/#4623" class="Bound">ys</a> <a id="4673" href="../Lists/#3467" class="Function Operator">++</a> <a id="4676" href="../Lists/#4626" class="Bound">zs</a>
  <a id="4681" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="4689" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="4692" href="../Lists/#3467" class="Function Operator">++</a> <a id="4695" class="Symbol">(</a><a id="4696" href="../Lists/#4623" class="Bound">ys</a> <a id="4699" href="../Lists/#3467" class="Function Operator">++</a> <a id="4702" href="../Lists/#4626" class="Bound">zs</a><a id="4704" class="Symbol">)</a>
  <a id="4708" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
<a id="4710" href="../Lists/#4528" class="Function">++-assoc</a> <a id="4719" class="Symbol">(</a><a id="4720" href="../Lists/#4720" class="Bound">x</a> <a id="4722" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4724" href="../Lists/#4724" class="Bound">xs</a><a id="4726" class="Symbol">)</a> <a id="4728" href="../Lists/#4728" class="Bound">ys</a> <a id="4731" href="../Lists/#4731" class="Bound">zs</a> <a id="4734" class="Symbol">=</a>
  <a id="4738" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="4748" class="Symbol">(</a><a id="4749" href="../Lists/#4720" class="Bound">x</a> <a id="4751" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4753" href="../Lists/#4724" class="Bound">xs</a> <a id="4756" href="../Lists/#3467" class="Function Operator">++</a> <a id="4759" href="../Lists/#4728" class="Bound">ys</a><a id="4761" class="Symbol">)</a> <a id="4763" href="../Lists/#3467" class="Function Operator">++</a> <a id="4766" href="../Lists/#4731" class="Bound">zs</a>
  <a id="4771" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="4779" href="../Lists/#4720" class="Bound">x</a> <a id="4781" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4783" class="Symbol">(</a><a id="4784" href="../Lists/#4724" class="Bound">xs</a> <a id="4787" href="../Lists/#3467" class="Function Operator">++</a> <a id="4790" href="../Lists/#4728" class="Bound">ys</a><a id="4792" class="Symbol">)</a> <a id="4794" href="../Lists/#3467" class="Function Operator">++</a> <a id="4797" href="../Lists/#4731" class="Bound">zs</a>
  <a id="4802" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="4810" href="../Lists/#4720" class="Bound">x</a> <a id="4812" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4814" class="Symbol">((</a><a id="4816" href="../Lists/#4724" class="Bound">xs</a> <a id="4819" href="../Lists/#3467" class="Function Operator">++</a> <a id="4822" href="../Lists/#4728" class="Bound">ys</a><a id="4824" class="Symbol">)</a> <a id="4826" href="../Lists/#3467" class="Function Operator">++</a> <a id="4829" href="../Lists/#4731" class="Bound">zs</a><a id="4831" class="Symbol">)</a>
  <a id="4835" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="4838" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#1131" class="Function">cong</a> <a id="4843" class="Symbol">(</a><a id="4844" href="../Lists/#4720" class="Bound">x</a> <a id="4846" href="../Lists/#1111" class="InductiveConstructor Operator">∷_</a><a id="4848" class="Symbol">)</a> <a id="4850" class="Symbol">(</a><a id="4851" href="../Lists/#4528" class="Function">++-assoc</a> <a id="4860" href="../Lists/#4724" class="Bound">xs</a> <a id="4863" href="../Lists/#4728" class="Bound">ys</a> <a id="4866" href="../Lists/#4731" class="Bound">zs</a><a id="4868" class="Symbol">)</a> <a id="4870" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
    <a id="4876" href="../Lists/#4720" class="Bound">x</a> <a id="4878" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4880" class="Symbol">(</a><a id="4881" href="../Lists/#4724" class="Bound">xs</a> <a id="4884" href="../Lists/#3467" class="Function Operator">++</a> <a id="4887" class="Symbol">(</a><a id="4888" href="../Lists/#4728" class="Bound">ys</a> <a id="4891" href="../Lists/#3467" class="Function Operator">++</a> <a id="4894" href="../Lists/#4731" class="Bound">zs</a><a id="4896" class="Symbol">))</a>
  <a id="4901" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="4909" href="../Lists/#4720" class="Bound">x</a> <a id="4911" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="4913" href="../Lists/#4724" class="Bound">xs</a> <a id="4916" href="../Lists/#3467" class="Function Operator">++</a> <a id="4919" class="Symbol">(</a><a id="4920" href="../Lists/#4728" class="Bound">ys</a> <a id="4923" href="../Lists/#3467" class="Function Operator">++</a> <a id="4926" href="../Lists/#4731" class="Bound">zs</a><a id="4928" class="Symbol">)</a>
  <a id="4932" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<p>The proof is by induction on the first argument. The base case instantiates to <code>[]</code>, and follows by straightforward computation. The inductive case instantiates to <code>x ∷ xs</code>, and follows by straightforward computation combined with the inductive hypothesis. As usual, the inductive hypothesis is indicated by a recursive invocation of the proof, in this case <code>++-assoc xs ys zs</code>.</p>
<p>Recall that Agda supports <a href="../Induction/#sections">sections</a>. Applying <code>cong (x ∷_)</code> promotes the inductive hypothesis:</p>
<pre><code>(xs ++ ys) ++ zs ≡ xs ++ (ys ++ zs)</code></pre>
<p>to the equality:</p>
<pre><code>x ∷ ((xs ++ ys) ++ zs) ≡ x ∷ (xs ++ (ys ++ zs))</code></pre>
<p>which is needed in the proof.</p>
It is also easy to show that <code>[]</code> is a left and right identity for <code>_++_</code>. That it is a left identity is immediate from the definition:
<pre class="Agda"><a id="++-identityˡ"></a><a id="5721" href="../Lists/#5721" class="Function">++-identityˡ</a> <a id="5734" class="Symbol">:</a> <a id="5736" class="Symbol">∀</a> <a id="5738" class="Symbol">{</a><a id="5739" href="../Lists/#5739" class="Bound">A</a> <a id="5741" class="Symbol">:</a> <a id="5743" class="PrimitiveType">Set</a><a id="5746" class="Symbol">}</a> <a id="5748" class="Symbol">(</a><a id="5749" href="../Lists/#5749" class="Bound">xs</a> <a id="5752" class="Symbol">:</a> <a id="5754" href="../Lists/#1067" class="Datatype">List</a> <a id="5759" href="../Lists/#5739" class="Bound">A</a><a id="5760" class="Symbol">)</a> <a id="5762" class="Symbol">→</a> <a id="5764" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="5767" href="../Lists/#3467" class="Function Operator">++</a> <a id="5770" href="../Lists/#5749" class="Bound">xs</a> <a id="5773" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="5775" href="../Lists/#5749" class="Bound">xs</a>
<a id="5778" href="../Lists/#5721" class="Function">++-identityˡ</a> <a id="5791" href="../Lists/#5791" class="Bound">xs</a> <a id="5794" class="Symbol">=</a>
  <a id="5798" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="5808" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="5811" href="../Lists/#3467" class="Function Operator">++</a> <a id="5814" href="../Lists/#5791" class="Bound">xs</a>
  <a id="5819" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="5827" href="../Lists/#5791" class="Bound">xs</a>
  <a id="5832" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
That it is a right identity follows by simple induction:
<pre class="Agda"><a id="++-identityʳ"></a><a id="5899" href="../Lists/#5899" class="Function">++-identityʳ</a> <a id="5912" class="Symbol">:</a> <a id="5914" class="Symbol">∀</a> <a id="5916" class="Symbol">{</a><a id="5917" href="../Lists/#5917" class="Bound">A</a> <a id="5919" class="Symbol">:</a> <a id="5921" class="PrimitiveType">Set</a><a id="5924" class="Symbol">}</a> <a id="5926" class="Symbol">(</a><a id="5927" href="../Lists/#5927" class="Bound">xs</a> <a id="5930" class="Symbol">:</a> <a id="5932" href="../Lists/#1067" class="Datatype">List</a> <a id="5937" href="../Lists/#5917" class="Bound">A</a><a id="5938" class="Symbol">)</a> <a id="5940" class="Symbol">→</a> <a id="5942" href="../Lists/#5927" class="Bound">xs</a> <a id="5945" href="../Lists/#3467" class="Function Operator">++</a> <a id="5948" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="5951" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="5953" href="../Lists/#5927" class="Bound">xs</a>
<a id="5956" href="../Lists/#5899" class="Function">++-identityʳ</a> <a id="5969" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="5972" class="Symbol">=</a>
  <a id="5976" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="5986" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="5989" href="../Lists/#3467" class="Function Operator">++</a> <a id="5992" href="../Lists/#1096" class="InductiveConstructor">[]</a>
  <a id="5997" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="6005" href="../Lists/#1096" class="InductiveConstructor">[]</a>
  <a id="6010" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
<a id="6012" href="../Lists/#5899" class="Function">++-identityʳ</a> <a id="6025" class="Symbol">(</a><a id="6026" href="../Lists/#6026" class="Bound">x</a> <a id="6028" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="6030" href="../Lists/#6030" class="Bound">xs</a><a id="6032" class="Symbol">)</a> <a id="6034" class="Symbol">=</a>
  <a id="6038" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="6048" class="Symbol">(</a><a id="6049" href="../Lists/#6026" class="Bound">x</a> <a id="6051" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="6053" href="../Lists/#6030" class="Bound">xs</a><a id="6055" class="Symbol">)</a> <a id="6057" href="../Lists/#3467" class="Function Operator">++</a> <a id="6060" href="../Lists/#1096" class="InductiveConstructor">[]</a>
  <a id="6065" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="6073" href="../Lists/#6026" class="Bound">x</a> <a id="6075" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="6077" class="Symbol">(</a><a id="6078" href="../Lists/#6030" class="Bound">xs</a> <a id="6081" href="../Lists/#3467" class="Function Operator">++</a> <a id="6084" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="6086" class="Symbol">)</a>
  <a id="6090" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="6093" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#1131" class="Function">cong</a> <a id="6098" class="Symbol">(</a><a id="6099" href="../Lists/#6026" class="Bound">x</a> <a id="6101" href="../Lists/#1111" class="InductiveConstructor Operator">∷_</a><a id="6103" class="Symbol">)</a> <a id="6105" class="Symbol">(</a><a id="6106" href="../Lists/#5899" class="Function">++-identityʳ</a> <a id="6119" href="../Lists/#6030" class="Bound">xs</a><a id="6121" class="Symbol">)</a> <a id="6123" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
    <a id="6129" href="../Lists/#6026" class="Bound">x</a> <a id="6131" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="6133" href="../Lists/#6030" class="Bound">xs</a>
  <a id="6138" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<p>As we will see later, these three properties establish that <code>_++_</code> and <code>[]</code> form a <em>monoid</em> over lists.</p>
<h2 id="length">Length</h2>
Our next function finds the length of a list:
<pre class="Agda"><a id="length"></a><a id="6310" href="../Lists/#6310" class="Function">length</a> <a id="6317" class="Symbol">:</a> <a id="6319" class="Symbol">∀</a> <a id="6321" class="Symbol">{</a><a id="6322" href="../Lists/#6322" class="Bound">A</a> <a id="6324" class="Symbol">:</a> <a id="6326" class="PrimitiveType">Set</a><a id="6329" class="Symbol">}</a> <a id="6331" class="Symbol">→</a> <a id="6333" href="../Lists/#1067" class="Datatype">List</a> <a id="6338" href="../Lists/#6322" class="Bound">A</a> <a id="6340" class="Symbol">→</a> <a id="6342" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="6344" href="../Lists/#6310" class="Function">length</a> <a id="6351" href="../Lists/#1096" class="InductiveConstructor">[]</a>        <a id="6361" class="Symbol">=</a>  <a id="6364" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>
<a id="6369" href="../Lists/#6310" class="Function">length</a> <a id="6376" class="Symbol">(</a><a id="6377" href="../Lists/#6377" class="Bound">x</a> <a id="6379" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="6381" href="../Lists/#6381" class="Bound">xs</a><a id="6383" class="Symbol">)</a>  <a id="6386" class="Symbol">=</a>  <a id="6389" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="6393" class="Symbol">(</a><a id="6394" href="../Lists/#6310" class="Function">length</a> <a id="6401" href="../Lists/#6381" class="Bound">xs</a><a id="6403" class="Symbol">)</a>
</pre>
<p>Again, it takes an implicit parameter <code>A</code>. The length of the empty list is zero. The length of a non-empty list is one greater than the length of the tail of the list.</p>
Here is an example showing how to compute the length of a list:
<pre class="Agda"><a id="6646" href="../Lists/#6646" class="Function">_</a> <a id="6648" class="Symbol">:</a> <a id="6650" href="../Lists/#6310" class="Function">length</a> <a id="6657" href="../Lists/#2881" class="InductiveConstructor Operator">[</a> <a id="6659" class="Number">0</a> <a id="6661" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="6663" class="Number">1</a> <a id="6665" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="6667" class="Number">2</a> <a id="6669" href="../Lists/#2881" class="InductiveConstructor Operator">]</a> <a id="6671" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="6673" class="Number">3</a>
<a id="6675" class="Symbol">_</a> <a id="6677" class="Symbol">=</a>
  <a id="6681" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="6691" href="../Lists/#6310" class="Function">length</a> <a id="6698" class="Symbol">(</a><a id="6699" class="Number">0</a> <a id="6701" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="6703" class="Number">1</a> <a id="6705" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="6707" class="Number">2</a> <a id="6709" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="6711" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="6713" class="Symbol">)</a>
  <a id="6717" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="6725" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="6729" class="Symbol">(</a><a id="6730" href="../Lists/#6310" class="Function">length</a> <a id="6737" class="Symbol">(</a><a id="6738" class="Number">1</a> <a id="6740" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="6742" class="Number">2</a> <a id="6744" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="6746" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="6748" class="Symbol">))</a>
  <a id="6753" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="6761" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="6765" class="Symbol">(</a><a id="6766" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="6770" class="Symbol">(</a><a id="6771" href="../Lists/#6310" class="Function">length</a> <a id="6778" class="Symbol">(</a><a id="6779" class="Number">2</a> <a id="6781" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="6783" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="6785" class="Symbol">)))</a>
  <a id="6791" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="6799" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="6803" class="Symbol">(</a><a id="6804" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="6808" class="Symbol">(</a><a id="6809" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="6813" class="Symbol">(</a><a id="6814" href="../Lists/#6310" class="Function">length</a> <a id="6821" class="Symbol">{</a><a id="6822" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="6823" class="Symbol">}</a> <a id="6825" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="6827" class="Symbol">)))</a>
  <a id="6833" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="6841" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="6845" class="Symbol">(</a><a id="6846" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="6850" class="Symbol">(</a><a id="6851" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="6855" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="6859" class="Symbol">))</a>
  <a id="6864" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<p>Computing the length of a list requires time linear in the number of elements in the list.</p>
<p>In the second-to-last line, we cannot write simply <code>length []</code> but must instead write <code>length {ℕ} []</code>. Since <code>[]</code> has no elements, Agda has insufficient information to infer the implicit parameter.</p>
<h2 id="reasoning-about-length">Reasoning about length</h2>
The length of one list appended to another is the sum of the lengths of the lists:
<pre class="Agda"><a id="length-++"></a><a id="7277" href="../Lists/#7277" class="Function">length-++</a> <a id="7287" class="Symbol">:</a> <a id="7289" class="Symbol">∀</a> <a id="7291" class="Symbol">{</a><a id="7292" href="../Lists/#7292" class="Bound">A</a> <a id="7294" class="Symbol">:</a> <a id="7296" class="PrimitiveType">Set</a><a id="7299" class="Symbol">}</a> <a id="7301" class="Symbol">(</a><a id="7302" href="../Lists/#7302" class="Bound">xs</a> <a id="7305" href="../Lists/#7305" class="Bound">ys</a> <a id="7308" class="Symbol">:</a> <a id="7310" href="../Lists/#1067" class="Datatype">List</a> <a id="7315" href="../Lists/#7292" class="Bound">A</a><a id="7316" class="Symbol">)</a>
  <a id="7320" class="Symbol">→</a> <a id="7322" href="../Lists/#6310" class="Function">length</a> <a id="7329" class="Symbol">(</a><a id="7330" href="../Lists/#7302" class="Bound">xs</a> <a id="7333" href="../Lists/#3467" class="Function Operator">++</a> <a id="7336" href="../Lists/#7305" class="Bound">ys</a><a id="7338" class="Symbol">)</a> <a id="7340" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="7342" href="../Lists/#6310" class="Function">length</a> <a id="7349" href="../Lists/#7302" class="Bound">xs</a> <a id="7352" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="7354" href="../Lists/#6310" class="Function">length</a> <a id="7361" href="../Lists/#7305" class="Bound">ys</a>
<a id="7364" href="../Lists/#7277" class="Function">length-++</a> <a id="7374" class="Symbol">{</a><a id="7375" href="../Lists/#7375" class="Bound">A</a><a id="7376" class="Symbol">}</a> <a id="7378" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="7381" href="../Lists/#7381" class="Bound">ys</a> <a id="7384" class="Symbol">=</a>
  <a id="7388" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="7398" href="../Lists/#6310" class="Function">length</a> <a id="7405" class="Symbol">(</a><a id="7406" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="7409" href="../Lists/#3467" class="Function Operator">++</a> <a id="7412" href="../Lists/#7381" class="Bound">ys</a><a id="7414" class="Symbol">)</a>
  <a id="7418" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="7426" href="../Lists/#6310" class="Function">length</a> <a id="7433" href="../Lists/#7381" class="Bound">ys</a>
  <a id="7438" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="7446" href="../Lists/#6310" class="Function">length</a> <a id="7453" class="Symbol">{</a><a id="7454" href="../Lists/#7375" class="Bound">A</a><a id="7455" class="Symbol">}</a> <a id="7457" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="7460" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="7462" href="../Lists/#6310" class="Function">length</a> <a id="7469" href="../Lists/#7381" class="Bound">ys</a>
  <a id="7474" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
<a id="7476" href="../Lists/#7277" class="Function">length-++</a> <a id="7486" class="Symbol">(</a><a id="7487" href="../Lists/#7487" class="Bound">x</a> <a id="7489" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="7491" href="../Lists/#7491" class="Bound">xs</a><a id="7493" class="Symbol">)</a> <a id="7495" href="../Lists/#7495" class="Bound">ys</a> <a id="7498" class="Symbol">=</a>
  <a id="7502" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="7512" href="../Lists/#6310" class="Function">length</a> <a id="7519" class="Symbol">((</a><a id="7521" href="../Lists/#7487" class="Bound">x</a> <a id="7523" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="7525" href="../Lists/#7491" class="Bound">xs</a><a id="7527" class="Symbol">)</a> <a id="7529" href="../Lists/#3467" class="Function Operator">++</a> <a id="7532" href="../Lists/#7495" class="Bound">ys</a><a id="7534" class="Symbol">)</a>
  <a id="7538" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="7546" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="7550" class="Symbol">(</a><a id="7551" href="../Lists/#6310" class="Function">length</a> <a id="7558" class="Symbol">(</a><a id="7559" href="../Lists/#7491" class="Bound">xs</a> <a id="7562" href="../Lists/#3467" class="Function Operator">++</a> <a id="7565" href="../Lists/#7495" class="Bound">ys</a><a id="7567" class="Symbol">))</a>
  <a id="7572" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="7575" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#1131" class="Function">cong</a> <a id="7580" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="7584" class="Symbol">(</a><a id="7585" href="../Lists/#7277" class="Function">length-++</a> <a id="7595" href="../Lists/#7491" class="Bound">xs</a> <a id="7598" href="../Lists/#7495" class="Bound">ys</a><a id="7600" class="Symbol">)</a> <a id="7602" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
    <a id="7608" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="7612" class="Symbol">(</a><a id="7613" href="../Lists/#6310" class="Function">length</a> <a id="7620" href="../Lists/#7491" class="Bound">xs</a> <a id="7623" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="7625" href="../Lists/#6310" class="Function">length</a> <a id="7632" href="../Lists/#7495" class="Bound">ys</a><a id="7634" class="Symbol">)</a>
  <a id="7638" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="7646" href="../Lists/#6310" class="Function">length</a> <a id="7653" class="Symbol">(</a><a id="7654" href="../Lists/#7487" class="Bound">x</a> <a id="7656" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="7658" href="../Lists/#7491" class="Bound">xs</a><a id="7660" class="Symbol">)</a> <a id="7662" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="7664" href="../Lists/#6310" class="Function">length</a> <a id="7671" href="../Lists/#7495" class="Bound">ys</a>
  <a id="7676" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<p>The proof is by induction on the first argument. The base case instantiates to <code>[]</code>, and follows by straightforward computation. As before, Agda cannot infer the implicit type parameter to <code>length</code>, and it must be given explicitly. The inductive case instantiates to <code>x ∷ xs</code>, and follows by straightforward computation combined with the inductive hypothesis. As usual, the inductive hypothesis is indicated by a recursive invocation of the proof, in this case <code>length-++ xs ys</code>, and it is promoted by the congruence <code>cong suc</code>.</p>
<h2 id="reverse">Reverse</h2>
Using append, it is easy to formulate a function to reverse a list:
<pre class="Agda"><a id="reverse"></a><a id="8300" href="../Lists/#8300" class="Function">reverse</a> <a id="8308" class="Symbol">:</a> <a id="8310" class="Symbol">∀</a> <a id="8312" class="Symbol">{</a><a id="8313" href="../Lists/#8313" class="Bound">A</a> <a id="8315" class="Symbol">:</a> <a id="8317" class="PrimitiveType">Set</a><a id="8320" class="Symbol">}</a> <a id="8322" class="Symbol">→</a> <a id="8324" href="../Lists/#1067" class="Datatype">List</a> <a id="8329" href="../Lists/#8313" class="Bound">A</a> <a id="8331" class="Symbol">→</a> <a id="8333" href="../Lists/#1067" class="Datatype">List</a> <a id="8338" href="../Lists/#8313" class="Bound">A</a>
<a id="8340" href="../Lists/#8300" class="Function">reverse</a> <a id="8348" href="../Lists/#1096" class="InductiveConstructor">[]</a>        <a id="8358" class="Symbol">=</a>  <a id="8361" href="../Lists/#1096" class="InductiveConstructor">[]</a>
<a id="8364" href="../Lists/#8300" class="Function">reverse</a> <a id="8372" class="Symbol">(</a><a id="8373" href="../Lists/#8373" class="Bound">x</a> <a id="8375" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="8377" href="../Lists/#8377" class="Bound">xs</a><a id="8379" class="Symbol">)</a>  <a id="8382" class="Symbol">=</a>  <a id="8385" href="../Lists/#8300" class="Function">reverse</a> <a id="8393" href="../Lists/#8377" class="Bound">xs</a> <a id="8396" href="../Lists/#3467" class="Function Operator">++</a> <a id="8399" href="../Lists/#2827" class="InductiveConstructor Operator">[</a> <a id="8401" href="../Lists/#8373" class="Bound">x</a> <a id="8403" href="../Lists/#2827" class="InductiveConstructor Operator">]</a>
</pre>
<p>The reverse of the empty list is the empty list. The reverse of a non-empty list is the reverse of its tail appended to a unit list containing its head.</p>
Here is an example showing how to reverse a list:
<pre class="Agda"><a id="8617" href="../Lists/#8617" class="Function">_</a> <a id="8619" class="Symbol">:</a> <a id="8621" href="../Lists/#8300" class="Function">reverse</a> <a id="8629" href="../Lists/#2881" class="InductiveConstructor Operator">[</a> <a id="8631" class="Number">0</a> <a id="8633" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="8635" class="Number">1</a> <a id="8637" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="8639" class="Number">2</a> <a id="8641" href="../Lists/#2881" class="InductiveConstructor Operator">]</a> <a id="8643" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="8645" href="../Lists/#2881" class="InductiveConstructor Operator">[</a> <a id="8647" class="Number">2</a> <a id="8649" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="8651" class="Number">1</a> <a id="8653" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="8655" class="Number">0</a> <a id="8657" href="../Lists/#2881" class="InductiveConstructor Operator">]</a>
<a id="8659" class="Symbol">_</a> <a id="8661" class="Symbol">=</a>
  <a id="8665" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="8675" href="../Lists/#8300" class="Function">reverse</a> <a id="8683" class="Symbol">(</a><a id="8684" class="Number">0</a> <a id="8686" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="8688" class="Number">1</a> <a id="8690" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="8692" class="Number">2</a> <a id="8694" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="8696" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="8698" class="Symbol">)</a>
  <a id="8702" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="8710" href="../Lists/#8300" class="Function">reverse</a> <a id="8718" class="Symbol">(</a><a id="8719" class="Number">1</a> <a id="8721" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="8723" class="Number">2</a> <a id="8725" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="8727" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="8729" class="Symbol">)</a> <a id="8731" href="../Lists/#3467" class="Function Operator">++</a> <a id="8734" href="../Lists/#2827" class="InductiveConstructor Operator">[</a> <a id="8736" class="Number">0</a> <a id="8738" href="../Lists/#2827" class="InductiveConstructor Operator">]</a>
  <a id="8742" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="8750" class="Symbol">(</a><a id="8751" href="../Lists/#8300" class="Function">reverse</a> <a id="8759" class="Symbol">(</a><a id="8760" class="Number">2</a> <a id="8762" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="8764" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="8766" class="Symbol">)</a> <a id="8768" href="../Lists/#3467" class="Function Operator">++</a> <a id="8771" href="../Lists/#2827" class="InductiveConstructor Operator">[</a> <a id="8773" class="Number">1</a> <a id="8775" href="../Lists/#2827" class="InductiveConstructor Operator">]</a><a id="8776" class="Symbol">)</a> <a id="8778" href="../Lists/#3467" class="Function Operator">++</a> <a id="8781" href="../Lists/#2827" class="InductiveConstructor Operator">[</a> <a id="8783" class="Number">0</a> <a id="8785" href="../Lists/#2827" class="InductiveConstructor Operator">]</a>
  <a id="8789" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="8797" class="Symbol">((</a><a id="8799" href="../Lists/#8300" class="Function">reverse</a> <a id="8807" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="8810" href="../Lists/#3467" class="Function Operator">++</a> <a id="8813" href="../Lists/#2827" class="InductiveConstructor Operator">[</a> <a id="8815" class="Number">2</a> <a id="8817" href="../Lists/#2827" class="InductiveConstructor Operator">]</a><a id="8818" class="Symbol">)</a> <a id="8820" href="../Lists/#3467" class="Function Operator">++</a> <a id="8823" href="../Lists/#2827" class="InductiveConstructor Operator">[</a> <a id="8825" class="Number">1</a> <a id="8827" href="../Lists/#2827" class="InductiveConstructor Operator">]</a><a id="8828" class="Symbol">)</a> <a id="8830" href="../Lists/#3467" class="Function Operator">++</a> <a id="8833" href="../Lists/#2827" class="InductiveConstructor Operator">[</a> <a id="8835" class="Number">0</a> <a id="8837" href="../Lists/#2827" class="InductiveConstructor Operator">]</a>
  <a id="8841" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="8849" class="Symbol">((</a><a id="8851" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="8854" href="../Lists/#3467" class="Function Operator">++</a> <a id="8857" href="../Lists/#2827" class="InductiveConstructor Operator">[</a> <a id="8859" class="Number">2</a> <a id="8861" href="../Lists/#2827" class="InductiveConstructor Operator">]</a><a id="8862" class="Symbol">)</a> <a id="8864" href="../Lists/#3467" class="Function Operator">++</a> <a id="8867" href="../Lists/#2827" class="InductiveConstructor Operator">[</a> <a id="8869" class="Number">1</a> <a id="8871" href="../Lists/#2827" class="InductiveConstructor Operator">]</a><a id="8872" class="Symbol">)</a> <a id="8874" href="../Lists/#3467" class="Function Operator">++</a> <a id="8877" href="../Lists/#2827" class="InductiveConstructor Operator">[</a> <a id="8879" class="Number">0</a> <a id="8881" href="../Lists/#2827" class="InductiveConstructor Operator">]</a>
  <a id="8885" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="8893" class="Symbol">((</a><a id="8895" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="8898" href="../Lists/#3467" class="Function Operator">++</a> <a id="8901" class="Number">2</a> <a id="8903" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="8905" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="8907" class="Symbol">)</a> <a id="8909" href="../Lists/#3467" class="Function Operator">++</a> <a id="8912" class="Number">1</a> <a id="8914" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="8916" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="8918" class="Symbol">)</a> <a id="8920" href="../Lists/#3467" class="Function Operator">++</a> <a id="8923" class="Number">0</a> <a id="8925" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="8927" href="../Lists/#1096" class="InductiveConstructor">[]</a>
  <a id="8932" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="8940" class="Symbol">(</a><a id="8941" class="Number">2</a> <a id="8943" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="8945" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="8948" href="../Lists/#3467" class="Function Operator">++</a> <a id="8951" class="Number">1</a> <a id="8953" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="8955" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="8957" class="Symbol">)</a> <a id="8959" href="../Lists/#3467" class="Function Operator">++</a> <a id="8962" class="Number">0</a> <a id="8964" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="8966" href="../Lists/#1096" class="InductiveConstructor">[]</a>
  <a id="8971" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="8979" class="Number">2</a> <a id="8981" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="8983" class="Symbol">(</a><a id="8984" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="8987" href="../Lists/#3467" class="Function Operator">++</a> <a id="8990" class="Number">1</a> <a id="8992" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="8994" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="8996" class="Symbol">)</a> <a id="8998" href="../Lists/#3467" class="Function Operator">++</a> <a id="9001" class="Number">0</a> <a id="9003" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="9005" href="../Lists/#1096" class="InductiveConstructor">[]</a>
  <a id="9010" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="9018" class="Symbol">(</a><a id="9019" class="Number">2</a> <a id="9021" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="9023" class="Number">1</a> <a id="9025" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="9027" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="9029" class="Symbol">)</a> <a id="9031" href="../Lists/#3467" class="Function Operator">++</a> <a id="9034" class="Number">0</a> <a id="9036" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="9038" href="../Lists/#1096" class="InductiveConstructor">[]</a>
  <a id="9043" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="9051" class="Number">2</a> <a id="9053" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="9055" class="Symbol">(</a><a id="9056" class="Number">1</a> <a id="9058" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="9060" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="9063" href="../Lists/#3467" class="Function Operator">++</a> <a id="9066" class="Number">0</a> <a id="9068" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="9070" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="9072" class="Symbol">)</a>
  <a id="9076" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="9084" class="Number">2</a> <a id="9086" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="9088" class="Number">1</a> <a id="9090" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="9092" class="Symbol">(</a><a id="9093" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="9096" href="../Lists/#3467" class="Function Operator">++</a> <a id="9099" class="Number">0</a> <a id="9101" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="9103" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="9105" class="Symbol">)</a>
  <a id="9109" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="9117" class="Number">2</a> <a id="9119" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="9121" class="Number">1</a> <a id="9123" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="9125" class="Number">0</a> <a id="9127" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="9129" href="../Lists/#1096" class="InductiveConstructor">[]</a>
  <a id="9134" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="9142" href="../Lists/#2881" class="InductiveConstructor Operator">[</a> <a id="9144" class="Number">2</a> <a id="9146" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="9148" class="Number">1</a> <a id="9150" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="9152" class="Number">0</a> <a id="9154" href="../Lists/#2881" class="InductiveConstructor Operator">]</a>
  <a id="9158" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<p>Reversing a list in this way takes time <em>quadratic</em> in the length of the list. This is because reverse ends up appending lists of lengths <code>1</code>, <code>2</code>, up to <code>n - 1</code>, where <code>n</code> is the length of the list being reversed, append takes time linear in the length of the first list, and the sum of the numbers up to <code>n - 1</code> is <code>n * (n - 1) / 2</code>. (We will validate that last fact in an exercise later in this chapter.)</p>
<h4 id="exercise-reverse--distrib-recommended">Exercise <code>reverse-++-distrib</code> (recommended)</h4>
<p>Show that the reverse of one list appended to another is the reverse of the second appended to the reverse of the first:</p>
<pre><code>reverse (xs ++ ys) ≡ reverse ys ++ reverse xs</code></pre>
<h4 id="exercise-reverse-involutive-recommended">Exercise <code>reverse-involutive</code> (recommended)</h4>
<p>A function is an <em>involution</em> if when applied twice it acts as the identity function. Show that reverse is an involution:</p>
<pre><code>reverse (reverse xs) ≡ xs</code></pre>
<h2 id="faster-reverse">Faster reverse</h2>
The definition above, while easy to reason about, is less efficient than one might expect since it takes time quadratic in the length of the list. The idea is that we generalise reverse to take an additional argument:
<pre class="Agda"><a id="shunt"></a><a id="10244" href="../Lists/#10244" class="Function">shunt</a> <a id="10250" class="Symbol">:</a> <a id="10252" class="Symbol">∀</a> <a id="10254" class="Symbol">{</a><a id="10255" href="../Lists/#10255" class="Bound">A</a> <a id="10257" class="Symbol">:</a> <a id="10259" class="PrimitiveType">Set</a><a id="10262" class="Symbol">}</a> <a id="10264" class="Symbol">→</a> <a id="10266" href="../Lists/#1067" class="Datatype">List</a> <a id="10271" href="../Lists/#10255" class="Bound">A</a> <a id="10273" class="Symbol">→</a> <a id="10275" href="../Lists/#1067" class="Datatype">List</a> <a id="10280" href="../Lists/#10255" class="Bound">A</a> <a id="10282" class="Symbol">→</a> <a id="10284" href="../Lists/#1067" class="Datatype">List</a> <a id="10289" href="../Lists/#10255" class="Bound">A</a>
<a id="10291" href="../Lists/#10244" class="Function">shunt</a> <a id="10297" href="../Lists/#1096" class="InductiveConstructor">[]</a>       <a id="10306" href="../Lists/#10306" class="Bound">ys</a>  <a id="10310" class="Symbol">=</a>  <a id="10313" href="../Lists/#10306" class="Bound">ys</a>
<a id="10316" href="../Lists/#10244" class="Function">shunt</a> <a id="10322" class="Symbol">(</a><a id="10323" href="../Lists/#10323" class="Bound">x</a> <a id="10325" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="10327" href="../Lists/#10327" class="Bound">xs</a><a id="10329" class="Symbol">)</a> <a id="10331" href="../Lists/#10331" class="Bound">ys</a>  <a id="10335" class="Symbol">=</a>  <a id="10338" href="../Lists/#10244" class="Function">shunt</a> <a id="10344" href="../Lists/#10327" class="Bound">xs</a> <a id="10347" class="Symbol">(</a><a id="10348" href="../Lists/#10323" class="Bound">x</a> <a id="10350" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="10352" href="../Lists/#10331" class="Bound">ys</a><a id="10354" class="Symbol">)</a>
</pre>
<p>The definition is by recursion on the first argument. The second argument actually becomes <em>larger</em>, but this is not a problem because the argument on which we recurse becomes <em>smaller</em>.</p>
Shunt is related to reverse as follows:
<pre class="Agda"><a id="shunt-reverse"></a><a id="10592" href="../Lists/#10592" class="Function">shunt-reverse</a> <a id="10606" class="Symbol">:</a> <a id="10608" class="Symbol">∀</a> <a id="10610" class="Symbol">{</a><a id="10611" href="../Lists/#10611" class="Bound">A</a> <a id="10613" class="Symbol">:</a> <a id="10615" class="PrimitiveType">Set</a><a id="10618" class="Symbol">}</a> <a id="10620" class="Symbol">(</a><a id="10621" href="../Lists/#10621" class="Bound">xs</a> <a id="10624" href="../Lists/#10624" class="Bound">ys</a> <a id="10627" class="Symbol">:</a> <a id="10629" href="../Lists/#1067" class="Datatype">List</a> <a id="10634" href="../Lists/#10611" class="Bound">A</a><a id="10635" class="Symbol">)</a>
  <a id="10639" class="Symbol">→</a> <a id="10641" href="../Lists/#10244" class="Function">shunt</a> <a id="10647" href="../Lists/#10621" class="Bound">xs</a> <a id="10650" href="../Lists/#10624" class="Bound">ys</a> <a id="10653" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="10655" href="../Lists/#8300" class="Function">reverse</a> <a id="10663" href="../Lists/#10621" class="Bound">xs</a> <a id="10666" href="../Lists/#3467" class="Function Operator">++</a> <a id="10669" href="../Lists/#10624" class="Bound">ys</a>
<a id="10672" href="../Lists/#10592" class="Function">shunt-reverse</a> <a id="10686" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="10689" href="../Lists/#10689" class="Bound">ys</a> <a id="10692" class="Symbol">=</a>
  <a id="10696" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="10706" href="../Lists/#10244" class="Function">shunt</a> <a id="10712" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="10715" href="../Lists/#10689" class="Bound">ys</a>
  <a id="10720" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="10728" href="../Lists/#10689" class="Bound">ys</a>
  <a id="10733" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="10741" href="../Lists/#8300" class="Function">reverse</a> <a id="10749" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="10752" href="../Lists/#3467" class="Function Operator">++</a> <a id="10755" href="../Lists/#10689" class="Bound">ys</a>
  <a id="10760" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
<a id="10762" href="../Lists/#10592" class="Function">shunt-reverse</a> <a id="10776" class="Symbol">(</a><a id="10777" href="../Lists/#10777" class="Bound">x</a> <a id="10779" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="10781" href="../Lists/#10781" class="Bound">xs</a><a id="10783" class="Symbol">)</a> <a id="10785" href="../Lists/#10785" class="Bound">ys</a> <a id="10788" class="Symbol">=</a>
  <a id="10792" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="10802" href="../Lists/#10244" class="Function">shunt</a> <a id="10808" class="Symbol">(</a><a id="10809" href="../Lists/#10777" class="Bound">x</a> <a id="10811" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="10813" href="../Lists/#10781" class="Bound">xs</a><a id="10815" class="Symbol">)</a> <a id="10817" href="../Lists/#10785" class="Bound">ys</a>
  <a id="10822" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="10830" href="../Lists/#10244" class="Function">shunt</a> <a id="10836" href="../Lists/#10781" class="Bound">xs</a> <a id="10839" class="Symbol">(</a><a id="10840" href="../Lists/#10777" class="Bound">x</a> <a id="10842" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="10844" href="../Lists/#10785" class="Bound">ys</a><a id="10846" class="Symbol">)</a>
  <a id="10850" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="10853" href="../Lists/#10592" class="Function">shunt-reverse</a> <a id="10867" href="../Lists/#10781" class="Bound">xs</a> <a id="10870" class="Symbol">(</a><a id="10871" href="../Lists/#10777" class="Bound">x</a> <a id="10873" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="10875" href="../Lists/#10785" class="Bound">ys</a><a id="10877" class="Symbol">)</a> <a id="10879" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
    <a id="10885" href="../Lists/#8300" class="Function">reverse</a> <a id="10893" href="../Lists/#10781" class="Bound">xs</a> <a id="10896" href="../Lists/#3467" class="Function Operator">++</a> <a id="10899" class="Symbol">(</a><a id="10900" href="../Lists/#10777" class="Bound">x</a> <a id="10902" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="10904" href="../Lists/#10785" class="Bound">ys</a><a id="10906" class="Symbol">)</a>
  <a id="10910" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="10918" href="../Lists/#8300" class="Function">reverse</a> <a id="10926" href="../Lists/#10781" class="Bound">xs</a> <a id="10929" href="../Lists/#3467" class="Function Operator">++</a> <a id="10932" class="Symbol">(</a><a id="10933" href="../Lists/#2827" class="InductiveConstructor Operator">[</a> <a id="10935" href="../Lists/#10777" class="Bound">x</a> <a id="10937" href="../Lists/#2827" class="InductiveConstructor Operator">]</a> <a id="10939" href="../Lists/#3467" class="Function Operator">++</a> <a id="10942" href="../Lists/#10785" class="Bound">ys</a><a id="10944" class="Symbol">)</a>
  <a id="10948" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="10951" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#980" class="Function">sym</a> <a id="10955" class="Symbol">(</a><a id="10956" href="../Lists/#4528" class="Function">++-assoc</a> <a id="10965" class="Symbol">(</a><a id="10966" href="../Lists/#8300" class="Function">reverse</a> <a id="10974" href="../Lists/#10781" class="Bound">xs</a><a id="10976" class="Symbol">)</a> <a id="10978" href="../Lists/#2827" class="InductiveConstructor Operator">[</a> <a id="10980" href="../Lists/#10777" class="Bound">x</a> <a id="10982" href="../Lists/#2827" class="InductiveConstructor Operator">]</a> <a id="10984" href="../Lists/#10785" class="Bound">ys</a><a id="10986" class="Symbol">)</a> <a id="10988" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
    <a id="10994" class="Symbol">(</a><a id="10995" href="../Lists/#8300" class="Function">reverse</a> <a id="11003" href="../Lists/#10781" class="Bound">xs</a> <a id="11006" href="../Lists/#3467" class="Function Operator">++</a> <a id="11009" href="../Lists/#2827" class="InductiveConstructor Operator">[</a> <a id="11011" href="../Lists/#10777" class="Bound">x</a> <a id="11013" href="../Lists/#2827" class="InductiveConstructor Operator">]</a><a id="11014" class="Symbol">)</a> <a id="11016" href="../Lists/#3467" class="Function Operator">++</a> <a id="11019" href="../Lists/#10785" class="Bound">ys</a>
  <a id="11024" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="11032" href="../Lists/#8300" class="Function">reverse</a> <a id="11040" class="Symbol">(</a><a id="11041" href="../Lists/#10777" class="Bound">x</a> <a id="11043" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="11045" href="../Lists/#10781" class="Bound">xs</a><a id="11047" class="Symbol">)</a> <a id="11049" href="../Lists/#3467" class="Function Operator">++</a> <a id="11052" href="../Lists/#10785" class="Bound">ys</a>
  <a id="11057" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<p>The proof is by induction on the first argument. The base case instantiates to <code>[]</code>, and follows by straightforward computation. The inductive case instantiates to <code>x ∷ xs</code> and follows by the inductive hypothesis and associativity of append. When we invoke the inductive hypothesis, the second argument actually becomes <em>larger</em>, but this is not a problem because the argument on which we induct becomes <em>smaller</em>.</p>
<p>Generalising on an auxiliary argument, which becomes larger as the argument on which we recurse or induct becomes smaller, is a common trick. It belongs in your quiver of arrows, ready to slay the right problem.</p>
Having defined shunt be generalisation, it is now easy to respecialise to give a more efficient definition of reverse:
<pre class="Agda"><a id="reverse′"></a><a id="11816" href="../Lists/#11816" class="Function">reverse′</a> <a id="11825" class="Symbol">:</a> <a id="11827" class="Symbol">∀</a> <a id="11829" class="Symbol">{</a><a id="11830" href="../Lists/#11830" class="Bound">A</a> <a id="11832" class="Symbol">:</a> <a id="11834" class="PrimitiveType">Set</a><a id="11837" class="Symbol">}</a> <a id="11839" class="Symbol">→</a> <a id="11841" href="../Lists/#1067" class="Datatype">List</a> <a id="11846" href="../Lists/#11830" class="Bound">A</a> <a id="11848" class="Symbol">→</a> <a id="11850" href="../Lists/#1067" class="Datatype">List</a> <a id="11855" href="../Lists/#11830" class="Bound">A</a>
<a id="11857" href="../Lists/#11816" class="Function">reverse′</a> <a id="11866" href="../Lists/#11866" class="Bound">xs</a> <a id="11869" class="Symbol">=</a> <a id="11871" href="../Lists/#10244" class="Function">shunt</a> <a id="11877" href="../Lists/#11866" class="Bound">xs</a> <a id="11880" href="../Lists/#1096" class="InductiveConstructor">[]</a>
</pre>
Given our previous lemma, it is straightforward to show the two definitions equivalent:
<pre class="Agda"><a id="reverses"></a><a id="11980" href="../Lists/#11980" class="Function">reverses</a> <a id="11989" class="Symbol">:</a> <a id="11991" class="Symbol">∀</a> <a id="11993" class="Symbol">{</a><a id="11994" href="../Lists/#11994" class="Bound">A</a> <a id="11996" class="Symbol">:</a> <a id="11998" class="PrimitiveType">Set</a><a id="12001" class="Symbol">}</a> <a id="12003" class="Symbol">(</a><a id="12004" href="../Lists/#12004" class="Bound">xs</a> <a id="12007" class="Symbol">:</a> <a id="12009" href="../Lists/#1067" class="Datatype">List</a> <a id="12014" href="../Lists/#11994" class="Bound">A</a><a id="12015" class="Symbol">)</a>
  <a id="12019" class="Symbol">→</a> <a id="12021" href="../Lists/#11816" class="Function">reverse′</a> <a id="12030" href="../Lists/#12004" class="Bound">xs</a> <a id="12033" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="12035" href="../Lists/#8300" class="Function">reverse</a> <a id="12043" href="../Lists/#12004" class="Bound">xs</a>
<a id="12046" href="../Lists/#11980" class="Function">reverses</a> <a id="12055" href="../Lists/#12055" class="Bound">xs</a> <a id="12058" class="Symbol">=</a>
  <a id="12062" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="12072" href="../Lists/#11816" class="Function">reverse′</a> <a id="12081" href="../Lists/#12055" class="Bound">xs</a>
  <a id="12086" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="12094" href="../Lists/#10244" class="Function">shunt</a> <a id="12100" href="../Lists/#12055" class="Bound">xs</a> <a id="12103" href="../Lists/#1096" class="InductiveConstructor">[]</a>
  <a id="12108" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="12111" href="../Lists/#10592" class="Function">shunt-reverse</a> <a id="12125" href="../Lists/#12055" class="Bound">xs</a> <a id="12128" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="12131" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
    <a id="12137" href="../Lists/#8300" class="Function">reverse</a> <a id="12145" href="../Lists/#12055" class="Bound">xs</a> <a id="12148" href="../Lists/#3467" class="Function Operator">++</a> <a id="12151" href="../Lists/#1096" class="InductiveConstructor">[]</a>
  <a id="12156" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="12159" href="../Lists/#5899" class="Function">++-identityʳ</a> <a id="12172" class="Symbol">(</a><a id="12173" href="../Lists/#8300" class="Function">reverse</a> <a id="12181" href="../Lists/#12055" class="Bound">xs</a><a id="12183" class="Symbol">)</a> <a id="12185" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
    <a id="12191" href="../Lists/#8300" class="Function">reverse</a> <a id="12199" href="../Lists/#12055" class="Bound">xs</a>
  <a id="12204" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
Here is an example showing fast reverse of the list <code>[ 0 , 1 , 2 ]</code>:
<pre class="Agda"><a id="12284" href="../Lists/#12284" class="Function">_</a> <a id="12286" class="Symbol">:</a> <a id="12288" href="../Lists/#11816" class="Function">reverse′</a> <a id="12297" href="../Lists/#2881" class="InductiveConstructor Operator">[</a> <a id="12299" class="Number">0</a> <a id="12301" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="12303" class="Number">1</a> <a id="12305" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="12307" class="Number">2</a> <a id="12309" href="../Lists/#2881" class="InductiveConstructor Operator">]</a> <a id="12311" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="12313" href="../Lists/#2881" class="InductiveConstructor Operator">[</a> <a id="12315" class="Number">2</a> <a id="12317" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="12319" class="Number">1</a> <a id="12321" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="12323" class="Number">0</a> <a id="12325" href="../Lists/#2881" class="InductiveConstructor Operator">]</a>
<a id="12327" class="Symbol">_</a> <a id="12329" class="Symbol">=</a>
  <a id="12333" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="12343" href="../Lists/#11816" class="Function">reverse′</a> <a id="12352" class="Symbol">(</a><a id="12353" class="Number">0</a> <a id="12355" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="12357" class="Number">1</a> <a id="12359" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="12361" class="Number">2</a> <a id="12363" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="12365" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="12367" class="Symbol">)</a>
  <a id="12371" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="12379" href="../Lists/#10244" class="Function">shunt</a> <a id="12385" class="Symbol">(</a><a id="12386" class="Number">0</a> <a id="12388" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="12390" class="Number">1</a> <a id="12392" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="12394" class="Number">2</a> <a id="12396" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="12398" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="12400" class="Symbol">)</a> <a id="12402" href="../Lists/#1096" class="InductiveConstructor">[]</a>
  <a id="12407" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="12415" href="../Lists/#10244" class="Function">shunt</a> <a id="12421" class="Symbol">(</a><a id="12422" class="Number">1</a> <a id="12424" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="12426" class="Number">2</a> <a id="12428" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="12430" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="12432" class="Symbol">)</a> <a id="12434" class="Symbol">(</a><a id="12435" class="Number">0</a> <a id="12437" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="12439" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="12441" class="Symbol">)</a>
  <a id="12445" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="12453" href="../Lists/#10244" class="Function">shunt</a> <a id="12459" class="Symbol">(</a><a id="12460" class="Number">2</a> <a id="12462" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="12464" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="12466" class="Symbol">)</a> <a id="12468" class="Symbol">(</a><a id="12469" class="Number">1</a> <a id="12471" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="12473" class="Number">0</a> <a id="12475" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="12477" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="12479" class="Symbol">)</a>
  <a id="12483" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="12491" href="../Lists/#10244" class="Function">shunt</a> <a id="12497" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="12500" class="Symbol">(</a><a id="12501" class="Number">2</a> <a id="12503" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="12505" class="Number">1</a> <a id="12507" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="12509" class="Number">0</a> <a id="12511" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="12513" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="12515" class="Symbol">)</a>
  <a id="12519" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="12527" class="Number">2</a> <a id="12529" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="12531" class="Number">1</a> <a id="12533" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="12535" class="Number">0</a> <a id="12537" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="12539" href="../Lists/#1096" class="InductiveConstructor">[]</a>
  <a id="12544" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<p>Now the time to reverse a list is linear in the length of the list.</p>
<h2 id="Map">Map</h2>
Map applies a function to every element of a list to generate a corresponding list. Map is an example of a <em>higher-order function</em>, one which takes a function as an argument or returns a function as a result:
<pre class="Agda"><a id="map"></a><a id="12847" href="../Lists/#12847" class="Function">map</a> <a id="12851" class="Symbol">:</a> <a id="12853" class="Symbol">∀</a> <a id="12855" class="Symbol">{</a><a id="12856" href="../Lists/#12856" class="Bound">A</a> <a id="12858" href="../Lists/#12858" class="Bound">B</a> <a id="12860" class="Symbol">:</a> <a id="12862" class="PrimitiveType">Set</a><a id="12865" class="Symbol">}</a> <a id="12867" class="Symbol">→</a> <a id="12869" class="Symbol">(</a><a id="12870" href="../Lists/#12856" class="Bound">A</a> <a id="12872" class="Symbol">→</a> <a id="12874" href="../Lists/#12858" class="Bound">B</a><a id="12875" class="Symbol">)</a> <a id="12877" class="Symbol">→</a> <a id="12879" href="../Lists/#1067" class="Datatype">List</a> <a id="12884" href="../Lists/#12856" class="Bound">A</a> <a id="12886" class="Symbol">→</a> <a id="12888" href="../Lists/#1067" class="Datatype">List</a> <a id="12893" href="../Lists/#12858" class="Bound">B</a>
<a id="12895" href="../Lists/#12847" class="Function">map</a> <a id="12899" href="../Lists/#12899" class="Bound">f</a> <a id="12901" href="../Lists/#1096" class="InductiveConstructor">[]</a>        <a id="12911" class="Symbol">=</a>  <a id="12914" href="../Lists/#1096" class="InductiveConstructor">[]</a>
<a id="12917" href="../Lists/#12847" class="Function">map</a> <a id="12921" href="../Lists/#12921" class="Bound">f</a> <a id="12923" class="Symbol">(</a><a id="12924" href="../Lists/#12924" class="Bound">x</a> <a id="12926" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="12928" href="../Lists/#12928" class="Bound">xs</a><a id="12930" class="Symbol">)</a>  <a id="12933" class="Symbol">=</a>  <a id="12936" href="../Lists/#12921" class="Bound">f</a> <a id="12938" href="../Lists/#12924" class="Bound">x</a> <a id="12940" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="12942" href="../Lists/#12847" class="Function">map</a> <a id="12946" href="../Lists/#12921" class="Bound">f</a> <a id="12948" href="../Lists/#12928" class="Bound">xs</a>
</pre>
<p>Map of the empty list is the empty list. Map of a non-empty list yields a list with head the same as the function applied to the head of the given list, and tail the same as map of the function applied to the tail of the given list.</p>
Here is an example showing how to use map to increment every element of a list:
<pre class="Agda"><a id="13273" href="../Lists/#13273" class="Function">_</a> <a id="13275" class="Symbol">:</a> <a id="13277" href="../Lists/#12847" class="Function">map</a> <a id="13281" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="13285" href="../Lists/#2881" class="InductiveConstructor Operator">[</a> <a id="13287" class="Number">0</a> <a id="13289" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="13291" class="Number">1</a> <a id="13293" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="13295" class="Number">2</a> <a id="13297" href="../Lists/#2881" class="InductiveConstructor Operator">]</a> <a id="13299" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="13301" href="../Lists/#2881" class="InductiveConstructor Operator">[</a> <a id="13303" class="Number">1</a> <a id="13305" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="13307" class="Number">2</a> <a id="13309" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="13311" class="Number">3</a> <a id="13313" href="../Lists/#2881" class="InductiveConstructor Operator">]</a>
<a id="13315" class="Symbol">_</a> <a id="13317" class="Symbol">=</a>
  <a id="13321" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="13331" href="../Lists/#12847" class="Function">map</a> <a id="13335" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="13339" class="Symbol">(</a><a id="13340" class="Number">0</a> <a id="13342" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="13344" class="Number">1</a> <a id="13346" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="13348" class="Number">2</a> <a id="13350" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="13352" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="13354" class="Symbol">)</a>
  <a id="13358" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="13366" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="13370" class="Number">0</a> <a id="13372" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="13374" href="../Lists/#12847" class="Function">map</a> <a id="13378" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="13382" class="Symbol">(</a><a id="13383" class="Number">1</a> <a id="13385" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="13387" class="Number">2</a> <a id="13389" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="13391" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="13393" class="Symbol">)</a>
  <a id="13397" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="13405" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="13409" class="Number">0</a> <a id="13411" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="13413" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="13417" class="Number">1</a> <a id="13419" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="13421" href="../Lists/#12847" class="Function">map</a> <a id="13425" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="13429" class="Symbol">(</a><a id="13430" class="Number">2</a> <a id="13432" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="13434" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="13436" class="Symbol">)</a>
  <a id="13440" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="13448" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="13452" class="Number">0</a> <a id="13454" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="13456" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="13460" class="Number">1</a> <a id="13462" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="13464" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="13468" class="Number">2</a> <a id="13470" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="13472" href="../Lists/#12847" class="Function">map</a> <a id="13476" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="13480" href="../Lists/#1096" class="InductiveConstructor">[]</a>
  <a id="13485" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="13493" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="13497" class="Number">0</a> <a id="13499" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="13501" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="13505" class="Number">1</a> <a id="13507" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="13509" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="13513" class="Number">2</a> <a id="13515" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="13517" href="../Lists/#1096" class="InductiveConstructor">[]</a>
  <a id="13522" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="13530" class="Number">1</a> <a id="13532" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="13534" class="Number">2</a> <a id="13536" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="13538" class="Number">3</a> <a id="13540" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="13542" href="../Lists/#1096" class="InductiveConstructor">[]</a>
  <a id="13547" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<p>Map requires time linear in the length of the list.</p>
It is often convenient to exploit currying by applying map to a function to yield a new function, and at a later point applying the resulting function:
<pre class="Agda"><a id="sucs"></a><a id="13762" href="../Lists/#13762" class="Function">sucs</a> <a id="13767" class="Symbol">:</a> <a id="13769" href="../Lists/#1067" class="Datatype">List</a> <a id="13774" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="13776" class="Symbol">→</a> <a id="13778" href="../Lists/#1067" class="Datatype">List</a> <a id="13783" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="13785" href="../Lists/#13762" class="Function">sucs</a> <a id="13790" class="Symbol">=</a> <a id="13792" href="../Lists/#12847" class="Function">map</a> <a id="13796" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a>

<a id="13801" href="../Lists/#13801" class="Function">_</a> <a id="13803" class="Symbol">:</a> <a id="13805" href="../Lists/#13762" class="Function">sucs</a> <a id="13810" href="../Lists/#2881" class="InductiveConstructor Operator">[</a> <a id="13812" class="Number">0</a> <a id="13814" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="13816" class="Number">1</a> <a id="13818" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="13820" class="Number">2</a> <a id="13822" href="../Lists/#2881" class="InductiveConstructor Operator">]</a> <a id="13824" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="13826" href="../Lists/#2881" class="InductiveConstructor Operator">[</a> <a id="13828" class="Number">1</a> <a id="13830" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="13832" class="Number">2</a> <a id="13834" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="13836" class="Number">3</a> <a id="13838" href="../Lists/#2881" class="InductiveConstructor Operator">]</a>
<a id="13840" class="Symbol">_</a> <a id="13842" class="Symbol">=</a>
  <a id="13846" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="13856" href="../Lists/#13762" class="Function">sucs</a> <a id="13861" href="../Lists/#2881" class="InductiveConstructor Operator">[</a> <a id="13863" class="Number">0</a> <a id="13865" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="13867" class="Number">1</a> <a id="13869" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="13871" class="Number">2</a> <a id="13873" href="../Lists/#2881" class="InductiveConstructor Operator">]</a>
  <a id="13877" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="13885" href="../Lists/#12847" class="Function">map</a> <a id="13889" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="13893" href="../Lists/#2881" class="InductiveConstructor Operator">[</a> <a id="13895" class="Number">0</a> <a id="13897" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="13899" class="Number">1</a> <a id="13901" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="13903" class="Number">2</a> <a id="13905" href="../Lists/#2881" class="InductiveConstructor Operator">]</a>
  <a id="13909" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="13917" href="../Lists/#2881" class="InductiveConstructor Operator">[</a> <a id="13919" class="Number">1</a> <a id="13921" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="13923" class="Number">2</a> <a id="13925" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="13927" class="Number">3</a> <a id="13929" href="../Lists/#2881" class="InductiveConstructor Operator">]</a>
  <a id="13933" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<p>Any type that is parameterised on another type, such as lists, has a corresponding map, which accepts a function and returns a function from the type parameterised on the domain of the function to the type parameterised on the range of the function. Further, a type that is parameterised on <em>n</em> types will have a map that is parameterised on <em>n</em> functions.</p>
<h4 id="exercise-map-compose-practice">Exercise <code>map-compose</code> (practice)</h4>
<p>Prove that the map of a composition is equal to the composition of two maps:</p>
<pre><code>map (g ∘ f) ≡ map g ∘ map f</code></pre>
<p>The last step of the proof requires extensionality.</p>
<pre class="Agda"><a id="14507" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise-map--distribute-practice">Exercise <code>map-++-distribute</code> (practice)</h4>
<p>Prove the following relationship between map and append:</p>
<pre><code>map f (xs ++ ys) ≡ map f xs ++ map f ys</code></pre>
<pre class="Agda"><a id="14688" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise-map-tree-practice">Exercise <code>map-Tree</code> (practice)</h4>
Define a type of trees with leaves of type <code>A</code> and internal nodes of type <code>B</code>:
<pre class="Agda"><a id="14836" class="Keyword">data</a> <a id="Tree"></a><a id="14841" href="../Lists/#14841" class="Datatype">Tree</a> <a id="14846" class="Symbol">(</a><a id="14847" href="../Lists/#14847" class="Bound">A</a> <a id="14849" href="../Lists/#14849" class="Bound">B</a> <a id="14851" class="Symbol">:</a> <a id="14853" class="PrimitiveType">Set</a><a id="14856" class="Symbol">)</a> <a id="14858" class="Symbol">:</a> <a id="14860" class="PrimitiveType">Set</a> <a id="14864" class="Keyword">where</a>
  <a id="Tree.leaf"></a><a id="14872" href="../Lists/#14872" class="InductiveConstructor">leaf</a> <a id="14877" class="Symbol">:</a> <a id="14879" href="../Lists/#14847" class="Bound">A</a> <a id="14881" class="Symbol">→</a> <a id="14883" href="../Lists/#14841" class="Datatype">Tree</a> <a id="14888" href="../Lists/#14847" class="Bound">A</a> <a id="14890" href="../Lists/#14849" class="Bound">B</a>
  <a id="Tree.node"></a><a id="14894" href="../Lists/#14894" class="InductiveConstructor">node</a> <a id="14899" class="Symbol">:</a> <a id="14901" href="../Lists/#14841" class="Datatype">Tree</a> <a id="14906" href="../Lists/#14847" class="Bound">A</a> <a id="14908" href="../Lists/#14849" class="Bound">B</a> <a id="14910" class="Symbol">→</a> <a id="14912" href="../Lists/#14849" class="Bound">B</a> <a id="14914" class="Symbol">→</a> <a id="14916" href="../Lists/#14841" class="Datatype">Tree</a> <a id="14921" href="../Lists/#14847" class="Bound">A</a> <a id="14923" href="../Lists/#14849" class="Bound">B</a> <a id="14925" class="Symbol">→</a> <a id="14927" href="../Lists/#14841" class="Datatype">Tree</a> <a id="14932" href="../Lists/#14847" class="Bound">A</a> <a id="14934" href="../Lists/#14849" class="Bound">B</a>
</pre>
<p>Define a suitable map operator over trees:</p>
<pre><code>map-Tree : ∀ {A B C D : Set} → (A → C) → (B → D) → Tree A B → Tree C D</code></pre>
<pre class="Agda"><a id="15064" class="Comment">-- Your code goes here</a>
</pre>
<h2 id="Fold">Fold</h2>
Fold takes an operator and a value, and uses the operator to combine each of the elements of the list, taking the given value as the result for the empty list:
<pre class="Agda"><a id="foldr"></a><a id="15273" href="../Lists/#15273" class="Function">foldr</a> <a id="15279" class="Symbol">:</a> <a id="15281" class="Symbol">∀</a> <a id="15283" class="Symbol">{</a><a id="15284" href="../Lists/#15284" class="Bound">A</a> <a id="15286" href="../Lists/#15286" class="Bound">B</a> <a id="15288" class="Symbol">:</a> <a id="15290" class="PrimitiveType">Set</a><a id="15293" class="Symbol">}</a> <a id="15295" class="Symbol">→</a> <a id="15297" class="Symbol">(</a><a id="15298" href="../Lists/#15284" class="Bound">A</a> <a id="15300" class="Symbol">→</a> <a id="15302" href="../Lists/#15286" class="Bound">B</a> <a id="15304" class="Symbol">→</a> <a id="15306" href="../Lists/#15286" class="Bound">B</a><a id="15307" class="Symbol">)</a> <a id="15309" class="Symbol">→</a> <a id="15311" href="../Lists/#15286" class="Bound">B</a> <a id="15313" class="Symbol">→</a> <a id="15315" href="../Lists/#1067" class="Datatype">List</a> <a id="15320" href="../Lists/#15284" class="Bound">A</a> <a id="15322" class="Symbol">→</a> <a id="15324" href="../Lists/#15286" class="Bound">B</a>
<a id="15326" href="../Lists/#15273" class="Function">foldr</a> <a id="15332" href="../Lists/#15332" class="Bound Operator">_⊗_</a> <a id="15336" href="../Lists/#15336" class="Bound">e</a> <a id="15338" href="../Lists/#1096" class="InductiveConstructor">[]</a>        <a id="15348" class="Symbol">=</a>  <a id="15351" href="../Lists/#15336" class="Bound">e</a>
<a id="15353" href="../Lists/#15273" class="Function">foldr</a> <a id="15359" href="../Lists/#15359" class="Bound Operator">_⊗_</a> <a id="15363" href="../Lists/#15363" class="Bound">e</a> <a id="15365" class="Symbol">(</a><a id="15366" href="../Lists/#15366" class="Bound">x</a> <a id="15368" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="15370" href="../Lists/#15370" class="Bound">xs</a><a id="15372" class="Symbol">)</a>  <a id="15375" class="Symbol">=</a>  <a id="15378" href="../Lists/#15366" class="Bound">x</a> <a id="15380" href="../Lists/#15359" class="Bound Operator">⊗</a> <a id="15382" href="../Lists/#15273" class="Function">foldr</a> <a id="15388" href="../Lists/#15359" class="Bound Operator">_⊗_</a> <a id="15392" href="../Lists/#15363" class="Bound">e</a> <a id="15394" href="../Lists/#15370" class="Bound">xs</a>
</pre>
<p>Fold of the empty list is the given value. Fold of a non-empty list uses the operator to combine the head of the list and the fold of the tail of the list.</p>
Here is an example showing how to use fold to find the sum of a list:
<pre class="Agda"><a id="15632" href="../Lists/#15632" class="Function">_</a> <a id="15634" class="Symbol">:</a> <a id="15636" href="../Lists/#15273" class="Function">foldr</a> <a id="15642" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="15646" class="Number">0</a> <a id="15648" href="../Lists/#2920" class="InductiveConstructor Operator">[</a> <a id="15650" class="Number">1</a> <a id="15652" href="../Lists/#2920" class="InductiveConstructor Operator">,</a> <a id="15654" class="Number">2</a> <a id="15656" href="../Lists/#2920" class="InductiveConstructor Operator">,</a> <a id="15658" class="Number">3</a> <a id="15660" href="../Lists/#2920" class="InductiveConstructor Operator">,</a> <a id="15662" class="Number">4</a> <a id="15664" href="../Lists/#2920" class="InductiveConstructor Operator">]</a> <a id="15666" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="15668" class="Number">10</a>
<a id="15671" class="Symbol">_</a> <a id="15673" class="Symbol">=</a>
  <a id="15677" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="15687" href="../Lists/#15273" class="Function">foldr</a> <a id="15693" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="15697" class="Number">0</a> <a id="15699" class="Symbol">(</a><a id="15700" class="Number">1</a> <a id="15702" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="15704" class="Number">2</a> <a id="15706" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="15708" class="Number">3</a> <a id="15710" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="15712" class="Number">4</a> <a id="15714" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="15716" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="15718" class="Symbol">)</a>
  <a id="15722" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="15730" class="Number">1</a> <a id="15732" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="15734" href="../Lists/#15273" class="Function">foldr</a> <a id="15740" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="15744" class="Number">0</a> <a id="15746" class="Symbol">(</a><a id="15747" class="Number">2</a> <a id="15749" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="15751" class="Number">3</a> <a id="15753" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="15755" class="Number">4</a> <a id="15757" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="15759" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="15761" class="Symbol">)</a>
  <a id="15765" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="15773" class="Number">1</a> <a id="15775" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="15777" class="Symbol">(</a><a id="15778" class="Number">2</a> <a id="15780" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="15782" href="../Lists/#15273" class="Function">foldr</a> <a id="15788" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="15792" class="Number">0</a> <a id="15794" class="Symbol">(</a><a id="15795" class="Number">3</a> <a id="15797" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="15799" class="Number">4</a> <a id="15801" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="15803" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="15805" class="Symbol">))</a>
  <a id="15810" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="15818" class="Number">1</a> <a id="15820" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="15822" class="Symbol">(</a><a id="15823" class="Number">2</a> <a id="15825" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="15827" class="Symbol">(</a><a id="15828" class="Number">3</a> <a id="15830" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="15832" href="../Lists/#15273" class="Function">foldr</a> <a id="15838" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="15842" class="Number">0</a> <a id="15844" class="Symbol">(</a><a id="15845" class="Number">4</a> <a id="15847" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="15849" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="15851" class="Symbol">)))</a>
  <a id="15857" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="15865" class="Number">1</a> <a id="15867" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="15869" class="Symbol">(</a><a id="15870" class="Number">2</a> <a id="15872" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="15874" class="Symbol">(</a><a id="15875" class="Number">3</a> <a id="15877" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="15879" class="Symbol">(</a><a id="15880" class="Number">4</a> <a id="15882" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="15884" href="../Lists/#15273" class="Function">foldr</a> <a id="15890" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="15894" class="Number">0</a> <a id="15896" href="../Lists/#1096" class="InductiveConstructor">[]</a><a id="15898" class="Symbol">)))</a>
  <a id="15904" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="15912" class="Number">1</a> <a id="15914" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="15916" class="Symbol">(</a><a id="15917" class="Number">2</a> <a id="15919" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="15921" class="Symbol">(</a><a id="15922" class="Number">3</a> <a id="15924" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="15926" class="Symbol">(</a><a id="15927" class="Number">4</a> <a id="15929" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="15931" class="Number">0</a><a id="15932" class="Symbol">)))</a>
  <a id="15938" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<p>Here we have an instance of <code>foldr</code> where <code>A</code> and <code>B</code> are both <code>ℕ</code>. Fold requires time linear in the length of the list.</p>
It is often convenient to exploit currying by applying fold to an operator and a value to yield a new function, and at a later point applying the resulting function:
<pre class="Agda"><a id="sum"></a><a id="16236" href="../Lists/#16236" class="Function">sum</a> <a id="16240" class="Symbol">:</a> <a id="16242" href="../Lists/#1067" class="Datatype">List</a> <a id="16247" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="16249" class="Symbol">→</a> <a id="16251" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="16253" href="../Lists/#16236" class="Function">sum</a> <a id="16257" class="Symbol">=</a> <a id="16259" href="../Lists/#15273" class="Function">foldr</a> <a id="16265" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="16269" class="Number">0</a>

<a id="16272" href="../Lists/#16272" class="Function">_</a> <a id="16274" class="Symbol">:</a> <a id="16276" href="../Lists/#16236" class="Function">sum</a> <a id="16280" href="../Lists/#2920" class="InductiveConstructor Operator">[</a> <a id="16282" class="Number">1</a> <a id="16284" href="../Lists/#2920" class="InductiveConstructor Operator">,</a> <a id="16286" class="Number">2</a> <a id="16288" href="../Lists/#2920" class="InductiveConstructor Operator">,</a> <a id="16290" class="Number">3</a> <a id="16292" href="../Lists/#2920" class="InductiveConstructor Operator">,</a> <a id="16294" class="Number">4</a> <a id="16296" href="../Lists/#2920" class="InductiveConstructor Operator">]</a> <a id="16298" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="16300" class="Number">10</a>
<a id="16303" class="Symbol">_</a> <a id="16305" class="Symbol">=</a>
  <a id="16309" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="16319" href="../Lists/#16236" class="Function">sum</a> <a id="16323" href="../Lists/#2920" class="InductiveConstructor Operator">[</a> <a id="16325" class="Number">1</a> <a id="16327" href="../Lists/#2920" class="InductiveConstructor Operator">,</a> <a id="16329" class="Number">2</a> <a id="16331" href="../Lists/#2920" class="InductiveConstructor Operator">,</a> <a id="16333" class="Number">3</a> <a id="16335" href="../Lists/#2920" class="InductiveConstructor Operator">,</a> <a id="16337" class="Number">4</a> <a id="16339" href="../Lists/#2920" class="InductiveConstructor Operator">]</a>
  <a id="16343" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="16351" href="../Lists/#15273" class="Function">foldr</a> <a id="16357" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="16361" class="Number">0</a> <a id="16363" href="../Lists/#2920" class="InductiveConstructor Operator">[</a> <a id="16365" class="Number">1</a> <a id="16367" href="../Lists/#2920" class="InductiveConstructor Operator">,</a> <a id="16369" class="Number">2</a> <a id="16371" href="../Lists/#2920" class="InductiveConstructor Operator">,</a> <a id="16373" class="Number">3</a> <a id="16375" href="../Lists/#2920" class="InductiveConstructor Operator">,</a> <a id="16377" class="Number">4</a> <a id="16379" href="../Lists/#2920" class="InductiveConstructor Operator">]</a>
  <a id="16383" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="16391" class="Number">10</a>
  <a id="16396" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<p>Just as the list type has two constructors, <code>[]</code> and <code>_∷_</code>, so the fold function takes two arguments, <code>e</code> and <code>_⊗_</code> (in addition to the list argument). In general, a data type with <em>n</em> constructors will have a corresponding fold function that takes <em>n</em> arguments.</p>
<p>As another example, observe that</p>
<pre><code>foldr _∷_ [] xs ≡ xs</code></pre>
<p>Here, if <code>xs</code> is of type <code>List A</code>, then we see we have an instance of <code>foldr</code> where <code>A</code> is <code>A</code> and <code>B</code> is <code>List A</code>. It follows that</p>
<pre><code>xs ++ ys ≡ foldr _∷_ ys xs</code></pre>
<p>Demonstrating both these equations is left as an exercise.</p>
<h4 id="exercise-product-recommended">Exercise <code>product</code> (recommended)</h4>
<p>Use fold to define a function to find the product of a list of numbers. For example:</p>
<pre><code>product [ 1 , 2 , 3 , 4 ] ≡ 24</code></pre>
<pre class="Agda"><a id="17120" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise-foldr--recommended">Exercise <code>foldr-++</code> (recommended)</h4>
<p>Show that fold and append are related as follows:</p>
<pre><code>foldr _⊗_ e (xs ++ ys) ≡ foldr _⊗_ (foldr _⊗_ e ys) xs</code></pre>
<pre class="Agda"><a id="17303" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise-foldr--practice">Exercise <code>foldr-∷</code> (practice)</h4>
<p>Show</p>
<pre><code>foldr _∷_ [] xs ≡ xs</code></pre>
<p>Show as a consequence of <code>foldr-++</code> above that</p>
<pre><code>xs ++ ys ≡ foldr _∷_ ys xs</code></pre>
<pre class="Agda"><a id="17484" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise-map-is-foldr-practice">Exercise <code>map-is-foldr</code> (practice)</h4>
<p>Show that map can be defined using fold:</p>
<pre><code>map f ≡ foldr (λ x xs → f x ∷ xs) []</code></pre>
<p>The proof requires extensionality.</p>
<pre class="Agda"><a id="17677" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise-fold-tree-practice">Exercise <code>fold-Tree</code> (practice)</h4>
<p>Define a suitable fold function for the type of trees given earlier:</p>
<pre><code>fold-Tree : ∀ {A B C : Set} → (A → C) → (C → B → C → C) → Tree A B → C</code></pre>
<pre class="Agda"><a id="17894" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise-map-is-fold-tree-practice">Exercise <code>map-is-fold-Tree</code> (practice)</h4>
<p>Demonstrate an analogue of <code>map-is-foldr</code> for the type of trees.</p>
<pre class="Agda"><a id="18037" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise-sum-downfrom-stretch">Exercise <code>sum-downFrom</code> (stretch)</h4>
Define a function that counts down as follows:
<pre class="Agda"><a id="downFrom"></a><a id="18156" href="../Lists/#18156" class="Function">downFrom</a> <a id="18165" class="Symbol">:</a> <a id="18167" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="18169" class="Symbol">→</a> <a id="18171" href="../Lists/#1067" class="Datatype">List</a> <a id="18176" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="18178" href="../Lists/#18156" class="Function">downFrom</a> <a id="18187" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>     <a id="18196" class="Symbol">=</a>  <a id="18199" href="../Lists/#1096" class="InductiveConstructor">[]</a>
<a id="18202" href="../Lists/#18156" class="Function">downFrom</a> <a id="18211" class="Symbol">(</a><a id="18212" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="18216" href="../Lists/#18216" class="Bound">n</a><a id="18217" class="Symbol">)</a>  <a id="18220" class="Symbol">=</a>  <a id="18223" href="../Lists/#18216" class="Bound">n</a> <a id="18225" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="18227" href="../Lists/#18156" class="Function">downFrom</a> <a id="18236" href="../Lists/#18216" class="Bound">n</a>
</pre>
For example:
<pre class="Agda"><a id="18259" href="../Lists/#18259" class="Function">_</a> <a id="18261" class="Symbol">:</a> <a id="18263" href="../Lists/#18156" class="Function">downFrom</a> <a id="18272" class="Number">3</a> <a id="18274" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="18276" href="../Lists/#2881" class="InductiveConstructor Operator">[</a> <a id="18278" class="Number">2</a> <a id="18280" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="18282" class="Number">1</a> <a id="18284" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="18286" class="Number">0</a> <a id="18288" href="../Lists/#2881" class="InductiveConstructor Operator">]</a>
<a id="18290" class="Symbol">_</a> <a id="18292" class="Symbol">=</a> <a id="18294" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>Prove that the sum of the numbers <code>(n - 1) + ⋯ + 0</code> is equal to <code>n * (n ∸ 1) / 2</code>:</p>
<pre><code>sum (downFrom n) * 2 ≡ n * (n ∸ 1)</code></pre>
<h2 id="monoids">Monoids</h2>
<p>Typically when we use a fold the operator is associative and the value is a left and right identity for the operator, meaning that the operator and the value form a <em>monoid</em>.</p>
We can define a monoid as a suitable record type:
<pre class="Agda"><a id="18670" class="Keyword">record</a> <a id="IsMonoid"></a><a id="18677" href="../Lists/#18677" class="Record">IsMonoid</a> <a id="18686" class="Symbol">{</a><a id="18687" href="../Lists/#18687" class="Bound">A</a> <a id="18689" class="Symbol">:</a> <a id="18691" class="PrimitiveType">Set</a><a id="18694" class="Symbol">}</a> <a id="18696" class="Symbol">(</a><a id="18697" href="../Lists/#18697" class="Bound Operator">_⊗_</a> <a id="18701" class="Symbol">:</a> <a id="18703" href="../Lists/#18687" class="Bound">A</a> <a id="18705" class="Symbol">→</a> <a id="18707" href="../Lists/#18687" class="Bound">A</a> <a id="18709" class="Symbol">→</a> <a id="18711" href="../Lists/#18687" class="Bound">A</a><a id="18712" class="Symbol">)</a> <a id="18714" class="Symbol">(</a><a id="18715" href="../Lists/#18715" class="Bound">e</a> <a id="18717" class="Symbol">:</a> <a id="18719" href="../Lists/#18687" class="Bound">A</a><a id="18720" class="Symbol">)</a> <a id="18722" class="Symbol">:</a> <a id="18724" class="PrimitiveType">Set</a> <a id="18728" class="Keyword">where</a>
  <a id="18736" class="Keyword">field</a>
    <a id="IsMonoid.assoc"></a><a id="18746" href="../Lists/#18746" class="Field">assoc</a> <a id="18752" class="Symbol">:</a> <a id="18754" class="Symbol">∀</a> <a id="18756" class="Symbol">(</a><a id="18757" href="../Lists/#18757" class="Bound">x</a> <a id="18759" href="../Lists/#18759" class="Bound">y</a> <a id="18761" href="../Lists/#18761" class="Bound">z</a> <a id="18763" class="Symbol">:</a> <a id="18765" href="../Lists/#18687" class="Bound">A</a><a id="18766" class="Symbol">)</a> <a id="18768" class="Symbol">→</a> <a id="18770" class="Symbol">(</a><a id="18771" href="../Lists/#18757" class="Bound">x</a> <a id="18773" href="../Lists/#18697" class="Bound Operator">⊗</a> <a id="18775" href="../Lists/#18759" class="Bound">y</a><a id="18776" class="Symbol">)</a> <a id="18778" href="../Lists/#18697" class="Bound Operator">⊗</a> <a id="18780" href="../Lists/#18761" class="Bound">z</a> <a id="18782" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="18784" href="../Lists/#18757" class="Bound">x</a> <a id="18786" href="../Lists/#18697" class="Bound Operator">⊗</a> <a id="18788" class="Symbol">(</a><a id="18789" href="../Lists/#18759" class="Bound">y</a> <a id="18791" href="../Lists/#18697" class="Bound Operator">⊗</a> <a id="18793" href="../Lists/#18761" class="Bound">z</a><a id="18794" class="Symbol">)</a>
    <a id="IsMonoid.identityˡ"></a><a id="18800" href="../Lists/#18800" class="Field">identityˡ</a> <a id="18810" class="Symbol">:</a> <a id="18812" class="Symbol">∀</a> <a id="18814" class="Symbol">(</a><a id="18815" href="../Lists/#18815" class="Bound">x</a> <a id="18817" class="Symbol">:</a> <a id="18819" href="../Lists/#18687" class="Bound">A</a><a id="18820" class="Symbol">)</a> <a id="18822" class="Symbol">→</a> <a id="18824" href="../Lists/#18715" class="Bound">e</a> <a id="18826" href="../Lists/#18697" class="Bound Operator">⊗</a> <a id="18828" href="../Lists/#18815" class="Bound">x</a> <a id="18830" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="18832" href="../Lists/#18815" class="Bound">x</a>
    <a id="IsMonoid.identityʳ"></a><a id="18838" href="../Lists/#18838" class="Field">identityʳ</a> <a id="18848" class="Symbol">:</a> <a id="18850" class="Symbol">∀</a> <a id="18852" class="Symbol">(</a><a id="18853" href="../Lists/#18853" class="Bound">x</a> <a id="18855" class="Symbol">:</a> <a id="18857" href="../Lists/#18687" class="Bound">A</a><a id="18858" class="Symbol">)</a> <a id="18860" class="Symbol">→</a> <a id="18862" href="../Lists/#18853" class="Bound">x</a> <a id="18864" href="../Lists/#18697" class="Bound Operator">⊗</a> <a id="18866" href="../Lists/#18715" class="Bound">e</a> <a id="18868" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="18870" href="../Lists/#18853" class="Bound">x</a>

<a id="18873" class="Keyword">open</a> <a id="18878" href="../Lists/#18677" class="Module">IsMonoid</a>
</pre>
As examples, sum and zero, multiplication and one, and append and the empty list, are all examples of monoids:
<pre class="Agda"><a id="+-monoid"></a><a id="19007" href="../Lists/#19007" class="Function">+-monoid</a> <a id="19016" class="Symbol">:</a> <a id="19018" href="../Lists/#18677" class="Record">IsMonoid</a> <a id="19027" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="19031" class="Number">0</a>
<a id="19033" href="../Lists/#19007" class="Function">+-monoid</a> <a id="19042" class="Symbol">=</a>
  <a id="19046" class="Keyword">record</a>
    <a id="19057" class="Symbol">{</a> <a id="19059" href="../Lists/#18746" class="Field">assoc</a> <a id="19065" class="Symbol">=</a> <a id="19067" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html#12490" class="Function">+-assoc</a>
    <a id="19079" class="Symbol">;</a> <a id="19081" href="../Lists/#18800" class="Field">identityˡ</a> <a id="19091" class="Symbol">=</a> <a id="19093" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html#12591" class="Function">+-identityˡ</a>
    <a id="19109" class="Symbol">;</a> <a id="19111" href="../Lists/#18838" class="Field">identityʳ</a> <a id="19121" class="Symbol">=</a> <a id="19123" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html#12646" class="Function">+-identityʳ</a>
    <a id="19139" class="Symbol">}</a>

<a id="*-monoid"></a><a id="19142" href="../Lists/#19142" class="Function">*-monoid</a> <a id="19151" class="Symbol">:</a> <a id="19153" href="../Lists/#18677" class="Record">IsMonoid</a> <a id="19162" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#528" class="Primitive Operator">_*_</a> <a id="19166" class="Number">1</a>
<a id="19168" href="../Lists/#19142" class="Function">*-monoid</a> <a id="19177" class="Symbol">=</a>
  <a id="19181" class="Keyword">record</a>
    <a id="19192" class="Symbol">{</a> <a id="19194" href="../Lists/#18746" class="Field">assoc</a> <a id="19200" class="Symbol">=</a> <a id="19202" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html#20430" class="Function">*-assoc</a>
    <a id="19214" class="Symbol">;</a> <a id="19216" href="../Lists/#18800" class="Field">identityˡ</a> <a id="19226" class="Symbol">=</a> <a id="19228" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html#19330" class="Function">*-identityˡ</a>
    <a id="19244" class="Symbol">;</a> <a id="19246" href="../Lists/#18838" class="Field">identityʳ</a> <a id="19256" class="Symbol">=</a> <a id="19258" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html#19394" class="Function">*-identityʳ</a>
    <a id="19274" class="Symbol">}</a>

<a id="++-monoid"></a><a id="19277" href="../Lists/#19277" class="Function">++-monoid</a> <a id="19287" class="Symbol">:</a> <a id="19289" class="Symbol">∀</a> <a id="19291" class="Symbol">{</a><a id="19292" href="../Lists/#19292" class="Bound">A</a> <a id="19294" class="Symbol">:</a> <a id="19296" class="PrimitiveType">Set</a><a id="19299" class="Symbol">}</a> <a id="19301" class="Symbol">→</a> <a id="19303" href="../Lists/#18677" class="Record">IsMonoid</a> <a id="19312" class="Symbol">{</a><a id="19313" href="../Lists/#1067" class="Datatype">List</a> <a id="19318" href="../Lists/#19292" class="Bound">A</a><a id="19319" class="Symbol">}</a> <a id="19321" href="../Lists/#3467" class="Function Operator">_++_</a> <a id="19326" href="../Lists/#1096" class="InductiveConstructor">[]</a>
<a id="19329" href="../Lists/#19277" class="Function">++-monoid</a> <a id="19339" class="Symbol">=</a>
  <a id="19343" class="Keyword">record</a>
    <a id="19354" class="Symbol">{</a> <a id="19356" href="../Lists/#18746" class="Field">assoc</a> <a id="19362" class="Symbol">=</a> <a id="19364" href="../Lists/#4528" class="Function">++-assoc</a>
    <a id="19377" class="Symbol">;</a> <a id="19379" href="../Lists/#18800" class="Field">identityˡ</a> <a id="19389" class="Symbol">=</a> <a id="19391" href="../Lists/#5721" class="Function">++-identityˡ</a>
    <a id="19408" class="Symbol">;</a> <a id="19410" href="../Lists/#18838" class="Field">identityʳ</a> <a id="19420" class="Symbol">=</a> <a id="19422" href="../Lists/#5899" class="Function">++-identityʳ</a>
    <a id="19439" class="Symbol">}</a>
</pre>
If <code>_⊗_</code> and <code>e</code> form a monoid, then we can re-express fold on the same operator and an arbitrary value:
<pre class="Agda"><a id="foldr-monoid"></a><a id="19555" href="../Lists/#19555" class="Function">foldr-monoid</a> <a id="19568" class="Symbol">:</a> <a id="19570" class="Symbol">∀</a> <a id="19572" class="Symbol">{</a><a id="19573" href="../Lists/#19573" class="Bound">A</a> <a id="19575" class="Symbol">:</a> <a id="19577" class="PrimitiveType">Set</a><a id="19580" class="Symbol">}</a> <a id="19582" class="Symbol">(</a><a id="19583" href="../Lists/#19583" class="Bound Operator">_⊗_</a> <a id="19587" class="Symbol">:</a> <a id="19589" href="../Lists/#19573" class="Bound">A</a> <a id="19591" class="Symbol">→</a> <a id="19593" href="../Lists/#19573" class="Bound">A</a> <a id="19595" class="Symbol">→</a> <a id="19597" href="../Lists/#19573" class="Bound">A</a><a id="19598" class="Symbol">)</a> <a id="19600" class="Symbol">(</a><a id="19601" href="../Lists/#19601" class="Bound">e</a> <a id="19603" class="Symbol">:</a> <a id="19605" href="../Lists/#19573" class="Bound">A</a><a id="19606" class="Symbol">)</a> <a id="19608" class="Symbol">→</a> <a id="19610" href="../Lists/#18677" class="Record">IsMonoid</a> <a id="19619" href="../Lists/#19583" class="Bound Operator">_⊗_</a> <a id="19623" href="../Lists/#19601" class="Bound">e</a> <a id="19625" class="Symbol">→</a>
  <a id="19629" class="Symbol">∀</a> <a id="19631" class="Symbol">(</a><a id="19632" href="../Lists/#19632" class="Bound">xs</a> <a id="19635" class="Symbol">:</a> <a id="19637" href="../Lists/#1067" class="Datatype">List</a> <a id="19642" href="../Lists/#19573" class="Bound">A</a><a id="19643" class="Symbol">)</a> <a id="19645" class="Symbol">(</a><a id="19646" href="../Lists/#19646" class="Bound">y</a> <a id="19648" class="Symbol">:</a> <a id="19650" href="../Lists/#19573" class="Bound">A</a><a id="19651" class="Symbol">)</a> <a id="19653" class="Symbol">→</a> <a id="19655" href="../Lists/#15273" class="Function">foldr</a> <a id="19661" href="../Lists/#19583" class="Bound Operator">_⊗_</a> <a id="19665" href="../Lists/#19646" class="Bound">y</a> <a id="19667" href="../Lists/#19632" class="Bound">xs</a> <a id="19670" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="19672" href="../Lists/#15273" class="Function">foldr</a> <a id="19678" href="../Lists/#19583" class="Bound Operator">_⊗_</a> <a id="19682" href="../Lists/#19601" class="Bound">e</a> <a id="19684" href="../Lists/#19632" class="Bound">xs</a> <a id="19687" href="../Lists/#19583" class="Bound Operator">⊗</a> <a id="19689" href="../Lists/#19646" class="Bound">y</a>
<a id="19691" href="../Lists/#19555" class="Function">foldr-monoid</a> <a id="19704" href="../Lists/#19704" class="Bound Operator">_⊗_</a> <a id="19708" href="../Lists/#19708" class="Bound">e</a> <a id="19710" href="../Lists/#19710" class="Bound">⊗-monoid</a> <a id="19719" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="19722" href="../Lists/#19722" class="Bound">y</a> <a id="19724" class="Symbol">=</a>
  <a id="19728" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="19738" href="../Lists/#15273" class="Function">foldr</a> <a id="19744" href="../Lists/#19704" class="Bound Operator">_⊗_</a> <a id="19748" href="../Lists/#19722" class="Bound">y</a> <a id="19750" href="../Lists/#1096" class="InductiveConstructor">[]</a>
  <a id="19755" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="19763" href="../Lists/#19722" class="Bound">y</a>
  <a id="19767" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="19770" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#980" class="Function">sym</a> <a id="19774" class="Symbol">(</a><a id="19775" href="../Lists/#18800" class="Field">identityˡ</a> <a id="19785" href="../Lists/#19710" class="Bound">⊗-monoid</a> <a id="19794" href="../Lists/#19722" class="Bound">y</a><a id="19795" class="Symbol">)</a> <a id="19797" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
    <a id="19803" class="Symbol">(</a><a id="19804" href="../Lists/#19708" class="Bound">e</a> <a id="19806" href="../Lists/#19704" class="Bound Operator">⊗</a> <a id="19808" href="../Lists/#19722" class="Bound">y</a><a id="19809" class="Symbol">)</a>
  <a id="19813" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="19821" href="../Lists/#15273" class="Function">foldr</a> <a id="19827" href="../Lists/#19704" class="Bound Operator">_⊗_</a> <a id="19831" href="../Lists/#19708" class="Bound">e</a> <a id="19833" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="19836" href="../Lists/#19704" class="Bound Operator">⊗</a> <a id="19838" href="../Lists/#19722" class="Bound">y</a>
  <a id="19842" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
<a id="19844" href="../Lists/#19555" class="Function">foldr-monoid</a> <a id="19857" href="../Lists/#19857" class="Bound Operator">_⊗_</a> <a id="19861" href="../Lists/#19861" class="Bound">e</a> <a id="19863" href="../Lists/#19863" class="Bound">⊗-monoid</a> <a id="19872" class="Symbol">(</a><a id="19873" href="../Lists/#19873" class="Bound">x</a> <a id="19875" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="19877" href="../Lists/#19877" class="Bound">xs</a><a id="19879" class="Symbol">)</a> <a id="19881" href="../Lists/#19881" class="Bound">y</a> <a id="19883" class="Symbol">=</a>
  <a id="19887" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="19897" href="../Lists/#15273" class="Function">foldr</a> <a id="19903" href="../Lists/#19857" class="Bound Operator">_⊗_</a> <a id="19907" href="../Lists/#19881" class="Bound">y</a> <a id="19909" class="Symbol">(</a><a id="19910" href="../Lists/#19873" class="Bound">x</a> <a id="19912" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="19914" href="../Lists/#19877" class="Bound">xs</a><a id="19916" class="Symbol">)</a>
  <a id="19920" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="19928" href="../Lists/#19873" class="Bound">x</a> <a id="19930" href="../Lists/#19857" class="Bound Operator">⊗</a> <a id="19932" class="Symbol">(</a><a id="19933" href="../Lists/#15273" class="Function">foldr</a> <a id="19939" href="../Lists/#19857" class="Bound Operator">_⊗_</a> <a id="19943" href="../Lists/#19881" class="Bound">y</a> <a id="19945" href="../Lists/#19877" class="Bound">xs</a><a id="19947" class="Symbol">)</a>
  <a id="19951" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="19954" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#1131" class="Function">cong</a> <a id="19959" class="Symbol">(</a><a id="19960" href="../Lists/#19873" class="Bound">x</a> <a id="19962" href="../Lists/#19857" class="Bound Operator">⊗_</a><a id="19964" class="Symbol">)</a> <a id="19966" class="Symbol">(</a><a id="19967" href="../Lists/#19555" class="Function">foldr-monoid</a> <a id="19980" href="../Lists/#19857" class="Bound Operator">_⊗_</a> <a id="19984" href="../Lists/#19861" class="Bound">e</a> <a id="19986" href="../Lists/#19863" class="Bound">⊗-monoid</a> <a id="19995" href="../Lists/#19877" class="Bound">xs</a> <a id="19998" href="../Lists/#19881" class="Bound">y</a><a id="19999" class="Symbol">)</a> <a id="20001" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
    <a id="20007" href="../Lists/#19873" class="Bound">x</a> <a id="20009" href="../Lists/#19857" class="Bound Operator">⊗</a> <a id="20011" class="Symbol">(</a><a id="20012" href="../Lists/#15273" class="Function">foldr</a> <a id="20018" href="../Lists/#19857" class="Bound Operator">_⊗_</a> <a id="20022" href="../Lists/#19861" class="Bound">e</a> <a id="20024" href="../Lists/#19877" class="Bound">xs</a> <a id="20027" href="../Lists/#19857" class="Bound Operator">⊗</a> <a id="20029" href="../Lists/#19881" class="Bound">y</a><a id="20030" class="Symbol">)</a>
  <a id="20034" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="20037" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#980" class="Function">sym</a> <a id="20041" class="Symbol">(</a><a id="20042" href="../Lists/#18746" class="Field">assoc</a> <a id="20048" href="../Lists/#19863" class="Bound">⊗-monoid</a> <a id="20057" href="../Lists/#19873" class="Bound">x</a> <a id="20059" class="Symbol">(</a><a id="20060" href="../Lists/#15273" class="Function">foldr</a> <a id="20066" href="../Lists/#19857" class="Bound Operator">_⊗_</a> <a id="20070" href="../Lists/#19861" class="Bound">e</a> <a id="20072" href="../Lists/#19877" class="Bound">xs</a><a id="20074" class="Symbol">)</a> <a id="20076" href="../Lists/#19881" class="Bound">y</a><a id="20077" class="Symbol">)</a> <a id="20079" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
    <a id="20085" class="Symbol">(</a><a id="20086" href="../Lists/#19873" class="Bound">x</a> <a id="20088" href="../Lists/#19857" class="Bound Operator">⊗</a> <a id="20090" href="../Lists/#15273" class="Function">foldr</a> <a id="20096" href="../Lists/#19857" class="Bound Operator">_⊗_</a> <a id="20100" href="../Lists/#19861" class="Bound">e</a> <a id="20102" href="../Lists/#19877" class="Bound">xs</a><a id="20104" class="Symbol">)</a> <a id="20106" href="../Lists/#19857" class="Bound Operator">⊗</a> <a id="20108" href="../Lists/#19881" class="Bound">y</a>
  <a id="20112" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="20120" href="../Lists/#15273" class="Function">foldr</a> <a id="20126" href="../Lists/#19857" class="Bound Operator">_⊗_</a> <a id="20130" href="../Lists/#19861" class="Bound">e</a> <a id="20132" class="Symbol">(</a><a id="20133" href="../Lists/#19873" class="Bound">x</a> <a id="20135" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="20137" href="../Lists/#19877" class="Bound">xs</a><a id="20139" class="Symbol">)</a> <a id="20141" href="../Lists/#19857" class="Bound Operator">⊗</a> <a id="20143" href="../Lists/#19881" class="Bound">y</a>
  <a id="20147" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
In a previous exercise we showed the following.
<pre class="Agda"><a id="20206" class="Keyword">postulate</a>
  <a id="foldr-++"></a><a id="20218" href="../Lists/#20218" class="Postulate">foldr-++</a> <a id="20227" class="Symbol">:</a> <a id="20229" class="Symbol">∀</a> <a id="20231" class="Symbol">{</a><a id="20232" href="../Lists/#20232" class="Bound">A</a> <a id="20234" class="Symbol">:</a> <a id="20236" class="PrimitiveType">Set</a><a id="20239" class="Symbol">}</a> <a id="20241" class="Symbol">(</a><a id="20242" href="../Lists/#20242" class="Bound Operator">_⊗_</a> <a id="20246" class="Symbol">:</a> <a id="20248" href="../Lists/#20232" class="Bound">A</a> <a id="20250" class="Symbol">→</a> <a id="20252" href="../Lists/#20232" class="Bound">A</a> <a id="20254" class="Symbol">→</a> <a id="20256" href="../Lists/#20232" class="Bound">A</a><a id="20257" class="Symbol">)</a> <a id="20259" class="Symbol">(</a><a id="20260" href="../Lists/#20260" class="Bound">e</a> <a id="20262" class="Symbol">:</a> <a id="20264" href="../Lists/#20232" class="Bound">A</a><a id="20265" class="Symbol">)</a> <a id="20267" class="Symbol">(</a><a id="20268" href="../Lists/#20268" class="Bound">xs</a> <a id="20271" href="../Lists/#20271" class="Bound">ys</a> <a id="20274" class="Symbol">:</a> <a id="20276" href="../Lists/#1067" class="Datatype">List</a> <a id="20281" href="../Lists/#20232" class="Bound">A</a><a id="20282" class="Symbol">)</a> <a id="20284" class="Symbol">→</a>
    <a id="20290" href="../Lists/#15273" class="Function">foldr</a> <a id="20296" href="../Lists/#20242" class="Bound Operator">_⊗_</a> <a id="20300" href="../Lists/#20260" class="Bound">e</a> <a id="20302" class="Symbol">(</a><a id="20303" href="../Lists/#20268" class="Bound">xs</a> <a id="20306" href="../Lists/#3467" class="Function Operator">++</a> <a id="20309" href="../Lists/#20271" class="Bound">ys</a><a id="20311" class="Symbol">)</a> <a id="20313" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="20315" href="../Lists/#15273" class="Function">foldr</a> <a id="20321" href="../Lists/#20242" class="Bound Operator">_⊗_</a> <a id="20325" class="Symbol">(</a><a id="20326" href="../Lists/#15273" class="Function">foldr</a> <a id="20332" href="../Lists/#20242" class="Bound Operator">_⊗_</a> <a id="20336" href="../Lists/#20260" class="Bound">e</a> <a id="20338" href="../Lists/#20271" class="Bound">ys</a><a id="20340" class="Symbol">)</a> <a id="20342" href="../Lists/#20268" class="Bound">xs</a>
</pre>
As a consequence, using a previous exercise, we have the following:
<pre class="Agda"><a id="foldr-monoid-++"></a><a id="20422" href="../Lists/#20422" class="Function">foldr-monoid-++</a> <a id="20438" class="Symbol">:</a> <a id="20440" class="Symbol">∀</a> <a id="20442" class="Symbol">{</a><a id="20443" href="../Lists/#20443" class="Bound">A</a> <a id="20445" class="Symbol">:</a> <a id="20447" class="PrimitiveType">Set</a><a id="20450" class="Symbol">}</a> <a id="20452" class="Symbol">(</a><a id="20453" href="../Lists/#20453" class="Bound Operator">_⊗_</a> <a id="20457" class="Symbol">:</a> <a id="20459" href="../Lists/#20443" class="Bound">A</a> <a id="20461" class="Symbol">→</a> <a id="20463" href="../Lists/#20443" class="Bound">A</a> <a id="20465" class="Symbol">→</a> <a id="20467" href="../Lists/#20443" class="Bound">A</a><a id="20468" class="Symbol">)</a> <a id="20470" class="Symbol">(</a><a id="20471" href="../Lists/#20471" class="Bound">e</a> <a id="20473" class="Symbol">:</a> <a id="20475" href="../Lists/#20443" class="Bound">A</a><a id="20476" class="Symbol">)</a> <a id="20478" class="Symbol">→</a> <a id="20480" href="../Lists/#18677" class="Record">IsMonoid</a> <a id="20489" href="../Lists/#20453" class="Bound Operator">_⊗_</a> <a id="20493" href="../Lists/#20471" class="Bound">e</a> <a id="20495" class="Symbol">→</a>
  <a id="20499" class="Symbol">∀</a> <a id="20501" class="Symbol">(</a><a id="20502" href="../Lists/#20502" class="Bound">xs</a> <a id="20505" href="../Lists/#20505" class="Bound">ys</a> <a id="20508" class="Symbol">:</a> <a id="20510" href="../Lists/#1067" class="Datatype">List</a> <a id="20515" href="../Lists/#20443" class="Bound">A</a><a id="20516" class="Symbol">)</a> <a id="20518" class="Symbol">→</a> <a id="20520" href="../Lists/#15273" class="Function">foldr</a> <a id="20526" href="../Lists/#20453" class="Bound Operator">_⊗_</a> <a id="20530" href="../Lists/#20471" class="Bound">e</a> <a id="20532" class="Symbol">(</a><a id="20533" href="../Lists/#20502" class="Bound">xs</a> <a id="20536" href="../Lists/#3467" class="Function Operator">++</a> <a id="20539" href="../Lists/#20505" class="Bound">ys</a><a id="20541" class="Symbol">)</a> <a id="20543" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="20545" href="../Lists/#15273" class="Function">foldr</a> <a id="20551" href="../Lists/#20453" class="Bound Operator">_⊗_</a> <a id="20555" href="../Lists/#20471" class="Bound">e</a> <a id="20557" href="../Lists/#20502" class="Bound">xs</a> <a id="20560" href="../Lists/#20453" class="Bound Operator">⊗</a> <a id="20562" href="../Lists/#15273" class="Function">foldr</a> <a id="20568" href="../Lists/#20453" class="Bound Operator">_⊗_</a> <a id="20572" href="../Lists/#20471" class="Bound">e</a> <a id="20574" href="../Lists/#20505" class="Bound">ys</a>
<a id="20577" href="../Lists/#20422" class="Function">foldr-monoid-++</a> <a id="20593" href="../Lists/#20593" class="Bound Operator">_⊗_</a> <a id="20597" href="../Lists/#20597" class="Bound">e</a> <a id="20599" href="../Lists/#20599" class="Bound">monoid-⊗</a> <a id="20608" href="../Lists/#20608" class="Bound">xs</a> <a id="20611" href="../Lists/#20611" class="Bound">ys</a> <a id="20614" class="Symbol">=</a>
  <a id="20618" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="20628" href="../Lists/#15273" class="Function">foldr</a> <a id="20634" href="../Lists/#20593" class="Bound Operator">_⊗_</a> <a id="20638" href="../Lists/#20597" class="Bound">e</a> <a id="20640" class="Symbol">(</a><a id="20641" href="../Lists/#20608" class="Bound">xs</a> <a id="20644" href="../Lists/#3467" class="Function Operator">++</a> <a id="20647" href="../Lists/#20611" class="Bound">ys</a><a id="20649" class="Symbol">)</a>
  <a id="20653" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="20656" href="../Lists/#20218" class="Postulate">foldr-++</a> <a id="20665" href="../Lists/#20593" class="Bound Operator">_⊗_</a> <a id="20669" href="../Lists/#20597" class="Bound">e</a> <a id="20671" href="../Lists/#20608" class="Bound">xs</a> <a id="20674" href="../Lists/#20611" class="Bound">ys</a> <a id="20677" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
    <a id="20683" href="../Lists/#15273" class="Function">foldr</a> <a id="20689" href="../Lists/#20593" class="Bound Operator">_⊗_</a> <a id="20693" class="Symbol">(</a><a id="20694" href="../Lists/#15273" class="Function">foldr</a> <a id="20700" href="../Lists/#20593" class="Bound Operator">_⊗_</a> <a id="20704" href="../Lists/#20597" class="Bound">e</a> <a id="20706" href="../Lists/#20611" class="Bound">ys</a><a id="20708" class="Symbol">)</a> <a id="20710" href="../Lists/#20608" class="Bound">xs</a>
  <a id="20715" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="20718" href="../Lists/#19555" class="Function">foldr-monoid</a> <a id="20731" href="../Lists/#20593" class="Bound Operator">_⊗_</a> <a id="20735" href="../Lists/#20597" class="Bound">e</a> <a id="20737" href="../Lists/#20599" class="Bound">monoid-⊗</a> <a id="20746" href="../Lists/#20608" class="Bound">xs</a> <a id="20749" class="Symbol">(</a><a id="20750" href="../Lists/#15273" class="Function">foldr</a> <a id="20756" href="../Lists/#20593" class="Bound Operator">_⊗_</a> <a id="20760" href="../Lists/#20597" class="Bound">e</a> <a id="20762" href="../Lists/#20611" class="Bound">ys</a><a id="20764" class="Symbol">)</a> <a id="20766" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
    <a id="20772" href="../Lists/#15273" class="Function">foldr</a> <a id="20778" href="../Lists/#20593" class="Bound Operator">_⊗_</a> <a id="20782" href="../Lists/#20597" class="Bound">e</a> <a id="20784" href="../Lists/#20608" class="Bound">xs</a> <a id="20787" href="../Lists/#20593" class="Bound Operator">⊗</a> <a id="20789" href="../Lists/#15273" class="Function">foldr</a> <a id="20795" href="../Lists/#20593" class="Bound Operator">_⊗_</a> <a id="20799" href="../Lists/#20597" class="Bound">e</a> <a id="20801" href="../Lists/#20611" class="Bound">ys</a>
  <a id="20806" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<h4 id="exercise-foldl-practice">Exercise <code>foldl</code> (practice)</h4>
<p>Define a function <code>foldl</code> which is analogous to <code>foldr</code>, but where operations associate to the left rather than the right. For example:</p>
<pre><code>foldr _⊗_ e [ x , y , z ]  =  x ⊗ (y ⊗ (z ⊗ e))
foldl _⊗_ e [ x , y , z ]  =  ((e ⊗ x) ⊗ y) ⊗ z</code></pre>
<pre class="Agda"><a id="21094" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise-foldr-monoid-foldl-practice">Exercise <code>foldr-monoid-foldl</code> (practice)</h4>
<p>Show that if <code>_⊗_</code> and <code>e</code> form a monoid, then <code>foldr _⊗_ e</code> and <code>foldl _⊗_ e</code> always compute the same result.</p>
<pre class="Agda"><a id="21286" class="Comment">-- Your code goes here</a>
</pre>
<h2 id="All">All</h2>
<p>We can also define predicates over lists. Two of the most important are <code>All</code> and <code>Any</code>.</p>
Predicate <code>All P</code> holds if predicate <code>P</code> is satisfied by every element of a list:
<pre class="Agda"><a id="21506" class="Keyword">data</a> <a id="All"></a><a id="21511" href="../Lists/#21511" class="Datatype">All</a> <a id="21515" class="Symbol">{</a><a id="21516" href="../Lists/#21516" class="Bound">A</a> <a id="21518" class="Symbol">:</a> <a id="21520" class="PrimitiveType">Set</a><a id="21523" class="Symbol">}</a> <a id="21525" class="Symbol">(</a><a id="21526" href="../Lists/#21526" class="Bound">P</a> <a id="21528" class="Symbol">:</a> <a id="21530" href="../Lists/#21516" class="Bound">A</a> <a id="21532" class="Symbol">→</a> <a id="21534" class="PrimitiveType">Set</a><a id="21537" class="Symbol">)</a> <a id="21539" class="Symbol">:</a> <a id="21541" href="../Lists/#1067" class="Datatype">List</a> <a id="21546" href="../Lists/#21516" class="Bound">A</a> <a id="21548" class="Symbol">→</a> <a id="21550" class="PrimitiveType">Set</a> <a id="21554" class="Keyword">where</a>
  <a id="All.[]"></a><a id="21562" href="../Lists/#21562" class="InductiveConstructor">[]</a>  <a id="21566" class="Symbol">:</a> <a id="21568" href="../Lists/#21511" class="Datatype">All</a> <a id="21572" href="../Lists/#21526" class="Bound">P</a> <a id="21574" href="../Lists/#1096" class="InductiveConstructor">[]</a>
  <a id="All._∷_"></a><a id="21579" href="../Lists/#21579" class="InductiveConstructor Operator">_∷_</a> <a id="21583" class="Symbol">:</a> <a id="21585" class="Symbol">∀</a> <a id="21587" class="Symbol">{</a><a id="21588" href="../Lists/#21588" class="Bound">x</a> <a id="21590" class="Symbol">:</a> <a id="21592" href="../Lists/#21516" class="Bound">A</a><a id="21593" class="Symbol">}</a> <a id="21595" class="Symbol">{</a><a id="21596" href="../Lists/#21596" class="Bound">xs</a> <a id="21599" class="Symbol">:</a> <a id="21601" href="../Lists/#1067" class="Datatype">List</a> <a id="21606" href="../Lists/#21516" class="Bound">A</a><a id="21607" class="Symbol">}</a> <a id="21609" class="Symbol">→</a> <a id="21611" href="../Lists/#21526" class="Bound">P</a> <a id="21613" href="../Lists/#21588" class="Bound">x</a> <a id="21615" class="Symbol">→</a> <a id="21617" href="../Lists/#21511" class="Datatype">All</a> <a id="21621" href="../Lists/#21526" class="Bound">P</a> <a id="21623" href="../Lists/#21596" class="Bound">xs</a> <a id="21626" class="Symbol">→</a> <a id="21628" href="../Lists/#21511" class="Datatype">All</a> <a id="21632" href="../Lists/#21526" class="Bound">P</a> <a id="21634" class="Symbol">(</a><a id="21635" href="../Lists/#21588" class="Bound">x</a> <a id="21637" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="21639" href="../Lists/#21596" class="Bound">xs</a><a id="21641" class="Symbol">)</a>
</pre>
<p>The type has two constructors, reusing the names of the same constructors for lists. The first asserts that <code>P</code> holds for every element of the empty list. The second asserts that if <code>P</code> holds of the head of a list and for every element of the tail of a list, then <code>P</code> holds for every element of the list. Agda uses types to disambiguate whether the constructor is building a list or evidence that <code>All P</code> holds.</p>
For example, <code>All (_≤ 2)</code> holds of a list where every element is less than or equal to two. Recall that <code>z≤n</code> proves <code>zero ≤ n</code> for any <code>n</code>, and that if <code>m≤n</code> proves <code>m ≤ n</code> then <code>s≤s m≤n</code> proves <code>suc m ≤ suc n</code>, for any <code>m</code> and <code>n</code>:
<pre class="Agda"><a id="22299" href="../Lists/#22299" class="Function">_</a> <a id="22301" class="Symbol">:</a> <a id="22303" href="../Lists/#21511" class="Datatype">All</a> <a id="22307" class="Symbol">(</a><a id="22308" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Base.html#937" class="Datatype Operator">_≤</a> <a id="22311" class="Number">2</a><a id="22312" class="Symbol">)</a> <a id="22314" href="../Lists/#2881" class="InductiveConstructor Operator">[</a> <a id="22316" class="Number">0</a> <a id="22318" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="22320" class="Number">1</a> <a id="22322" href="../Lists/#2881" class="InductiveConstructor Operator">,</a> <a id="22324" class="Number">2</a> <a id="22326" href="../Lists/#2881" class="InductiveConstructor Operator">]</a>
<a id="22328" class="Symbol">_</a> <a id="22330" class="Symbol">=</a> <a id="22332" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Base.html#960" class="InductiveConstructor">z≤n</a> <a id="22336" href="../Lists/#21579" class="InductiveConstructor Operator">∷</a> <a id="22338" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Base.html#1002" class="InductiveConstructor">s≤s</a> <a id="22342" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Base.html#960" class="InductiveConstructor">z≤n</a> <a id="22346" href="../Lists/#21579" class="InductiveConstructor Operator">∷</a> <a id="22348" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Base.html#1002" class="InductiveConstructor">s≤s</a> <a id="22352" class="Symbol">(</a><a id="22353" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Base.html#1002" class="InductiveConstructor">s≤s</a> <a id="22357" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Base.html#960" class="InductiveConstructor">z≤n</a><a id="22360" class="Symbol">)</a> <a id="22362" href="../Lists/#21579" class="InductiveConstructor Operator">∷</a> <a id="22364" href="../Lists/#21562" class="InductiveConstructor">[]</a>
</pre>
<p>Here <code>_∷_</code> and <code>[]</code> are the constructors of <code>All P</code> rather than of <code>List A</code>. The three items are proofs of <code>0 ≤ 2</code>, <code>1 ≤ 2</code>, and <code>2 ≤ 2</code>, respectively.</p>
<p>(One might wonder whether a pattern such as <code>[_,_,_]</code> can be used to construct values of type <code>All</code> as well as type <code>List</code>, since both use the same constructors. Indeed it can, so long as both types are in scope when the pattern is declared. That’s not the case here, since <code>List</code> is defined before <code>[_,_,_]</code>, but <code>All</code> is defined later.)</p>
<h2 id="any">Any</h2>
Predicate <code>Any P</code> holds if predicate <code>P</code> is satisfied by some element of a list:
<pre class="Agda"><a id="22959" class="Keyword">data</a> <a id="Any"></a><a id="22964" href="../Lists/#22964" class="Datatype">Any</a> <a id="22968" class="Symbol">{</a><a id="22969" href="../Lists/#22969" class="Bound">A</a> <a id="22971" class="Symbol">:</a> <a id="22973" class="PrimitiveType">Set</a><a id="22976" class="Symbol">}</a> <a id="22978" class="Symbol">(</a><a id="22979" href="../Lists/#22979" class="Bound">P</a> <a id="22981" class="Symbol">:</a> <a id="22983" href="../Lists/#22969" class="Bound">A</a> <a id="22985" class="Symbol">→</a> <a id="22987" class="PrimitiveType">Set</a><a id="22990" class="Symbol">)</a> <a id="22992" class="Symbol">:</a> <a id="22994" href="../Lists/#1067" class="Datatype">List</a> <a id="22999" href="../Lists/#22969" class="Bound">A</a> <a id="23001" class="Symbol">→</a> <a id="23003" class="PrimitiveType">Set</a> <a id="23007" class="Keyword">where</a>
  <a id="Any.here"></a><a id="23015" href="../Lists/#23015" class="InductiveConstructor">here</a>  <a id="23021" class="Symbol">:</a> <a id="23023" class="Symbol">∀</a> <a id="23025" class="Symbol">{</a><a id="23026" href="../Lists/#23026" class="Bound">x</a> <a id="23028" class="Symbol">:</a> <a id="23030" href="../Lists/#22969" class="Bound">A</a><a id="23031" class="Symbol">}</a> <a id="23033" class="Symbol">{</a><a id="23034" href="../Lists/#23034" class="Bound">xs</a> <a id="23037" class="Symbol">:</a> <a id="23039" href="../Lists/#1067" class="Datatype">List</a> <a id="23044" href="../Lists/#22969" class="Bound">A</a><a id="23045" class="Symbol">}</a> <a id="23047" class="Symbol">→</a> <a id="23049" href="../Lists/#22979" class="Bound">P</a> <a id="23051" href="../Lists/#23026" class="Bound">x</a> <a id="23053" class="Symbol">→</a> <a id="23055" href="../Lists/#22964" class="Datatype">Any</a> <a id="23059" href="../Lists/#22979" class="Bound">P</a> <a id="23061" class="Symbol">(</a><a id="23062" href="../Lists/#23026" class="Bound">x</a> <a id="23064" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="23066" href="../Lists/#23034" class="Bound">xs</a><a id="23068" class="Symbol">)</a>
  <a id="Any.there"></a><a id="23072" href="../Lists/#23072" class="InductiveConstructor">there</a> <a id="23078" class="Symbol">:</a> <a id="23080" class="Symbol">∀</a> <a id="23082" class="Symbol">{</a><a id="23083" href="../Lists/#23083" class="Bound">x</a> <a id="23085" class="Symbol">:</a> <a id="23087" href="../Lists/#22969" class="Bound">A</a><a id="23088" class="Symbol">}</a> <a id="23090" class="Symbol">{</a><a id="23091" href="../Lists/#23091" class="Bound">xs</a> <a id="23094" class="Symbol">:</a> <a id="23096" href="../Lists/#1067" class="Datatype">List</a> <a id="23101" href="../Lists/#22969" class="Bound">A</a><a id="23102" class="Symbol">}</a> <a id="23104" class="Symbol">→</a> <a id="23106" href="../Lists/#22964" class="Datatype">Any</a> <a id="23110" href="../Lists/#22979" class="Bound">P</a> <a id="23112" href="../Lists/#23091" class="Bound">xs</a> <a id="23115" class="Symbol">→</a> <a id="23117" href="../Lists/#22964" class="Datatype">Any</a> <a id="23121" href="../Lists/#22979" class="Bound">P</a> <a id="23123" class="Symbol">(</a><a id="23124" href="../Lists/#23083" class="Bound">x</a> <a id="23126" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="23128" href="../Lists/#23091" class="Bound">xs</a><a id="23130" class="Symbol">)</a>
</pre>
The first constructor provides evidence that the head of the list satisfies <code>P</code>, while the second provides evidence that some element of the tail of the list satisfies <code>P</code>. For example, we can define list membership as follows:
<pre class="Agda"><a id="23369" class="Keyword">infix</a> <a id="23375" class="Number">4</a> <a id="23377" href="../Lists/#23386" class="Function Operator">_∈_</a> <a id="23381" href="../Lists/#23456" class="Function Operator">_∉_</a>

<a id="_∈_"></a><a id="23386" href="../Lists/#23386" class="Function Operator">_∈_</a> <a id="23390" class="Symbol">:</a> <a id="23392" class="Symbol">∀</a> <a id="23394" class="Symbol">{</a><a id="23395" href="../Lists/#23395" class="Bound">A</a> <a id="23397" class="Symbol">:</a> <a id="23399" class="PrimitiveType">Set</a><a id="23402" class="Symbol">}</a> <a id="23404" class="Symbol">(</a><a id="23405" href="../Lists/#23405" class="Bound">x</a> <a id="23407" class="Symbol">:</a> <a id="23409" href="../Lists/#23395" class="Bound">A</a><a id="23410" class="Symbol">)</a> <a id="23412" class="Symbol">(</a><a id="23413" href="../Lists/#23413" class="Bound">xs</a> <a id="23416" class="Symbol">:</a> <a id="23418" href="../Lists/#1067" class="Datatype">List</a> <a id="23423" href="../Lists/#23395" class="Bound">A</a><a id="23424" class="Symbol">)</a> <a id="23426" class="Symbol">→</a> <a id="23428" class="PrimitiveType">Set</a>
<a id="23432" href="../Lists/#23432" class="Bound">x</a> <a id="23434" href="../Lists/#23386" class="Function Operator">∈</a> <a id="23436" href="../Lists/#23436" class="Bound">xs</a> <a id="23439" class="Symbol">=</a> <a id="23441" href="../Lists/#22964" class="Datatype">Any</a> <a id="23445" class="Symbol">(</a><a id="23446" href="../Lists/#23432" class="Bound">x</a> <a id="23448" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡_</a><a id="23450" class="Symbol">)</a> <a id="23452" href="../Lists/#23436" class="Bound">xs</a>

<a id="_∉_"></a><a id="23456" href="../Lists/#23456" class="Function Operator">_∉_</a> <a id="23460" class="Symbol">:</a> <a id="23462" class="Symbol">∀</a> <a id="23464" class="Symbol">{</a><a id="23465" href="../Lists/#23465" class="Bound">A</a> <a id="23467" class="Symbol">:</a> <a id="23469" class="PrimitiveType">Set</a><a id="23472" class="Symbol">}</a> <a id="23474" class="Symbol">(</a><a id="23475" href="../Lists/#23475" class="Bound">x</a> <a id="23477" class="Symbol">:</a> <a id="23479" href="../Lists/#23465" class="Bound">A</a><a id="23480" class="Symbol">)</a> <a id="23482" class="Symbol">(</a><a id="23483" href="../Lists/#23483" class="Bound">xs</a> <a id="23486" class="Symbol">:</a> <a id="23488" href="../Lists/#1067" class="Datatype">List</a> <a id="23493" href="../Lists/#23465" class="Bound">A</a><a id="23494" class="Symbol">)</a> <a id="23496" class="Symbol">→</a> <a id="23498" class="PrimitiveType">Set</a>
<a id="23502" href="../Lists/#23502" class="Bound">x</a> <a id="23504" href="../Lists/#23456" class="Function Operator">∉</a> <a id="23506" href="../Lists/#23506" class="Bound">xs</a> <a id="23509" class="Symbol">=</a> <a id="23511" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#653" class="Function Operator">¬</a> <a id="23513" class="Symbol">(</a><a id="23514" href="../Lists/#23502" class="Bound">x</a> <a id="23516" href="../Lists/#23386" class="Function Operator">∈</a> <a id="23518" href="../Lists/#23506" class="Bound">xs</a><a id="23520" class="Symbol">)</a>
</pre>
For example, zero is an element of the list <code>[ 0 , 1 , 0 , 2 ]</code>. Indeed, we can demonstrate this fact in two different ways, corresponding to the two different occurrences of zero in the list, as the first element and as the third element:
<pre class="Agda"><a id="23771" href="../Lists/#23771" class="Function">_</a> <a id="23773" class="Symbol">:</a> <a id="23775" class="Number">0</a> <a id="23777" href="../Lists/#23386" class="Function Operator">∈</a> <a id="23779" href="../Lists/#2920" class="InductiveConstructor Operator">[</a> <a id="23781" class="Number">0</a> <a id="23783" href="../Lists/#2920" class="InductiveConstructor Operator">,</a> <a id="23785" class="Number">1</a> <a id="23787" href="../Lists/#2920" class="InductiveConstructor Operator">,</a> <a id="23789" class="Number">0</a> <a id="23791" href="../Lists/#2920" class="InductiveConstructor Operator">,</a> <a id="23793" class="Number">2</a> <a id="23795" href="../Lists/#2920" class="InductiveConstructor Operator">]</a>
<a id="23797" class="Symbol">_</a> <a id="23799" class="Symbol">=</a> <a id="23801" href="../Lists/#23015" class="InductiveConstructor">here</a> <a id="23806" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>

<a id="23812" href="../Lists/#23812" class="Function">_</a> <a id="23814" class="Symbol">:</a> <a id="23816" class="Number">0</a> <a id="23818" href="../Lists/#23386" class="Function Operator">∈</a> <a id="23820" href="../Lists/#2920" class="InductiveConstructor Operator">[</a> <a id="23822" class="Number">0</a> <a id="23824" href="../Lists/#2920" class="InductiveConstructor Operator">,</a> <a id="23826" class="Number">1</a> <a id="23828" href="../Lists/#2920" class="InductiveConstructor Operator">,</a> <a id="23830" class="Number">0</a> <a id="23832" href="../Lists/#2920" class="InductiveConstructor Operator">,</a> <a id="23834" class="Number">2</a> <a id="23836" href="../Lists/#2920" class="InductiveConstructor Operator">]</a>
<a id="23838" class="Symbol">_</a> <a id="23840" class="Symbol">=</a> <a id="23842" href="../Lists/#23072" class="InductiveConstructor">there</a> <a id="23848" class="Symbol">(</a><a id="23849" href="../Lists/#23072" class="InductiveConstructor">there</a> <a id="23855" class="Symbol">(</a><a id="23856" href="../Lists/#23015" class="InductiveConstructor">here</a> <a id="23861" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="23865" class="Symbol">))</a>
</pre>
Further, we can demonstrate that three is not in the list, because any possible proof that it is in the list leads to contradiction:
<pre class="Agda"><a id="not-in"></a><a id="24009" href="../Lists/#24009" class="Function">not-in</a> <a id="24016" class="Symbol">:</a> <a id="24018" class="Number">3</a> <a id="24020" href="../Lists/#23456" class="Function Operator">∉</a> <a id="24022" href="../Lists/#2920" class="InductiveConstructor Operator">[</a> <a id="24024" class="Number">0</a> <a id="24026" href="../Lists/#2920" class="InductiveConstructor Operator">,</a> <a id="24028" class="Number">1</a> <a id="24030" href="../Lists/#2920" class="InductiveConstructor Operator">,</a> <a id="24032" class="Number">0</a> <a id="24034" href="../Lists/#2920" class="InductiveConstructor Operator">,</a> <a id="24036" class="Number">2</a> <a id="24038" href="../Lists/#2920" class="InductiveConstructor Operator">]</a>
<a id="24040" href="../Lists/#24009" class="Function">not-in</a> <a id="24047" class="Symbol">(</a><a id="24048" href="../Lists/#23015" class="InductiveConstructor">here</a> <a id="24053" class="Symbol">())</a>
<a id="24057" href="../Lists/#24009" class="Function">not-in</a> <a id="24064" class="Symbol">(</a><a id="24065" href="../Lists/#23072" class="InductiveConstructor">there</a> <a id="24071" class="Symbol">(</a><a id="24072" href="../Lists/#23015" class="InductiveConstructor">here</a> <a id="24077" class="Symbol">()))</a>
<a id="24082" href="../Lists/#24009" class="Function">not-in</a> <a id="24089" class="Symbol">(</a><a id="24090" href="../Lists/#23072" class="InductiveConstructor">there</a> <a id="24096" class="Symbol">(</a><a id="24097" href="../Lists/#23072" class="InductiveConstructor">there</a> <a id="24103" class="Symbol">(</a><a id="24104" href="../Lists/#23015" class="InductiveConstructor">here</a> <a id="24109" class="Symbol">())))</a>
<a id="24115" href="../Lists/#24009" class="Function">not-in</a> <a id="24122" class="Symbol">(</a><a id="24123" href="../Lists/#23072" class="InductiveConstructor">there</a> <a id="24129" class="Symbol">(</a><a id="24130" href="../Lists/#23072" class="InductiveConstructor">there</a> <a id="24136" class="Symbol">(</a><a id="24137" href="../Lists/#23072" class="InductiveConstructor">there</a> <a id="24143" class="Symbol">(</a><a id="24144" href="../Lists/#23015" class="InductiveConstructor">here</a> <a id="24149" class="Symbol">()))))</a>
<a id="24156" href="../Lists/#24009" class="Function">not-in</a> <a id="24163" class="Symbol">(</a><a id="24164" href="../Lists/#23072" class="InductiveConstructor">there</a> <a id="24170" class="Symbol">(</a><a id="24171" href="../Lists/#23072" class="InductiveConstructor">there</a> <a id="24177" class="Symbol">(</a><a id="24178" href="../Lists/#23072" class="InductiveConstructor">there</a> <a id="24184" class="Symbol">(</a><a id="24185" href="../Lists/#23072" class="InductiveConstructor">there</a> <a id="24191" class="Symbol">()))))</a>
</pre>
<p>The five occurrences of <code>()</code> attest to the fact that there is no possible evidence for <code>3 ≡ 0</code>, <code>3 ≡ 1</code>, <code>3 ≡ 0</code>, <code>3 ≡ 2</code>, and <code>3 ∈ []</code>, respectively.</p>
<h2 id="all-and-append">All and append</h2>
A predicate holds for every element of one list appended to another if and only if it holds for every element of both lists:
<pre class="Agda"><a id="All-++-⇔"></a><a id="24502" href="../Lists/#24502" class="Function">All-++-⇔</a> <a id="24511" class="Symbol">:</a> <a id="24513" class="Symbol">∀</a> <a id="24515" class="Symbol">{</a><a id="24516" href="../Lists/#24516" class="Bound">A</a> <a id="24518" class="Symbol">:</a> <a id="24520" class="PrimitiveType">Set</a><a id="24523" class="Symbol">}</a> <a id="24525" class="Symbol">{</a><a id="24526" href="../Lists/#24526" class="Bound">P</a> <a id="24528" class="Symbol">:</a> <a id="24530" href="../Lists/#24516" class="Bound">A</a> <a id="24532" class="Symbol">→</a> <a id="24534" class="PrimitiveType">Set</a><a id="24537" class="Symbol">}</a> <a id="24539" class="Symbol">(</a><a id="24540" href="../Lists/#24540" class="Bound">xs</a> <a id="24543" href="../Lists/#24543" class="Bound">ys</a> <a id="24546" class="Symbol">:</a> <a id="24548" href="../Lists/#1067" class="Datatype">List</a> <a id="24553" href="../Lists/#24516" class="Bound">A</a><a id="24554" class="Symbol">)</a> <a id="24556" class="Symbol">→</a>
  <a id="24560" href="../Lists/#21511" class="Datatype">All</a> <a id="24564" href="../Lists/#24526" class="Bound">P</a> <a id="24566" class="Symbol">(</a><a id="24567" href="../Lists/#24540" class="Bound">xs</a> <a id="24570" href="../Lists/#3467" class="Function Operator">++</a> <a id="24573" href="../Lists/#24543" class="Bound">ys</a><a id="24575" class="Symbol">)</a> <a id="24577" href="../Isomorphism/#11988" class="Record Operator">⇔</a> <a id="24579" class="Symbol">(</a><a id="24580" href="../Lists/#21511" class="Datatype">All</a> <a id="24584" href="../Lists/#24526" class="Bound">P</a> <a id="24586" href="../Lists/#24540" class="Bound">xs</a> <a id="24589" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1167" class="Function Operator">×</a> <a id="24591" href="../Lists/#21511" class="Datatype">All</a> <a id="24595" href="../Lists/#24526" class="Bound">P</a> <a id="24597" href="../Lists/#24543" class="Bound">ys</a><a id="24599" class="Symbol">)</a>
<a id="24601" href="../Lists/#24502" class="Function">All-++-⇔</a> <a id="24610" href="../Lists/#24610" class="Bound">xs</a> <a id="24613" href="../Lists/#24613" class="Bound">ys</a> <a id="24616" class="Symbol">=</a>
  <a id="24620" class="Keyword">record</a>
    <a id="24631" class="Symbol">{</a> <a id="24633" href="../Isomorphism/#12028" class="Field">to</a>       <a id="24642" class="Symbol">=</a>  <a id="24645" href="../Lists/#24700" class="Function">to</a> <a id="24648" href="../Lists/#24610" class="Bound">xs</a> <a id="24651" href="../Lists/#24613" class="Bound">ys</a>
    <a id="24658" class="Symbol">;</a> <a id="24660" href="../Isomorphism/#12045" class="Field">from</a>     <a id="24669" class="Symbol">=</a>  <a id="24672" href="../Lists/#24925" class="Function">from</a> <a id="24677" href="../Lists/#24610" class="Bound">xs</a> <a id="24680" href="../Lists/#24613" class="Bound">ys</a>
    <a id="24687" class="Symbol">}</a>
  <a id="24691" class="Keyword">where</a>

  <a id="24700" href="../Lists/#24700" class="Function">to</a> <a id="24703" class="Symbol">:</a> <a id="24705" class="Symbol">∀</a> <a id="24707" class="Symbol">{</a><a id="24708" href="../Lists/#24708" class="Bound">A</a> <a id="24710" class="Symbol">:</a> <a id="24712" class="PrimitiveType">Set</a><a id="24715" class="Symbol">}</a> <a id="24717" class="Symbol">{</a><a id="24718" href="../Lists/#24718" class="Bound">P</a> <a id="24720" class="Symbol">:</a> <a id="24722" href="../Lists/#24708" class="Bound">A</a> <a id="24724" class="Symbol">→</a> <a id="24726" class="PrimitiveType">Set</a><a id="24729" class="Symbol">}</a> <a id="24731" class="Symbol">(</a><a id="24732" href="../Lists/#24732" class="Bound">xs</a> <a id="24735" href="../Lists/#24735" class="Bound">ys</a> <a id="24738" class="Symbol">:</a> <a id="24740" href="../Lists/#1067" class="Datatype">List</a> <a id="24745" href="../Lists/#24708" class="Bound">A</a><a id="24746" class="Symbol">)</a> <a id="24748" class="Symbol">→</a>
    <a id="24754" href="../Lists/#21511" class="Datatype">All</a> <a id="24758" href="../Lists/#24718" class="Bound">P</a> <a id="24760" class="Symbol">(</a><a id="24761" href="../Lists/#24732" class="Bound">xs</a> <a id="24764" href="../Lists/#3467" class="Function Operator">++</a> <a id="24767" href="../Lists/#24735" class="Bound">ys</a><a id="24769" class="Symbol">)</a> <a id="24771" class="Symbol">→</a> <a id="24773" class="Symbol">(</a><a id="24774" href="../Lists/#21511" class="Datatype">All</a> <a id="24778" href="../Lists/#24718" class="Bound">P</a> <a id="24780" href="../Lists/#24732" class="Bound">xs</a> <a id="24783" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1167" class="Function Operator">×</a> <a id="24785" href="../Lists/#21511" class="Datatype">All</a> <a id="24789" href="../Lists/#24718" class="Bound">P</a> <a id="24791" href="../Lists/#24735" class="Bound">ys</a><a id="24793" class="Symbol">)</a>
  <a id="24797" href="../Lists/#24700" class="Function">to</a> <a id="24800" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="24803" href="../Lists/#24803" class="Bound">ys</a> <a id="24806" href="../Lists/#24806" class="Bound">Pys</a> <a id="24810" class="Symbol">=</a> <a id="24812" href="../Lists/#880" class="InductiveConstructor Operator">⟨</a> <a id="24814" href="../Lists/#21562" class="InductiveConstructor">[]</a> <a id="24817" href="../Lists/#880" class="InductiveConstructor Operator">,</a> <a id="24819" href="../Lists/#24806" class="Bound">Pys</a> <a id="24823" href="../Lists/#880" class="InductiveConstructor Operator">⟩</a>
  <a id="24827" href="../Lists/#24700" class="Function">to</a> <a id="24830" class="Symbol">(</a><a id="24831" href="../Lists/#24831" class="Bound">x</a> <a id="24833" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="24835" href="../Lists/#24835" class="Bound">xs</a><a id="24837" class="Symbol">)</a> <a id="24839" href="../Lists/#24839" class="Bound">ys</a> <a id="24842" class="Symbol">(</a><a id="24843" href="../Lists/#24843" class="Bound">Px</a> <a id="24846" href="../Lists/#21579" class="InductiveConstructor Operator">∷</a> <a id="24848" href="../Lists/#24848" class="Bound">Pxs++ys</a><a id="24855" class="Symbol">)</a> <a id="24857" class="Keyword">with</a> <a id="24862" href="../Lists/#24700" class="Function">to</a> <a id="24865" href="../Lists/#24835" class="Bound">xs</a> <a id="24868" href="../Lists/#24839" class="Bound">ys</a> <a id="24871" href="../Lists/#24848" class="Bound">Pxs++ys</a>
  <a id="24881" class="Symbol">...</a> <a id="24885" class="Symbol">|</a> <a id="24887" href="../Lists/#880" class="InductiveConstructor Operator">⟨</a> <a id="24889" href="../Lists/#24889" class="Bound">Pxs</a> <a id="24893" href="../Lists/#880" class="InductiveConstructor Operator">,</a> <a id="24895" href="../Lists/#24895" class="Bound">Pys</a> <a id="24899" href="../Lists/#880" class="InductiveConstructor Operator">⟩</a> <a id="24901" class="Symbol">=</a> <a id="24903" href="../Lists/#880" class="InductiveConstructor Operator">⟨</a> <a id="24905" class="Bound">Px</a> <a id="24908" href="../Lists/#21579" class="InductiveConstructor Operator">∷</a> <a id="24910" href="../Lists/#24889" class="Bound">Pxs</a> <a id="24914" href="../Lists/#880" class="InductiveConstructor Operator">,</a> <a id="24916" href="../Lists/#24895" class="Bound">Pys</a> <a id="24920" href="../Lists/#880" class="InductiveConstructor Operator">⟩</a>

  <a id="24925" href="../Lists/#24925" class="Function">from</a> <a id="24930" class="Symbol">:</a> <a id="24932" class="Symbol">∀</a> <a id="24934" class="Symbol">{</a> <a id="24936" href="../Lists/#24936" class="Bound">A</a> <a id="24938" class="Symbol">:</a> <a id="24940" class="PrimitiveType">Set</a><a id="24943" class="Symbol">}</a> <a id="24945" class="Symbol">{</a><a id="24946" href="../Lists/#24946" class="Bound">P</a> <a id="24948" class="Symbol">:</a> <a id="24950" href="../Lists/#24936" class="Bound">A</a> <a id="24952" class="Symbol">→</a> <a id="24954" class="PrimitiveType">Set</a><a id="24957" class="Symbol">}</a> <a id="24959" class="Symbol">(</a><a id="24960" href="../Lists/#24960" class="Bound">xs</a> <a id="24963" href="../Lists/#24963" class="Bound">ys</a> <a id="24966" class="Symbol">:</a> <a id="24968" href="../Lists/#1067" class="Datatype">List</a> <a id="24973" href="../Lists/#24936" class="Bound">A</a><a id="24974" class="Symbol">)</a> <a id="24976" class="Symbol">→</a>
    <a id="24982" href="../Lists/#21511" class="Datatype">All</a> <a id="24986" href="../Lists/#24946" class="Bound">P</a> <a id="24988" href="../Lists/#24960" class="Bound">xs</a> <a id="24991" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1167" class="Function Operator">×</a> <a id="24993" href="../Lists/#21511" class="Datatype">All</a> <a id="24997" href="../Lists/#24946" class="Bound">P</a> <a id="24999" href="../Lists/#24963" class="Bound">ys</a> <a id="25002" class="Symbol">→</a> <a id="25004" href="../Lists/#21511" class="Datatype">All</a> <a id="25008" href="../Lists/#24946" class="Bound">P</a> <a id="25010" class="Symbol">(</a><a id="25011" href="../Lists/#24960" class="Bound">xs</a> <a id="25014" href="../Lists/#3467" class="Function Operator">++</a> <a id="25017" href="../Lists/#24963" class="Bound">ys</a><a id="25019" class="Symbol">)</a>
  <a id="25023" href="../Lists/#24925" class="Function">from</a> <a id="25028" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="25031" href="../Lists/#25031" class="Bound">ys</a> <a id="25034" href="../Lists/#880" class="InductiveConstructor Operator">⟨</a> <a id="25036" href="../Lists/#21562" class="InductiveConstructor">[]</a> <a id="25039" href="../Lists/#880" class="InductiveConstructor Operator">,</a> <a id="25041" href="../Lists/#25041" class="Bound">Pys</a> <a id="25045" href="../Lists/#880" class="InductiveConstructor Operator">⟩</a> <a id="25047" class="Symbol">=</a> <a id="25049" href="../Lists/#25041" class="Bound">Pys</a>
  <a id="25055" href="../Lists/#24925" class="Function">from</a> <a id="25060" class="Symbol">(</a><a id="25061" href="../Lists/#25061" class="Bound">x</a> <a id="25063" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="25065" href="../Lists/#25065" class="Bound">xs</a><a id="25067" class="Symbol">)</a> <a id="25069" href="../Lists/#25069" class="Bound">ys</a> <a id="25072" href="../Lists/#880" class="InductiveConstructor Operator">⟨</a> <a id="25074" href="../Lists/#25074" class="Bound">Px</a> <a id="25077" href="../Lists/#21579" class="InductiveConstructor Operator">∷</a> <a id="25079" href="../Lists/#25079" class="Bound">Pxs</a> <a id="25083" href="../Lists/#880" class="InductiveConstructor Operator">,</a> <a id="25085" href="../Lists/#25085" class="Bound">Pys</a> <a id="25089" href="../Lists/#880" class="InductiveConstructor Operator">⟩</a> <a id="25091" class="Symbol">=</a>  <a id="25094" href="../Lists/#25074" class="Bound">Px</a> <a id="25097" href="../Lists/#21579" class="InductiveConstructor Operator">∷</a> <a id="25099" href="../Lists/#24925" class="Function">from</a> <a id="25104" href="../Lists/#25065" class="Bound">xs</a> <a id="25107" href="../Lists/#25069" class="Bound">ys</a> <a id="25110" href="../Lists/#880" class="InductiveConstructor Operator">⟨</a> <a id="25112" href="../Lists/#25079" class="Bound">Pxs</a> <a id="25116" href="../Lists/#880" class="InductiveConstructor Operator">,</a> <a id="25118" href="../Lists/#25085" class="Bound">Pys</a> <a id="25122" href="../Lists/#880" class="InductiveConstructor Operator">⟩</a>
</pre>
<h4 id="exercise-any---recommended">Exercise <code>Any-++-⇔</code> (recommended)</h4>
<p>Prove a result similar to <code>All-++-⇔</code>, but with <code>Any</code> in place of <code>All</code>, and a suitable replacement for <code>_×_</code>. As a consequence, demonstrate an equivalence relating <code>_∈_</code> and <code>_++_</code>.</p>
<pre class="Agda"><a id="25357" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise-all---stretch">Exercise <code>All-++-≃</code> (stretch)</h4>
<p>Show that the equivalence <code>All-++-⇔</code> can be extended to an isomorphism.</p>
<pre class="Agda"><a id="25498" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise-anyall-recommended">Exercise <code>¬Any⇔All¬</code> (recommended)</h4>
<p>Show that <code>Any</code> and <code>All</code> satisfy a version of De Morgan’s Law:</p>
<pre><code>(¬_ ∘ Any P) xs ⇔ All (¬_ ∘ P) xs</code></pre>
<p>(Can you see why it is important that here <code>_∘_</code> is generalised to arbitrary levels, as described in the section on <a href="../Equality/#unipoly">universe polymorphism</a>?)</p>
<p>Do we also have the following?</p>
<pre><code>(¬_ ∘ All P) xs ⇔ Any (¬_ ∘ P) xs</code></pre>
<p>If so, prove; if not, explain why.</p>
<pre class="Agda"><a id="25946" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise-anyall-stretch">Exercise <code>¬Any≃All¬</code> (stretch)</h4>
<p>Show that the equivalence <code>¬Any⇔All¬</code> can be extended to an isomorphism. You will need to use extensionality.</p>
<pre class="Agda"><a id="26126" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise-all--practice">Exercise <code>All-∀</code> (practice)</h4>
<p>Show that <code>All P xs</code> is isomorphic to <code>∀ {x} → x ∈ xs → P x</code>.</p>
<pre class="Agda"><a id="26255" class="Comment">-- You code goes here</a>
</pre>
<h4 id="exercise-any--practice">Exercise <code>Any-∃</code> (practice)</h4>
<p>Show that <code>Any P xs</code> is isomorphic to <code>∃[ x ] (x ∈ xs × P x)</code>.</p>
<pre class="Agda"><a id="26385" class="Comment">-- You code goes here</a>
</pre>
<h2 id="decidability-of-all">Decidability of All</h2>
If we consider a predicate as a function that yields a boolean, it is easy to define an analogue of <code>All</code>, which returns true if a given predicate returns true for every element of a list:
<pre class="Agda"><a id="all"></a><a id="26630" href="../Lists/#26630" class="Function">all</a> <a id="26634" class="Symbol">:</a> <a id="26636" class="Symbol">∀</a> <a id="26638" class="Symbol">{</a><a id="26639" href="../Lists/#26639" class="Bound">A</a> <a id="26641" class="Symbol">:</a> <a id="26643" class="PrimitiveType">Set</a><a id="26646" class="Symbol">}</a> <a id="26648" class="Symbol">→</a> <a id="26650" class="Symbol">(</a><a id="26651" href="../Lists/#26639" class="Bound">A</a> <a id="26653" class="Symbol">→</a> <a id="26655" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="26659" class="Symbol">)</a> <a id="26661" class="Symbol">→</a> <a id="26663" href="../Lists/#1067" class="Datatype">List</a> <a id="26668" href="../Lists/#26639" class="Bound">A</a> <a id="26670" class="Symbol">→</a> <a id="26672" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
<a id="26677" href="../Lists/#26630" class="Function">all</a> <a id="26681" href="../Lists/#26681" class="Bound">p</a>  <a id="26684" class="Symbol">=</a>  <a id="26687" href="../Lists/#15273" class="Function">foldr</a> <a id="26693" href="https://agda.github.io/agda-stdlib/v1.3/Data.Bool.Base.html#986" class="Function Operator">_∧_</a> <a id="26697" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="26702" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">∘</a> <a id="26704" href="../Lists/#12847" class="Function">map</a> <a id="26708" href="../Lists/#26681" class="Bound">p</a>
</pre>
<p>The function can be written in a particularly compact style by using the higher-order functions <code>map</code> and <code>foldr</code>.</p>
As one would hope, if we replace booleans by decidables there is again an analogue of <code>All</code>. First, return to the notion of a predicate <code>P</code> as a function of type <code>A → Set</code>, taking a value <code>x</code> of type <code>A</code> into evidence <code>P x</code> that a property holds for <code>x</code>. Say that a predicate <code>P</code> is <em>decidable</em> if we have a function that for a given <code>x</code> can decide <code>P x</code>:
<pre class="Agda"><a id="Decidable"></a><a id="27192" href="../Lists/#27192" class="Function">Decidable</a> <a id="27202" class="Symbol">:</a> <a id="27204" class="Symbol">∀</a> <a id="27206" class="Symbol">{</a><a id="27207" href="../Lists/#27207" class="Bound">A</a> <a id="27209" class="Symbol">:</a> <a id="27211" class="PrimitiveType">Set</a><a id="27214" class="Symbol">}</a> <a id="27216" class="Symbol">→</a> <a id="27218" class="Symbol">(</a><a id="27219" href="../Lists/#27207" class="Bound">A</a> <a id="27221" class="Symbol">→</a> <a id="27223" class="PrimitiveType">Set</a><a id="27226" class="Symbol">)</a> <a id="27228" class="Symbol">→</a> <a id="27230" class="PrimitiveType">Set</a>
<a id="27234" href="../Lists/#27192" class="Function">Decidable</a> <a id="27244" class="Symbol">{</a><a id="27245" href="../Lists/#27245" class="Bound">A</a><a id="27246" class="Symbol">}</a> <a id="27248" href="../Lists/#27248" class="Bound">P</a>  <a id="27251" class="Symbol">=</a>  <a id="27254" class="Symbol">∀</a> <a id="27256" class="Symbol">(</a><a id="27257" href="../Lists/#27257" class="Bound">x</a> <a id="27259" class="Symbol">:</a> <a id="27261" href="../Lists/#27245" class="Bound">A</a><a id="27262" class="Symbol">)</a> <a id="27264" class="Symbol">→</a> <a id="27266" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1508" class="Record">Dec</a> <a id="27270" class="Symbol">(</a><a id="27271" href="../Lists/#27248" class="Bound">P</a> <a id="27273" href="../Lists/#27257" class="Bound">x</a><a id="27274" class="Symbol">)</a>
</pre>
Then if predicate <code>P</code> is decidable, it is also decidable whether every element of a list satisfies the predicate:
<pre class="Agda"><a id="All?"></a><a id="27398" href="../Lists/#27398" class="Function">All?</a> <a id="27403" class="Symbol">:</a> <a id="27405" class="Symbol">∀</a> <a id="27407" class="Symbol">{</a><a id="27408" href="../Lists/#27408" class="Bound">A</a> <a id="27410" class="Symbol">:</a> <a id="27412" class="PrimitiveType">Set</a><a id="27415" class="Symbol">}</a> <a id="27417" class="Symbol">{</a><a id="27418" href="../Lists/#27418" class="Bound">P</a> <a id="27420" class="Symbol">:</a> <a id="27422" href="../Lists/#27408" class="Bound">A</a> <a id="27424" class="Symbol">→</a> <a id="27426" class="PrimitiveType">Set</a><a id="27429" class="Symbol">}</a> <a id="27431" class="Symbol">→</a> <a id="27433" href="../Lists/#27192" class="Function">Decidable</a> <a id="27443" href="../Lists/#27418" class="Bound">P</a> <a id="27445" class="Symbol">→</a> <a id="27447" href="../Lists/#27192" class="Function">Decidable</a> <a id="27457" class="Symbol">(</a><a id="27458" href="../Lists/#21511" class="Datatype">All</a> <a id="27462" href="../Lists/#27418" class="Bound">P</a><a id="27463" class="Symbol">)</a>
<a id="27465" href="../Lists/#27398" class="Function">All?</a> <a id="27470" href="../Lists/#27470" class="Bound">P?</a> <a id="27473" href="../Lists/#1096" class="InductiveConstructor">[]</a>                                 <a id="27508" class="Symbol">=</a>  <a id="27511" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1645" class="InductiveConstructor">yes</a> <a id="27515" href="../Lists/#21562" class="InductiveConstructor">[]</a>
<a id="27518" href="../Lists/#27398" class="Function">All?</a> <a id="27523" href="../Lists/#27523" class="Bound">P?</a> <a id="27526" class="Symbol">(</a><a id="27527" href="../Lists/#27527" class="Bound">x</a> <a id="27529" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="27531" href="../Lists/#27531" class="Bound">xs</a><a id="27533" class="Symbol">)</a> <a id="27535" class="Keyword">with</a> <a id="27540" href="../Lists/#27523" class="Bound">P?</a> <a id="27543" href="../Lists/#27527" class="Bound">x</a>   <a id="27547" class="Symbol">|</a> <a id="27549" href="../Lists/#27398" class="Function">All?</a> <a id="27554" href="../Lists/#27523" class="Bound">P?</a> <a id="27557" href="../Lists/#27531" class="Bound">xs</a>
<a id="27560" class="Symbol">...</a>                 <a id="27580" class="Symbol">|</a> <a id="27582" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1645" class="InductiveConstructor">yes</a> <a id="27586" href="../Lists/#27586" class="Bound">Px</a> <a id="27589" class="Symbol">|</a> <a id="27591" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1645" class="InductiveConstructor">yes</a> <a id="27595" href="../Lists/#27595" class="Bound">Pxs</a>     <a id="27603" class="Symbol">=</a>  <a id="27606" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1645" class="InductiveConstructor">yes</a> <a id="27610" class="Symbol">(</a><a id="27611" href="../Lists/#27586" class="Bound">Px</a> <a id="27614" href="../Lists/#21579" class="InductiveConstructor Operator">∷</a> <a id="27616" href="../Lists/#27595" class="Bound">Pxs</a><a id="27619" class="Symbol">)</a>
<a id="27621" class="Symbol">...</a>                 <a id="27641" class="Symbol">|</a> <a id="27643" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1682" class="InductiveConstructor">no</a> <a id="27646" href="../Lists/#27646" class="Bound">¬Px</a> <a id="27650" class="Symbol">|</a> <a id="27652" class="Symbol">_</a>           <a id="27664" class="Symbol">=</a>  <a id="27667" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1682" class="InductiveConstructor">no</a> <a id="27670" class="Symbol">λ{</a> <a id="27673" class="Symbol">(</a><a id="27674" href="../Lists/#27674" class="Bound">Px</a> <a id="27677" href="../Lists/#21579" class="InductiveConstructor Operator">∷</a> <a id="27679" href="../Lists/#27679" class="Bound">Pxs</a><a id="27682" class="Symbol">)</a> <a id="27684" class="Symbol">→</a> <a id="27686" href="../Lists/#27646" class="Bound">¬Px</a> <a id="27690" href="../Lists/#27674" class="Bound">Px</a>   <a id="27695" class="Symbol">}</a>
<a id="27697" class="CatchallClause Symbol">...</a><a id="27700" class="CatchallClause">                 </a><a id="27717" class="CatchallClause Symbol">|</a><a id="27718" class="CatchallClause"> </a><a id="27719" class="CatchallClause Symbol">_</a><a id="27720" class="CatchallClause">      </a><a id="27726" class="CatchallClause Symbol">|</a><a id="27727" class="CatchallClause"> </a><a id="27728" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1682" class="CatchallClause InductiveConstructor">no</a><a id="27730" class="CatchallClause"> </a><a id="27731" href="../Lists/#27731" class="CatchallClause Bound">¬Pxs</a>     <a id="27740" class="Symbol">=</a>  <a id="27743" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1682" class="InductiveConstructor">no</a> <a id="27746" class="Symbol">λ{</a> <a id="27749" class="Symbol">(</a><a id="27750" href="../Lists/#27750" class="Bound">Px</a> <a id="27753" href="../Lists/#21579" class="InductiveConstructor Operator">∷</a> <a id="27755" href="../Lists/#27755" class="Bound">Pxs</a><a id="27758" class="Symbol">)</a> <a id="27760" class="Symbol">→</a> <a id="27762" href="../Lists/#27731" class="Bound">¬Pxs</a> <a id="27767" href="../Lists/#27755" class="Bound">Pxs</a> <a id="27771" class="Symbol">}</a>
</pre>
<p>If the list is empty, then trivially <code>P</code> holds for every element of the list. Otherwise, the structure of the proof is similar to that showing that the conjunction of two decidable propositions is itself decidable, using <code>_∷_</code> rather than <code>⟨_,_⟩</code> to combine the evidence for the head and tail of the list.</p>
<h4 id="exercise-any-stretch">Exercise <code>Any?</code> (stretch)</h4>
<p>Just as <code>All</code> has analogues <code>all</code> and <code>All?</code> which determine whether a predicate holds for every element of a list, so does <code>Any</code> have analogues <code>any</code> and <code>Any?</code> which determine whether a predicate holds for some element of a list. Give their definitions.</p>
<pre class="Agda"><a id="28380" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise-split-stretch">Exercise <code>split</code> (stretch)</h4>
The relation <code>merge</code> holds when two lists merge to give a third list.
<pre class="Agda"><a id="28516" class="Keyword">data</a> <a id="merge"></a><a id="28521" href="../Lists/#28521" class="Datatype">merge</a> <a id="28527" class="Symbol">{</a><a id="28528" href="../Lists/#28528" class="Bound">A</a> <a id="28530" class="Symbol">:</a> <a id="28532" class="PrimitiveType">Set</a><a id="28535" class="Symbol">}</a> <a id="28537" class="Symbol">:</a> <a id="28539" class="Symbol">(</a><a id="28540" href="../Lists/#28540" class="Bound">xs</a> <a id="28543" href="../Lists/#28543" class="Bound">ys</a> <a id="28546" href="../Lists/#28546" class="Bound">zs</a> <a id="28549" class="Symbol">:</a> <a id="28551" href="../Lists/#1067" class="Datatype">List</a> <a id="28556" href="../Lists/#28528" class="Bound">A</a><a id="28557" class="Symbol">)</a> <a id="28559" class="Symbol">→</a> <a id="28561" class="PrimitiveType">Set</a> <a id="28565" class="Keyword">where</a>

  <a id="merge.[]"></a><a id="28574" href="../Lists/#28574" class="InductiveConstructor">[]</a> <a id="28577" class="Symbol">:</a>
      <a id="28585" class="Comment">--------------</a>
      <a id="28606" href="../Lists/#28521" class="Datatype">merge</a> <a id="28612" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="28615" href="../Lists/#1096" class="InductiveConstructor">[]</a> <a id="28618" href="../Lists/#1096" class="InductiveConstructor">[]</a>

  <a id="merge.left-∷"></a><a id="28624" href="../Lists/#28624" class="InductiveConstructor">left-∷</a> <a id="28631" class="Symbol">:</a> <a id="28633" class="Symbol">∀</a> <a id="28635" class="Symbol">{</a><a id="28636" href="../Lists/#28636" class="Bound">x</a> <a id="28638" href="../Lists/#28638" class="Bound">xs</a> <a id="28641" href="../Lists/#28641" class="Bound">ys</a> <a id="28644" href="../Lists/#28644" class="Bound">zs</a><a id="28646" class="Symbol">}</a>
    <a id="28652" class="Symbol">→</a> <a id="28654" href="../Lists/#28521" class="Datatype">merge</a> <a id="28660" href="../Lists/#28638" class="Bound">xs</a> <a id="28663" href="../Lists/#28641" class="Bound">ys</a> <a id="28666" href="../Lists/#28644" class="Bound">zs</a>
      <a id="28675" class="Comment">--------------------------</a>
    <a id="28706" class="Symbol">→</a> <a id="28708" href="../Lists/#28521" class="Datatype">merge</a> <a id="28714" class="Symbol">(</a><a id="28715" href="../Lists/#28636" class="Bound">x</a> <a id="28717" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="28719" href="../Lists/#28638" class="Bound">xs</a><a id="28721" class="Symbol">)</a> <a id="28723" href="../Lists/#28641" class="Bound">ys</a> <a id="28726" class="Symbol">(</a><a id="28727" href="../Lists/#28636" class="Bound">x</a> <a id="28729" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="28731" href="../Lists/#28644" class="Bound">zs</a><a id="28733" class="Symbol">)</a>

  <a id="merge.right-∷"></a><a id="28738" href="../Lists/#28738" class="InductiveConstructor">right-∷</a> <a id="28746" class="Symbol">:</a> <a id="28748" class="Symbol">∀</a> <a id="28750" class="Symbol">{</a><a id="28751" href="../Lists/#28751" class="Bound">y</a> <a id="28753" href="../Lists/#28753" class="Bound">xs</a> <a id="28756" href="../Lists/#28756" class="Bound">ys</a> <a id="28759" href="../Lists/#28759" class="Bound">zs</a><a id="28761" class="Symbol">}</a>
    <a id="28767" class="Symbol">→</a> <a id="28769" href="../Lists/#28521" class="Datatype">merge</a> <a id="28775" href="../Lists/#28753" class="Bound">xs</a> <a id="28778" href="../Lists/#28756" class="Bound">ys</a> <a id="28781" href="../Lists/#28759" class="Bound">zs</a>
      <a id="28790" class="Comment">--------------------------</a>
    <a id="28821" class="Symbol">→</a> <a id="28823" href="../Lists/#28521" class="Datatype">merge</a> <a id="28829" href="../Lists/#28753" class="Bound">xs</a> <a id="28832" class="Symbol">(</a><a id="28833" href="../Lists/#28751" class="Bound">y</a> <a id="28835" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="28837" href="../Lists/#28756" class="Bound">ys</a><a id="28839" class="Symbol">)</a> <a id="28841" class="Symbol">(</a><a id="28842" href="../Lists/#28751" class="Bound">y</a> <a id="28844" href="../Lists/#1111" class="InductiveConstructor Operator">∷</a> <a id="28846" href="../Lists/#28759" class="Bound">zs</a><a id="28848" class="Symbol">)</a>
</pre>
For example,
<pre class="Agda"><a id="28872" href="../Lists/#28872" class="Function">_</a> <a id="28874" class="Symbol">:</a> <a id="28876" href="../Lists/#28521" class="Datatype">merge</a> <a id="28882" href="../Lists/#2850" class="InductiveConstructor Operator">[</a> <a id="28884" class="Number">1</a> <a id="28886" href="../Lists/#2850" class="InductiveConstructor Operator">,</a> <a id="28888" class="Number">4</a> <a id="28890" href="../Lists/#2850" class="InductiveConstructor Operator">]</a> <a id="28892" href="../Lists/#2850" class="InductiveConstructor Operator">[</a> <a id="28894" class="Number">2</a> <a id="28896" href="../Lists/#2850" class="InductiveConstructor Operator">,</a> <a id="28898" class="Number">3</a> <a id="28900" href="../Lists/#2850" class="InductiveConstructor Operator">]</a> <a id="28902" href="../Lists/#2920" class="InductiveConstructor Operator">[</a> <a id="28904" class="Number">1</a> <a id="28906" href="../Lists/#2920" class="InductiveConstructor Operator">,</a> <a id="28908" class="Number">2</a> <a id="28910" href="../Lists/#2920" class="InductiveConstructor Operator">,</a> <a id="28912" class="Number">3</a> <a id="28914" href="../Lists/#2920" class="InductiveConstructor Operator">,</a> <a id="28916" class="Number">4</a> <a id="28918" href="../Lists/#2920" class="InductiveConstructor Operator">]</a>
<a id="28920" class="Symbol">_</a> <a id="28922" class="Symbol">=</a> <a id="28924" href="../Lists/#28624" class="InductiveConstructor">left-∷</a> <a id="28931" class="Symbol">(</a><a id="28932" href="../Lists/#28738" class="InductiveConstructor">right-∷</a> <a id="28940" class="Symbol">(</a><a id="28941" href="../Lists/#28738" class="InductiveConstructor">right-∷</a> <a id="28949" class="Symbol">(</a><a id="28950" href="../Lists/#28624" class="InductiveConstructor">left-∷</a> <a id="28957" href="../Lists/#28574" class="InductiveConstructor">[]</a><a id="28959" class="Symbol">)))</a>

</pre>
<p>Given a decidable predicate and a list, we can split the list into two lists that merge to give the original list, where all elements of one list satisfy the predicate, and all elements of the other do not satisfy the predicate.</p>
<p>Define the following variant of the traditional <code>filter</code> function on lists, which given a decidable predicate and a list returns a list of elements that satisfy the predicate and a list of elements that don’t, with their corresponding proofs.</p>
<pre><code>split : ∀ {A : Set} {P : A → Set} (P? : Decidable P) (zs : List A)
  → ∃[ xs ] ∃[ ys ] ( merge xs ys zs × All P xs × All (¬_ ∘ P) ys )</code></pre>
<pre class="Agda"><a id="29591" class="Comment">-- Your code goes here</a>
</pre>
<h2 id="standard-library">Standard Library</h2>
Definitions similar to those in this chapter can be found in the standard library:
<pre class="Agda"><a id="29727" class="Keyword">import</a> <a id="29734" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.html" class="Module">Data.List</a> <a id="29744" class="Keyword">using</a> <a id="29750" class="Symbol">(</a><a id="29751" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.List.html#148" class="Datatype">List</a><a id="29755" class="Symbol">;</a> <a id="29757" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Base.html#1763" class="Function Operator">_++_</a><a id="29761" class="Symbol">;</a> <a id="29763" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Base.html#4297" class="Function">length</a><a id="29769" class="Symbol">;</a> <a id="29771" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Base.html#9161" class="Function">reverse</a><a id="29778" class="Symbol">;</a> <a id="29780" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Base.html#1497" class="Function">map</a><a id="29783" class="Symbol">;</a> <a id="29785" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Base.html#3625" class="Function">foldr</a><a id="29790" class="Symbol">;</a> <a id="29792" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Base.html#5703" class="Function">downFrom</a><a id="29800" class="Symbol">)</a>
<a id="29802" class="Keyword">import</a> <a id="29809" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Relation.Unary.All.html" class="Module">Data.List.Relation.Unary.All</a> <a id="29838" class="Keyword">using</a> <a id="29844" class="Symbol">(</a><a id="29845" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Relation.Unary.All.html#1274" class="Datatype">All</a><a id="29848" class="Symbol">;</a> <a id="29850" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Relation.Unary.All.html#1337" class="InductiveConstructor">[]</a><a id="29852" class="Symbol">;</a> <a id="29854" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Relation.Unary.All.html#1354" class="InductiveConstructor Operator">_∷_</a><a id="29857" class="Symbol">)</a>
<a id="29859" class="Keyword">import</a> <a id="29866" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Relation.Unary.Any.html" class="Module">Data.List.Relation.Unary.Any</a> <a id="29895" class="Keyword">using</a> <a id="29901" class="Symbol">(</a><a id="29902" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Relation.Unary.Any.html#1111" class="Datatype">Any</a><a id="29905" class="Symbol">;</a> <a id="29907" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Relation.Unary.Any.html#1174" class="InductiveConstructor">here</a><a id="29911" class="Symbol">;</a> <a id="29913" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Relation.Unary.Any.html#1227" class="InductiveConstructor">there</a><a id="29918" class="Symbol">)</a>
<a id="29920" class="Keyword">import</a> <a id="29927" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Membership.Propositional.html" class="Module">Data.List.Membership.Propositional</a> <a id="29962" class="Keyword">using</a> <a id="29968" class="Symbol">(</a><a id="29969" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Membership.Setoid.html#882" class="Function Operator">_∈_</a><a id="29972" class="Symbol">)</a>
<a id="29974" class="Keyword">import</a> <a id="29981" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Properties.html" class="Module">Data.List.Properties</a>
  <a id="30004" class="Keyword">using</a> <a id="30010" class="Symbol">(</a><a id="30011" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Properties.html#33246" class="Function">reverse-++-commute</a><a id="30029" class="Symbol">;</a> <a id="30031" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Properties.html#3709" class="Function">map-compose</a><a id="30042" class="Symbol">;</a> <a id="30044" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Properties.html#3026" class="Function">map-++-commute</a><a id="30058" class="Symbol">;</a> <a id="30060" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Properties.html#15963" class="Function">foldr-++</a><a id="30068" class="Symbol">)</a>
  <a id="30072" class="Keyword">renaming</a> <a id="30081" class="Symbol">(</a><a id="30082" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Properties.html#38952" class="Function">mapIsFold</a> <a id="30092" class="Symbol">to</a> <a id="mapIsFold"></a><a id="30095" href="../Lists/#30095" class="Function">map-is-foldr</a><a id="30107" class="Symbol">)</a>
<a id="30109" class="Keyword">import</a> <a id="30116" href="https://agda.github.io/agda-stdlib/v1.3/Algebra.Structures.html" class="Module">Algebra.Structures</a> <a id="30135" class="Keyword">using</a> <a id="30141" class="Symbol">(</a><a id="30142" href="https://agda.github.io/agda-stdlib/v1.3/Algebra.Structures.html#2523" class="Record">IsMonoid</a><a id="30150" class="Symbol">)</a>
<a id="30152" class="Keyword">import</a> <a id="30159" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Unary.html" class="Module">Relation.Unary</a> <a id="30174" class="Keyword">using</a> <a id="30180" class="Symbol">(</a><a id="30181" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Unary.html#3536" class="Function">Decidable</a><a id="30190" class="Symbol">)</a>
<a id="30192" class="Keyword">import</a> <a id="30199" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.html" class="Module">Relation.Binary</a> <a id="30215" class="Keyword">using</a> <a id="30221" class="Symbol">(</a><a id="30222" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.Definitions.html#4575" class="Function">Decidable</a><a id="30231" class="Symbol">)</a>
</pre>
<p>The standard library version of <code>IsMonoid</code> differs from the one given here, in that it is also parameterised on an equivalence relation.</p>
<p>Both <code>Relation.Unary</code> and <code>Relation.Binary</code> define a version of <code>Decidable</code>, one for unary relations (as used in this chapter where <code>P</code> ranges over unary predicates) and one for binary relations (as used earlier, where <code>_≤_</code> ranges over a binary relation).</p>
<h2 id="unicode">Unicode</h2>
<p>This chapter uses the following unicode:</p>
<pre><code>∷  U+2237  PROPORTION  (\::)
⊗  U+2297  CIRCLED TIMES  (\otimes, \ox)
∈  U+2208  ELEMENT OF  (\in)
∉  U+2209  NOT AN ELEMENT OF  (\inn, \notin)</code></pre>
    </div>
    <nav class="pager">
    <ul class="pagination">
        
        <li><a class="pagelink" href="../Decidable/">Prev</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Lists.lagda.md">Source</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="../Lambda/">Next</a></li>
        <li class="separator">&bullet;</li>
        
    </ul>
</nav>

</article>

            </div>
        </main>
        <footer class="site-footer h-card">
    <data class="u-url" href="../"></data>
    <div class="wrapper">
        <h2 class="footer-heading">Programming Language Foundations in Agda</h2>
        
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Philip Wadler</li>
                    <li>
                        
                        <a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/wadler" title="wadler"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;wadler</a></li>
    
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Wen Kokke</li>
                    <li>
                        
                        <a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;wenkokke</a></li>
    
    
    <li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#twitter"></use></svg>&nbsp;wenkokke</a></li>
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Jeremy G. Siek</li>
                    <li>
                        
                        <a class="u-email" href="mailto:jsiek@indiana.edu">jsiek@indiana.edu</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/jsiek" title="jsiek"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;jsiek</a></li>
    
    
    <li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#twitter"></use></svg>&nbsp;jeremysiek</a></li>
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        
        This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
    </div>
</footer>

    </body>
</html>
